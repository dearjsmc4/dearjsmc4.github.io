<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Page 4 | Rudy&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="Rudy&#39;s Blog">
<meta property="og:url" content="https://dearjsmc4.github.io/page/4/index.html">
<meta property="og:site_name" content="Rudy&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rudy&#39;s Blog">
  
    <link rel="alternate" href="/atom.xml" title="Rudy&#39;s Blog" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body>


  


<header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="Rudy&#39;s Blog" rel="home"> Rudy&#39;s Blog </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class href="/tags">Tags</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-0510" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/05/10/0510/">전역변수 문제점, 모듈패턴, 프로퍼티 정의, 생성자 함수</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/05/10/0510/" class="article-date">
	  <time datetime="2019-05-09T15:00:00.000Z" itemprop="datePublished">May 10, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/javascript-til/">Javascript TIL</a>
 
      <!--  -->
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="전역-변수의-문제점"><a href="#전역-변수의-문제점" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h2><ol>
<li><p>중복 선언이 가능하다.<br> var 키워드의 경우 중복 선언이 가능한데, 이때 의도치않은 재할당이 일어날 수 있다.</p>
</li>
<li><p>생명 주기가 길다.<br> 스코프에 식별자가 등록되면 태어나는 것이고, 스코프가 죽으면 그 스코프의 변수도 죽는다. 전역 변수는 스코프가 소멸되지 않는다. 전역 스코프가 소멸되면 다른 window 전역 객체들도 다 못 쓰게 되는 것이다. 게다가 변수가 소멸되지 않으면 계속 메모리공간을 차지하고 있게 되는 문제도 있다.  </p>
</li>
</ol>
<p>함수의 생명 주기가 끝날 때는 식별자가 함수 객체를 가리키고 있는 그 참조를 끊어버리고 나중에 다시 함수를 호출하면 다시 참조하게 된다. 함수는 최대한 간결하고 짧게(스코프를 좁게) 만들고, 함수 하나당 할 일도 하나만 준다. 변수가 태어나자마자 빨리 소멸되도록 하는 것이다.</p>
<ol start="3">
<li><p>누구나 접근 가능하고 누구나 변경 가능하다. 값이 변할 확률이 높다.<br> 예상치못한 값의 변경은 에러를 일으키기 딱 좋다.  </p>
</li>
<li><p>네임 스페이스 오염<br> 브라우저에서는 파일별로 스코프가 생기지 않는다. 따라서 각 파일마다 전역변수를 따로 설정하더라도 브라우저에서 변수가 충돌할 수 있다.</p>
</li>
</ol>
<p><strong>캡슐화</strong>:<br>인터넷에서 내가 쓰지 않은 남의 댓글은 특별한 방법을 쓰지 않는 이상 삭제하거나 수정할 수 없다. 애초에 삭제나 수정버튼이 제공되지 않기 때문이다. 이처럼 어떤 변수를 아무나 참조하거나 변경할 수 없게 하고 싶다면 캡슐화를 통해 변수를 숨겨버릴 수도 있다. 자바스크립트는 클로저를 통해 캡슐화를 한다.  </p>
<h2 id="모듈패턴"><a href="#모듈패턴" class="headerlink" title="모듈패턴"></a>모듈패턴</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// private 변수</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        increase()&#123;</span><br><span class="line">            <span class="keyword">return</span> ++num;</span><br><span class="line">        &#125;,</span><br><span class="line">        decrease()&#123;</span><br><span class="line">            <span class="keyword">return</span> --num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter.num); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.increase()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.decrease()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>전역 변수를 사용하지 않는 방법 중 하나다. (이해가 안 되면 외워야 한다)<br>중첩함수가 외부함수보다 더 오래 살아남으면 그것을 클로져라고 한다. 함수 객체는 생성되어질때 자신의 상위스코프를 기억한다. (렉시컬 스코프와 연결되는 얘기다) 그래서 외부함수가 죽었어도 중첩함수가 갖고있던 상위스코프는 살아있다. 따라서 참조도 가능하고, 상위스코프에 있던 지역변수는 자유변수가 된다. 살아있는 상위스코프를 참조하고 있으니까 상태유지도 가능하다. 하지만 밖에서 변수 num 을 참조할 순 없다. 중첩함수만이 외부함수를 참조하고 변경할 수 있다.  </p>
<!-- 외부스코프를 나타내는 객체가 사실은 절대 죽지 않으니까 메모리낭비가 아닌가?
요즘 브라우저에서 클로져를 엄청나게 최적화해놔서 괜찮다는듯...
100개의 변수가 있더라도 참조하는 변수만 기억함. 나머지는 기억안함. -->
<h2 id="프로퍼티-정의"><a href="#프로퍼티-정의" class="headerlink" title="프로퍼티 정의"></a>프로퍼티 정의</h2><p>프로퍼티를 정의한다는건 프로퍼티 생성과 다르다.<br><code>Object.getOwnPropertyDescriptor</code> 메소드가 반환하는 게 프로퍼티의 어트리뷰트들인데, 이것들은 자바스크립트 엔진이 프로퍼티를 생성할 때 자동으로 기본값으로 정의해준다. 함수로 이렇게 정의된 어트리뷰트들을 바꿀 수도 있지만 실제로 그렇게 할 일이 많지는 않다.<br><!-- (enumerable : 열거가능한지. for in 문같은걸로 돌렸을 때 열거될수있는지.) --><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> me = &#123;</span><br><span class="line">name : <span class="string">'Rudy'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(me,<span class="string">'name'</span>));</span><br><span class="line"><span class="comment">//&#123;value: "Rudy", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="내부슬롯-내부메소드"><a href="#내부슬롯-내부메소드" class="headerlink" title="내부슬롯/내부메소드"></a>내부슬롯/내부메소드</h3><p>ECMAScript 스펙에서 나오는 말…<br><code>[[Call]]</code> 이나 <code>[[Prototype]]</code> 처럼 대괄호가 두 개 겹쳐있는 애들이 내부슬롯이다.<br><!-- ecmascript 스펙이 뭔가. 스펙은 설계서. 일을 왜하는지, 어떻게하는지. 
자바스크립트엔진을 어떻게 구현해야하는지.
내부 슬롯, 내부 메소드는  --><br>자바스크립트 엔진이 코드를 실행하는 알고리즘을 설명하기 위해 ECMAScript 스펙에서 사용하는 의사 프로퍼티. 자바스크립트엔진은 내부슬롯과 내부메소드의 사양을 만족시키는 것이 중요하다. 이 내부 슬롯은 내가 직접 접근할 수는 없고 필요하다면 간접적으로 접근 가능하다. 하지만 접근할 수 없게 만든 것들에는 역시 접근하지 않는 것이 좋겠다.  </p>
<h3 id="데이터-프로퍼티와-접근자-프로퍼티"><a href="#데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="데이터 프로퍼티와 접근자 프로퍼티"></a>데이터 프로퍼티와 접근자 프로퍼티</h3><p>프로퍼티에는 두 가지 종류가 있다. 데이터 프로퍼티와 접근자 프로퍼티이다.<br>위에서 살펴보았듯, <code>Object.getOwnPropertyDescriptor</code> 는 객체가 가지고 있는 프로퍼티의 정의값을 본다. 프로퍼티 어트리뷰트들을 담아서 프로퍼티 디스크립터라는 객체를 반환해준다고 하는데, 데이터 프로퍼티에는 value, writable, enumerable, configurable 이렇게 네 가지 어트리뷰트가 있다. 보통 우리가 보는 대부분의 프로퍼티는 데이터 프로퍼티이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(me,<span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "Rudy", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>접근자 프로퍼티에는 자체적으로는 값이 없고, 다른 데이터 프로퍼티의 값을 가져오거나 갱신할 때 쓴다.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(me.__proto__);</span><br><span class="line"><span class="comment">// &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>__proto__</code> 는 접근자 프로퍼티이다. 접근자 프로퍼티에는 value 가 보이지 않는다.  </p>
<h2 id="생성자-함수에-의한-객체-생성"><a href="#생성자-함수에-의한-객체-생성" class="headerlink" title="생성자 함수에 의한 객체 생성"></a>생성자 함수에 의한 객체 생성</h2><p>타입변환할 때 쓸 수 있는 방법 중 하나가 생성자 함수인데, 생성자함수는 타입변환이 주 업무가 아니다.<br>생성자 함수는 매개변수로 외부정보를 받아서 new 연산자와 함께 호출하여 여러 개의 객체를 만들어낼 수 있는 함수다. constructor 라고 한다. 리터럴 표기법으로도 여러 개의 객체를 만들 수 있지만, 한 번에 하나의 객체만 만들어낼 수 있고, 그러므로 여러 개를 만들려면 그만큼의 노가다가 필요하다. 게다가 같은 로직이 중복될 수 있는 문제가 있다. 또한 재사용이 불가능하다. 리터럴 표기법으로는 객체가 생성되고 말 뿐, 미리 만들어진 프로퍼티를 사용할 수는 없기 때문이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Object</span>());</span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>당장 콘솔창에서 <code>new Object();</code> 를 찍어보면 빈 객체가 만들어지는 것을 볼 수 있다. <strong>Object 생성자 함수</strong> 라고 한다. 물론 new 연산자를 붙이지 않아도 자바스크립트 엔진이 new 연산자가 붙어있는 것처럼 동작하기는 하지만, new 연산자를 붙여주는 것이 정석이니 그렇게 하도록 하자. 만들어진 빈 객체에는 프로퍼티나 메소드를 추가할 수 있다. 그런데 이렇게 일일이 추가하여 만들 것이라면 리터럴로 만드는 것보다 그렇게 큰 메리트는 없다. 객체를 만드는 방법에는  </p>
<ul>
<li>리터럴표기법  </li>
<li>Object 생성자 함수  </li>
<li>생성자 함수(우리가 만든)(중요!)  </li>
<li>Object.create() 함수  </li>
<li>Class  </li>
</ul>
<p>등이 있지만 생성자 우리가 만드는 생성자 함수를 먼저 살펴보자.<br><del>왜냐면 마지막 2개는 아직 안 배웠다.</del>  </p>
<!-- 인자로 원시값을 주면 랩핑해서 문자열이면 문자열객체를 만들고 숫자면 숫자객체를 만든다.
원시값을 객체처럼쓰면(메소드를 쓰면) 자바스크립트엔진이 그것을 객체타입으로 만든다. 
메소드를 호출하고 난 후에 변경된값을 반환하고 다시 원래값으로 돌아간다(부수효과가없음)
래퍼객체. 원시값타입을 객체로 바꾸는거 -->
<h3 id="생성자-함수가-객체를-만드는-방법"><a href="#생성자-함수가-객체를-만드는-방법" class="headerlink" title="생성자 함수가 객체를 만드는 방법"></a>생성자 함수가 객체를 만드는 방법</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Rudy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me);</span><br><span class="line"><span class="comment">// Person &#123;name: "Rudy"&#125;</span></span><br></pre></td></tr></table></figure>
<p>(객체 앞에 붙어있는 Person 은 생성자 함수의 이름이다.)<br>new 연산자와 함께 생성자 함수가 호출되면, 생성자 함수 내부로 컨트롤이 이동하여 두 가지의 암묵적인 동작이 일어난다.  </p>
<ol>
<li>빈 객체를 만들어서  </li>
<li>this에 할당한다.(이를 <strong>this 바인딩</strong> 이라고 한다.)  </li>
</ol>
<p>그리고 <code>this.name = &#39;Rudy&#39;;</code> 와 같이 프로퍼티들을 추가하고 할당해준다. 이것이 프로퍼티 동적추가/동적생성이다.<br>이때 <strong>this는 생성자함수가 (미래에) 생성할 객체(인스턴스)</strong>를 가리킨다. 마지막에는 암묵적으로 <strong>this 인 객체</strong>를 반환한다.  </p>
<p>생성자 함수 내부에 return문이 없더라도 생성자 함수는 암묵적으로 this 를 반환해준다. 그러므로 굳이 return 문을 넣을 필요도 없고 넣어서도 안 된다. 만약 return 문을 넣게 되면 무시되거나, 원시값을 리턴하도록 설정해둔 경우 this 가 아닌 원시값이 리턴되어버린다.  </p>
<p>생성자 함수를 new 없이 호출하면 일반함수호출이 되고, 이때의 this 는 무조건 생성자 함수가 만들어낼 객체가 아니라 전역 객체인 window 가 된다. 그리고 return 문이 없으므로 undefined 가 반환된다. 그래서 생성자함수가 일반함수와 똑같이 생겼더라도 <strong>반드시 new 로 호출</strong>해야 한다. 애초에 생성자 함수의 함수명을 파스칼케이스로 써서 구별하도록 약속되어 있으니 잘 알아보고 호출하도록 하자(이것도 개발자들끼리의 약속이지, 자바스크립트 엔진이 알아주는 것은 아니다). 이처럼 함수도 다양한 방식으로 호출할 수 있고 그때마다 this가 동적으로 결정된다.  </p>
<p>그리고 this 바인딩이라고 하였는데, 변수에는 값을 <em>할당</em> 한다고 하고 식별자에는 값을 <em>바인딩</em> 한다고 한다.  </p>
<!-- - 일반 객체를 호출할 수 없는 이유?  
함수 객체만 가지고있는
`[[call]]` 과 `[[constructor]]` 내부메소드가 없기때문이다.
일반함수,    생성자함수.
이렇게 둘로 나눠놓고 new 를 붙엿나 안붙엿나 검사를 한단다.
new가 붙으면 생성자함수니까... -->
<p>일반함수는 다 호출할 수 있지만 생성자 함수로 호출할 수 있는 함수는 정해져 있다. 화살표함수는 생성자 함수로 호출할 수 없다. 화살표함수는 콜백으로 자주 쓰이고, 생성자 내부메소드가 없다. 객체 내에서 메소드축약표현으로 쓴 메소드 역시 생성자함수로 호출이 안 된다.  </p>
<ul>
<li><code>new.target</code><br>생성자 함수가 new와 함께 호출되었는지 아닌지를 검사한다. IE에서는 지원이 되지 않는다.  </li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/javascript-til/">Javascript TIL</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">Javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/">TIL</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-0508" class="article article-type-post" itemscope itemprop="blogPost">
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2019/05/08/0508/">원시 값과 객체, 함수, 스코프</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/05/08/0508/" class="article-date">
	  <time datetime="2019-05-07T15:00:00.000Z" itemprop="datePublished">May 8, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/javascript-til/">Javascript TIL</a>
 
      <!--  -->
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="원시-값"><a href="#원시-값" class="headerlink" title="원시 값"></a>원시 값</h2><p><strong>변경 불가능한 값.</strong> 변수와 헷갈리면 안 된다. 변수 자체가 값도 아닐 뿐더러, 변수는 당연히 변수값이 변한다. 그런데 변수가 가지고 있는 값 자체가 원시 값(숫자, 문자, 불리언, null, undefined, symbol)일 때 값은 바뀌지 않는다. 상수하고도 헷갈리면 안 된다. <strong>상수도 값을 갖고 있을 수 있는 변수</strong>이다. 단지 재할당을 못할 뿐이지. 그래서 변하지 않는 수라고 하면 상수하고 헷갈리기 쉽다.<br><code>const a = {};</code> 일 때는 빈 객체를 변경할 수 있다. 객체는 객체타입이며 변경가능한 값이기 때문이다. <strong>변경 불가능하다는 것은 재할당 불가능하다는 것이 아니다.</strong><br><!-- 변수가 나쁜 건 아니지만 남발하면 안 좋다. 왜냐면 대부분의 에러가 변수때문에 나기 때문에. 따라서 변수는 스코프를 좁혀서 얼른 쓰고 얼른 버리는 게 좋다. 다른 곳에서 변경되지않도록.   --><br>대부분의 언어에서 문자열은 객체로 취급받는데 자바스크립트는 원시 값으로 취급받는다. <strong>재할당 이외의 방법으로는 절대 변할 수 없기 때문에 신뢰성이 보장</strong>된다. 요즘은 객체도 ‘얼려서’ 변경을 못하도록 하기도 한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;그럼 객체도 처음부터 원시 값으로 만들지 그랬냐&quot; </span><br><span class="line">-&gt; 객체를 하나 만든다는 게 생각보다 비용이 많이 드는 일이다. </span><br><span class="line">프로퍼티도 하나의 객체이고. 그러면 객체를 통째로 썼다 지웠다 하는 것보단 차라리 </span><br><span class="line">변경 가능하게 만드는 게 더 나은 일일 것이다. 신뢰성과 맞바꾸더라도... </span><br><span class="line">게다가 원시 값은 Pass by Value, 값을 복사해서 넘겨주는 전달인데, </span><br><span class="line">만약 객체를 통째로 복사해서 전달한다면 큰 낭비이기도 하다.</span><br></pre></td></tr></table></figure></p>
<p>(+)<br><strong>가비지컬렉터</strong>: 메모리공간의 값을 지우고 다니는 애가 아니라, 메모리공간의 할당을 해제하고 다니는 애다. 메모리공간 확보라는 건 ‘여기 쓸 거니까 건들지마’ 라는거고, 메모리공간 해제라는 건 ‘여기 쓰는 사람 없으니까 써도 돼’ 라는 것.  </p>
<h2 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h2><p>객체를 할당한 변수가 확보한 메모리공간에는 객체가 실제로 저장된 메모리공간의 주소가 저장되어있고, 이를 <strong>참조값</strong>이라고 한다. 식별자가 객체를 가리키고 있는(point) 상태이다. 참조값(메모리주소) 자체는 원시값이라서 바꿀 수 없지만 메모리공간에 저장된 실제 객체는 변경 가능하다. 객체 리터럴이 평가되어 값이 된다는 건 메모리에 이진수로 저장된다는 말이다. 두 개의 식별자가 한 객체를 공유한다는 건 한 쪽이 데이터를 변경하면 다른 한 쪽도 영향을 받으므로 부작용이 된다.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person1 === person2); <span class="comment">// ①</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name === person2.name); <span class="comment">// ②</span></span><br></pre></td></tr></table></figure>
<p>1번은 false, 2번은 true 가 나온다.<br>객체 비교는 참조값이 달라서 false고, 2번은 원시값 비교(‘Lee’)가 되기 때문에 true이다.</p>
<h2 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h2><p>함수 안으로 필요한 정보를 밀어넣고(input) 값을 만들면 그 값을 내보낸다(output).<br><code>function</code> 키워드는 함수 선언이라기보다는 <strong>함수 정의</strong>라고 하자.<br>함수 정의만으로 함수가 실행되는 것은 아니고, <strong>함수 호출</strong>이라는 트리거가 있어야 한다. <code>return</code>은 옵션이고, return 을 안 쓰면 암묵적으로 undefined 가 반환된다(완료 값). 매개변수도 변수라서 인수가 할당된다. 매개변수는 함수 몸체 안에서만 유효하다.<br>함수는 <strong>재사용</strong>을 위해 쓴다. 코드의 중복을 줄이고, 유지보수를 편리하게 한다. 실수가 줄어들고 품질도 좋아지고 돈도 적게 든다. 같은 코드가 여기저기 흩어져있으면 무언가를 고쳐야 할 때 여기저기 흩어진 코드에 다 찾아가서 고쳐줘야 한다.<br>함수명도 함수 몸체 내에서만 유효한 식별자이다. (보통 재귀함수에서 쓴다) 함수를 호출 할 때 보통 <code>foo();</code> 라고 하는데, 이때 foo 는 함수명이 아니라 자바스크립트 엔진이 함수명으로 암묵적으로 생성한 식별자이다.<br>인수 = argument<br>인자 (매개변수) = parameter  </p>
<h3 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h3><ol>
<li>함수 선언문  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>함수 선언문은 함수명이 필수다.<br>함수명 안 쓰고 변수에 할당하면 그게 함수 표현식이 된다.  </p>
<ol start="2">
<li>함수 표현식  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>변수 선언문 + 할당문.  </p>
<p>함수 선언문을 썼을 때, 자바스크립트 엔진이 암묵적으로 함수명과 같은 식별자를 등록하여 식별자가 함수 객체를 가리키게 하고, 그 식별자를 이용해 함수를 호출하게 된다. 함수 표현식도 var 키워드로 인해 foo 라는 식별자가 등록이 되고 함수 객체를 가리키게 된다. 똑같이 동작하는 것 같지만 사실 조금 다르다. 만약 코드 상으로 함수를 정의하기 전에 호출을 먼저 하게 되면 함수 선언문의 경우 함수 호이스팅에 의해 hello 가 콘솔에 출력된다. 함수 선언문은 foo 라는 식별자를 만듦과 동시에 함수 객체까지 메모리공간에 할당해버리기 때문이다. 하지만 var 키워드를 이용한 함수 표현식은 foo 라는 식별자가 등록만 되어있는 상태이기 때문에 호출하게 되면 foo 는 함수가 아니라는 에러가 뜬다.  </p>
<p>(+)<br>일반 객체와 함수 객체의 차이?<br>일반 객체와 달리 함수 객체는 호출할 수 있다. </p>
<p>인수와 매개변수의 개수가 일치하지 않아도 에러가 나지는 않는다.<br>매개변수의 갯수는 정해져 있지는 않지만 적을 수록 좋고, 3개까지 쓰는 게 제일 좋다. (왜인지 잘 기억이 안 나므로 알아보고 업데이트 하겠음)<br>3개가 넘어가면 그것들을 객체로 만들어서 넘기면 좋다.<br><!-- 강사님 추천 책: 클린 코드   --></p>
<ul>
<li>반환문 <code>return</code>  <ol>
<li>리턴 키워드 뒤에 지정한 값을 반환.  </li>
<li>함수의 실행을 중단하고 함수몸체를 빠져나간다. 값을 리턴했는데 뭘 더 할 게 없으니까.<br>리턴 뒤에 어떤 값을 적지 않아도 된다. 그냥 함수를 빠져나갈 뿐.  </li>
</ol>
</li>
</ul>
<h3 id="즉시실행함수"><a href="#즉시실행함수" class="headerlink" title="즉시실행함수"></a>즉시실행함수</h3><p>정의와 동시에 호출되는 함수. 함수 정의하면 함수 객체가 만들어지고, 그 객체는 호출할 수 있으니까 끝에 () 로 호출. 단 한 번 호출할 수 있다. 그래서 뭐 함수명을 식별자로 만들고 어쩌구 저쩌구도 안한다. 그냥 메모리를 단 한 번 쓰고 사라진다. 이름을 붙여줄 수도 있지만 재귀를 하지 않는 이상 이름이 의미가 없다. 즉시실행함수는 반드시 그룹연산자 (…) 로 묶어주거나 function 키워드 앞에 <code>!</code> 이나 <code>+</code> 를 붙여주어야 한다. 보통 그룹연산자로 묶은 뒤 그 안에서 호출까지 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  [실행 코드]</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<h3 id="중첩-함수"><a href="#중첩-함수" class="headerlink" title="중첩 함수"></a>중첩 함수</h3><p>함수가 함수 안에서 정의되었다. 외부함수를 도와주는 헬퍼함수의 역할을 한다. 스코프와 연관이 있다. 외부함수도 스코프를 만들고 내부함수도 스코프를 만드니까 스코프도 중첩이 된다. </p>
<h3 id="콜백함수"><a href="#콜백함수" class="headerlink" title="콜백함수"></a>콜백함수</h3><p>외부에서 밀어넣어주는 헬퍼함수. 두 함수를 합친다. 중첩함수는 태생적으로 함수 안에 있는거고 콜백은 밖에서 밀어넣어진다. 내가 넘기는 콜백함수에 따라 함수가 하는 일이 달라질 수 있다.</p>
<h2 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h2><p>식별자는 값과 바인딩이 되어있다. 왜냐면 값 없이는 식별자는 의미가 없기 때문이다. 스코프는 상하관계가 있다. 이 상하관계는 중첩관계에 의해서 만들어진다. 중첩된 함수 내부에서 선언된 변수는 하위스코프에, 외부함수에서 선언된 변수는 상위스코프에. 전역변수는 전역스코프에 있다. 자바스크립트는 함수가 스코프를 만들고, 이것을 함수레벨스코프라고 한다(var 키워드가 지원하는…). let이나 const는 블록레벨스코프를 지원한다.<br>똑같은 코드도 어디있느냐에 따라(문맥에 따라) 다르게 동작한다. 똑같은 말이라도 어떤 상황에서 하냐에 따라 다른 것처럼. 그 문맥이 스코프다.<br>자식객체는 부모객체의 자산을 쓸 수 있지만 그 반대는 안 된다. 하위스코프의 변수를 상위스코프에서 참조할 수 없다. 내 스코프에서 참조할 변수의 선언을 찾지 못하면 상위로 찾아 올라간다. 상위스코프와 하위스코프가 연결된 것을 <strong>스코프체인</strong>이라고 하는 것이다.  </p>
<!-- 렉시컬?
사전으로는 어휘의, 단어의.. 라는 뜻인데. 렉싱은 어휘를 뜻하고. 음... 식별자들이 렉시컬환경에 등록된다고 생각하면 그냥 식별자라는 어휘들을 모아두는 환경이라고 보면 안 되나? -->
<!-- 함수 선언문, 하면 선언이니까 식별자가 만들어지고 식별자는 함수객체를 가리킨다. 
그러니까 스코프체인에서 변수를 검색하는것과 똑같이 동작함.
스코프는 선언될 때에 결정됨.
함수 안의 변수는 호출될지안될지모르기때문에 실행할때 함수가 호출되면 그때 선언.
-->
<h3 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ?</span></span><br><span class="line">bar(); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>
<p>스코프가 결정되는데에는 두 가지 방식이 있다.  </p>
<ol>
<li>함수를 어디서 호출했는지에 따라 상위 스코프가 결정되거나  </li>
<li>함수를 어디서 정의했는지에 따라 상위 스코프가 결정된다.  </li>
</ol>
<p>자바스크립트는 <strong>함수를 어디서 정의했는지</strong>에 따라 상위 스코프가 결정된다. 즉 2번에 해당되고, 이를 <strong>정적 스코프</strong>, 또는 <strong>렉시컬 스코프</strong>라고 한다(1번은 동적 스코프라고 한다). 함수 bar 는 var x = 1; 과 같이 전역에서 정의되었기 때문에 bar 는 1를 출력한다. 만약 동적 스코프였다면 foo 함수 안에서 bar 가 호출되었기 때문에 foo 가 bar 의 상위 스코프가 되고, bar는 1이 아니라 10을 출력하게 될 것이다. </p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/javascript-til/">Javascript TIL</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">Javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/til/">TIL</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/5/">Next</a>
  </nav>

</section>
          <aside id="sidebar">
  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>Recent Posts</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/05/23/0523/">DOM, 동기식 &amp; 비동기식, 이벤트</a></h6>
              <span>May 23, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/05/22/0522/">클래스, 디스트럭처링, 모듈</a></h6>
              <span>May 22, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/05/20/0520/">정규표현식, 배열고차함수, 화살표함수, Rest/Spread</a></h6>
              <span>May 20, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/05/17/0517/">Object.prototype 접근, 배열</a></h6>
              <span>May 17, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/05/15/0515/">전역객체, this</a></h6>
              <span>May 15, 2019</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/2019/05/13/0513/">함수, 프로토타입</a></h6>
              <span>May 13, 2019</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/cs-til/">CS TIL</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">Javascript</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript-til/">Javascript TIL</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/기타/">기타</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/cs/">CS</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">CSS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">Javascript</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/til/">TIL</a><span class="tag-list-count">24</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">Web</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 Rudy&#39;s Blog All Rights Reserved.
        <!-- 
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
           -->
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
