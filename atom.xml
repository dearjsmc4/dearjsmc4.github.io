<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rudy&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dearjsmc4.github.io/"/>
  <updated>2019-05-03T02:43:29.255Z</updated>
  <id>https://dearjsmc4.github.io/</id>
  
  <author>
    <name>Hwang Yu-Soon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>컴퓨터 공학 TIL 0418</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0418/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0418/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T02:43:29.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="파이썬-기초와-알고리즘-2일차"><a href="#파이썬-기초와-알고리즘-2일차" class="headerlink" title="파이썬 기초와 알고리즘 2일차"></a>파이썬 기초와 알고리즘 2일차</h1><p>프로그래머는 프로그래밍(추상화) 하는 사람.  </p><ul><li>Procedual Programming : 함수를 통한 추상화<br>함수(function, (routine, procedure, subroutine))  </li><li>OOP(Object-Oriented Programming) : 객체를 통한 추상화  </li></ul><h3 id="함수에서의-추상화"><a href="#함수에서의-추상화" class="headerlink" title="함수에서의 추상화"></a>함수에서의 추상화</h3><p>함수 시그니쳐/인터페이스 와 내부구현을 구분하기  </p><ul><li>함수 시그니쳐(Function Signature)<br>-&gt; 함수 이름, 매개변수(parameter, argument), 결과값(반환)  </li><li>인터페이스(Interface)  </li><li>내부 구현(Implementation)  </li></ul><p>나는 <code>Math.pow()</code>함수를 사용할 때 내부 구현을 몰라도, 함수 시그니쳐만 알면 사용할 수 있다.<br>자바스크립트를 만든 사람들은 내부 구현을 맡아서 하는 것이고,<br>유저 프로그래머는 인터페이스만 알면 된다.<br>함수 시그니쳐를 모아놓은 것 -&gt; documentation  </p><h3 id="시그니쳐를-설계할-때-주의할-점"><a href="#시그니쳐를-설계할-때-주의할-점" class="headerlink" title="시그니쳐를 설계할 때 주의할 점"></a>시그니쳐를 설계할 때 주의할 점</h3><ol><li>함수 이름은 누가 봐도 이 함수가 하는 일이 뭔지 알 수 있게 지어야 한다.  </li><li>매개변수와 리턴값을 잘 설계해야 한다.<br>어떤 함수를 설계했을 때, 그 함수의 리턴값을 이용해 또다른 함수를 실행할 때 문제가 없도록.<br>예를 들어 내가 만든 함수는 문자형을 반환하는데, 다른 사람이 만든 함수가 숫자형을 매개변수로 받는 경우.<br>-&gt; “인터페이스도 안 맞추고 일하냐, 가관이다.” 소리가 나오는 상황.<br>-&gt; 기능 명세  </li></ol><h2 id="실수-real-number"><a href="#실수-real-number" class="headerlink" title="실수(real number)"></a>실수(real number)</h2><h3 id="부동-소수점"><a href="#부동-소수점" class="headerlink" title="부동 소수점"></a>부동 소수점</h3><ol><li><p>32비트로 실수를 표현하기 : <strong>단정도</strong> </p></li><li><p>64비트로 실수를 표현하기 : <strong>배정도</strong> -&gt; 자바스크립트  </p></li></ol><ul><li>첫 번째 비트는 부호를 의미 한다.  </li><li>가수부(mantissa)가 52bit 이다.  </li></ul><h3 id="64-실수-자료형-설계하기"><a href="#64-실수-자료형-설계하기" class="headerlink" title="64 실수 자료형 설계하기"></a>64 실수 자료형 설계하기</h3><p>실수 자료형을 표현한 수식<br><code>± 1.man × 2^exp - bias</code><br>1.man 은 가수(mantissa), 2는 밑수, exp-bias 는 지수(exponent)  </p><h4 id="정규화"><a href="#정규화" class="headerlink" title="정규화"></a>정규화</h4><p>정수부분을 0이 아닌 자연수로 만들기.<br>ex) 5234.433 -&gt; 5.234433 * 10^3  </p><ul><li>10진수 실수 10.625를 2진수 실수로 바꾸고 정규화<br>10.625 -&gt; 1010.101(2) -&gt; <code>1</code>.010101(2) * 2^3  </li></ul><p>2진수의 경우 0이 아닌 자연수는 1밖에 없다.<br>그래서 실제 가수부는 1.010101 이지만<br>정수부분을 뺀 소수부분 <code>010101</code> 을 가수부(mantissa)에 저장한다.<br>(나머지 부분은 0으로 채운다)<br>배정도의 가수부는 52bit 이지만,<br>-&gt; <code>&gt;&gt;&gt; sys.float_info.mant_dig</code> 이 53이었던 이유.  </p><p>(+)</p><p>10진수를 2진수가 커버할 때,<br>한 자리 수 중에 가장 큰 수인 9를 커버하려면<br>2진수 4자리가 필요하다. <code>1111(2) = 15</code><br>두 자리 수 중에 가장 큰 수인 99를 커버하려면<br>7자리가 필요하다. <code>1111111(2) = 127</code>  </p><p>이때, 가수부를 53자리까지 (맨 앞의 1 포함) 키운다면<br>9,007,199,254,740,991 까지 커버할 수 있고, 총 15자리이다.<br>-&gt; <code>&gt;&gt;&gt; sys.float_info.dig</code> 가 15인 이유.  </p><h4 id="exp-bias"><a href="#exp-bias" class="headerlink" title="exp-bias"></a>exp-bias</h4><p>1.010101(2) * 2^<code>3</code><br>지수를 저장하기.  </p><p><code>± 1.man * 2^exp-bias</code><br>즉, 3이 exp-bias 이다.<br>bias 는 음수를 지원하기 위해 IEEE 가 자체적으로 만든 프로토콜.<br>ex) 만약 -8 을 저장해야 한다면?  </p><p>double 의 bias 를 구하는 식은,<br><code>bias = 2^n-1 - 1</code><br>n은 지수부의 비트 수를 뜻한다.<br>double 의 지수부의 비트 수는 11bit 이므로,<br>bias = 2^11-1 - 1<br>bias = 2^10 - 1 = 1023  </p><p>지수부에는 3이 들어가야 맞는 것이지만, 편향치를 고려하여 저장해야 한다.<br>내가 저장해야 하는 실제 지수 값과 편향치를 안다면 메모리에 저장할 값도 알 수 있다.  </p><p><code>Ere = Emem - bias</code><br>즉, <code>Emem = Ere + bias</code>  </p><p>Emem = 3 + 1023 = 1026 이 된다.  </p><p><strong>이제 필요한 값은 다 구했다</strong>  </p><p><code>± 1.man × 2^exp - bias</code>  </p><ol><li>sign : 0  </li><li>exponent(exp - bias) : Emem = 1026 = 01000000001(2)  </li><li>mantissa : 010101000000…. (52bit를 채울 때까지 0을 넣는다)  </li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;파이썬-기초와-알고리즘-2일차&quot;&gt;&lt;a href=&quot;#파이썬-기초와-알고리즘-2일차&quot; class=&quot;headerlink&quot; title=&quot;파이썬 기초와 알고리즘 2일차&quot;&gt;&lt;/a&gt;파이썬 기초와 알고리즘 2일차&lt;/h1&gt;&lt;p&gt;프로그래머는 프로그래밍(추
      
    
    </summary>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/categories/til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>파이썬 기초 문법</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0419-python/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0419-python/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T03:43:35.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="파이썬-자료형-기초"><a href="#파이썬-자료형-기초" class="headerlink" title="파이썬 자료형 기초"></a>파이썬 자료형 기초</h1><ul><li>string = “abcde”  <ul><li>string<code>[2]</code> = ‘c’  </li><li>string<code>[2:]</code> = ‘cde’ (2번 자리 이상)  </li><li>string<code>[:2]</code> = ‘ab’ (0번 이상, 2번 미만)  </li><li>string<code>[0:1]</code> = ‘a’ (0번 째 이상, 1번 미만)  </li><li>string<code>[0:2]+&quot;z&quot;+string[3:]</code> = ‘abzde’ ( ab + z + de )  </li><li>string<code>.replace(&#39;c&#39;,&#39;z&#39;)</code> = ‘abzde’ (c 를 z 로 바꾸어서 보여줌. 원본이 바뀌지는 않는다.)  </li></ul></li></ul><h3 id="문자열-포매팅"><a href="#문자열-포매팅" class="headerlink" title="문자열 포매팅"></a>문자열 포매팅</h3><p>문자열 내의 어떤 값을 삽입하는 방법.  </p><p>a = 10<br>b = ‘abcde’  </p><ul><li><code>print(&quot;%d, %s&quot; %(a,b))</code> = 10, abcde  </li><li><code>print(&#39;숫자는 {0} 문자열은 {1}&#39;.format(a,b))</code><br>  = 숫자는 10 문자열은 abcde  </li><li><code>print(f&#39;숫자는 {} 문자열은 {}&#39;)</code><br>  = 숫자는 10 문자열은 abcde  </li></ul><p>a = 0.1234512345  </p><ul><li><code>print(f&#39;{a:.3}&#39;)</code> = 0.123 (소수점 뒤의 3자리까지만 자르기)  </li></ul><h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h3><ul><li>dic = {‘a’:1, 2:’two’, ‘func’:lambda a,b: a+b}<ul><li>dic<code>[&#39;a&#39;]</code> = 1 (a라는 키의 value를 가져오기)  </li><li>dic<code>[func](1,2)</code> = 3 (func 라는 키의 value 인 함수를 실행)<br>  lambda: 함수가 위치한 메모리 주소값  </li><li>dic.<code>keys()</code> = dict_keys([‘a’, 2, ‘func’]) (dic 의 모든 키값을 가져오기)  </li><li>dic.<code>items()</code> = dict_items<code>([(&#39;a&#39;, 1), (2, &#39;two&#39;), (&#39;func&#39;, &lt;function &lt;lambda&gt; at 0x05B738E8&gt;)])</code><br>  (key와 value값이 튜플로 묶여서 나옴) -&gt; 튜플인 이유가 있나?  </li><li>key_list = <code>list(dic.keys())</code> = [‘a’, 2, ‘func’] (key만 모아서 리스트로 만들기)  </li></ul></li></ul><p><strong>list 와 view 객체와의 차이</strong><br>key_view = dic.keys() = dict_keys([‘a’, 2, ‘func’])<br>key_list = [‘a’, 2, ‘func’]<br>일 때,<br><code>dic[5]=&#39;five&#39;</code> 딕셔너리에 쌍을 추가하면<br>key_view = dict_keys([‘a’, 2, ‘func’, <code>5</code>]) -&gt; 추가되었음<br>key_list = [‘a’, 2, ‘func’] -&gt; 추가 되지 않았음  </p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>집합 자료형인 세트에서는 중복이 허용되지 않는다.  </p><p>s1 = set([1,2,3,4])<br>s2 = set([3,4,5,6])  </p><ul><li><code>s1|s2</code> or <code>s1.union(s2)</code>= {1,2,3,4,5,6} (합집합)  </li><li><code>s1&amp;s2</code> or <code>s1.intersection(s2)</code>= {3,4} (교집합)  </li><li><code>s1-s2</code> or <code>s1.difference(s2)</code> = {1,2} (차집합)  </li><li><code>s2-s1</code> or <code>s2.difference(s1)</code> = {5,6} (차집합)  </li><li><code>s1^s2</code> or <code>s1.symmetric_difference(s2)</code>= {1,2,5,6} (대칭 차집합)  </li></ul><h3 id="True-False"><a href="#True-False" class="headerlink" title="True / False"></a>True / False</h3><ul><li><strong>거짓</strong>으로 취급하는 데이터  <ul><li>“” 빈 문자열  </li><li>[] 빈 리스트  </li><li>() 빈 튜플  </li><li>{} 빈 딕셔너리  </li><li>false  </li><li>none (JS의 undefined)  </li><li>0  </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;파이썬-자료형-기초&quot;&gt;&lt;a href=&quot;#파이썬-자료형-기초&quot; class=&quot;headerlink&quot; title=&quot;파이썬 자료형 기초&quot;&gt;&lt;/a&gt;파이썬 자료형 기초&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;string = “abcde”  &lt;ul&gt;
&lt;li&gt;strin
      
    
    </summary>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/categories/til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0419</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0419/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0419/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T02:43:57.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="파이썬-기초와-알고리즘-3일차"><a href="#파이썬-기초와-알고리즘-3일차" class="headerlink" title="파이썬 기초와 알고리즘 3일차"></a>파이썬 기초와 알고리즘 3일차</h1><p><code>.replace()</code> - 원본의 데이터를 바꾸지 않음.  </p><ul><li><p>튜플은 <strong>성능 최적화</strong>를 위해 존재.<br>데이터를 바꿀 수 없기 때문에 데이터를 가져와서 읽는 용도로만 사용한다.<br>리스트보다 빠르다. 튜플을 쓸 수 있다면 튜플을 쓸 것.  </p></li><li><p>딕셔너리 = “Collection of Pairs”<br>pair = <code>key : item</code><br>키와 밸류가 한 쌍으로 모여있다.  </p></li><li><p>뷰객체와 리스트객체의 차이<br>원본에 데이터를 추가했을 때 뷰 객체에서는 변경사항이 저장되지만 리스트는 안됨.  </p></li></ul><p>파이썬은 단순성이 존재목적.  </p><ul><li>expression: 식.<br>무언가를 반환할 수 있다면 그것은 식이다.<br>단항식 역시 참과 거짓, 혹은 값 자체를 반환할 수 있으므로 식이다.  </li></ul><p>a+b : <code>이항식. binary expression</code><br>“abc” : <code>단항식 unary expression</code>  </p><p>파이썬에서는 함수도 식이다.<br>식이라면 반드시 무언가를 반환해야 한다.<br>print() 도 함수고, 반환이 없어보이지만 실제로는 none 을 반환함.  </p><p><code>stdin</code> : standard input (키보드), 0<br><code>stdout</code> : standard output (모니터), 1<br><code>stderr</code> : standard error (모니터), 2  </p><h2 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h2><ul><li>ASCII  </li><li><p>UNICODE  </p><ul><li>UTF-8  </li><li>UTF-16  </li><li>UTF-32  </li><li>~CP949~  </li></ul></li><li><p>문자집합 :<br>영어, 불어, 독일어는 언어체계는 다르지만 같은 문자집합을 공유한다.  </p></li><li><p>문자 인코딩 : 모스부호처럼 문자를 부호화하는 것.<br>  반대로 모스부호를 문자로 만드는 것은 복호화.  </p></li><li><p>코트 포인트 : 내 맘대로 a를 13으로 바꿀 수 없다. 전세계 사람들이 약속을 해야 한다.<br>  a = 97 일때, a는 chracter 고, 97은 코드포인트. 어떠한 문자에 매핑되어있는 숫자.<br>  이렇게 매핑된 문자와 숫자를 테이블로 정리를 해놓은 것이 ASCII.  </p></li></ul><p>ASCII의 치명적 약점 : </p><ol><li>7비트만 사용할 수 있고 127개까지만 문자가 매핑되어있다.  </li><li>영어밖에 없다.  </li></ol><p>-&gt; <strong>UNICODE</strong><br>16비트짜리 평면을 17개 만들었다.<br>ASCII 코드가 임베디드 되어 있다.  </p><ul><li>UTF-8<ul><li>8비트 기반</li><li>아스키에 소속된 영어는 여전히 1바이트, 한글은 3바이트로 저장됨  </li></ul></li></ul><p>big endian &amp; little endian &amp; endian less(빅, 리틀 상관없이 그 자체가 저장됨)  </p><ul><li>단순 정렬 알고리즘(bubble sort)<br><a href="https://blueshirudy.tistory.com/13" target="_blank" rel="noopener">과정 정리해본 노트</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;파이썬-기초와-알고리즘-3일차&quot;&gt;&lt;a href=&quot;#파이썬-기초와-알고리즘-3일차&quot; class=&quot;headerlink&quot; title=&quot;파이썬 기초와 알고리즘 3일차&quot;&gt;&lt;/a&gt;파이썬 기초와 알고리즘 3일차&lt;/h1&gt;&lt;p&gt;&lt;code&gt;.replace
      
    
    </summary>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/categories/til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0423-1</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0423-1/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0423-1/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T02:44:21.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="메모리-계층-주요-키워드"><a href="#메모리-계층-주요-키워드" class="headerlink" title="메모리 계층 (주요 키워드)"></a>메모리 계층 (주요 키워드)</h2><p><em>지금은 모르더라도 나중에 꼭 알아둬야할 내용</em></p><ol><li>레지스터  </li><li>캐시  <ul><li>지역성 원리(principle of locality) -&gt; 캐시 히트, 캐시 미스  </li></ul></li><li>메모리  <ul><li>segmentation  <ul><li>코드  </li><li>데이터  </li><li>힙 (slow)  </li><li>스택 (fast)  </li></ul></li><li>가상메모리  <ul><li>page  </li><li>page frame  </li><li>page fault  </li><li>page title  </li></ul></li></ul></li><li>하드디스크  </li></ol><h2 id="Big-O"><a href="#Big-O" class="headerlink" title="Big O"></a>Big O</h2><p>데이터 갯수가 늘어날 때 T(n)이 어떤 식으로 늘어나는가<br>(어떤 형태의 그래프를 그리는가) 우리의 주 관심사.<br>그래프의 모양만 알기 위해서는 최고차항만 필요하다. -&gt; <code>O(n^2)</code></p><p><strong>이해가 안 되면 외워</strong>  </p><ol><li>O(a): 상수 시간<br> ex) 배열의 인덱싱  <pre><code>링크드 리스트의 삽입,삭제  </code></pre></li><li>O(log n): 로그 시간<br> ex) BST - insert, search, delete  </li><li>O(n): 선형 시간<br> ex) 링크드 리스트의 탐색 / 특정배열에서의 삽입,삭제  </li><li>O(n log n): 선형 로그 시간<br> ex) quick sort, merge sort<br> 비교 정렬(comparison sorting)의 경우 성능이 아무리 좋아도 O(n log n)보다 성능이 좋을 순 없다.  </li><li>O(n^2): 지수 시간<br> ex) 버블 소트, 선택 정렬, 삽입 정렬  </li></ol><hr><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><ul><li>Job scheduling -&gt; scheduler<br>-&gt; context switching<br>process status(프로세스 상태)<br>thread -&gt; multi threading(cpu 작업이 많을 때)  </li></ul><p>multi threading 의 문제  </p><ul><li>race condition  </li><li>dead-lock </li></ul><h3 id="Concurrency-Programming-동시성-프로그래밍"><a href="#Concurrency-Programming-동시성-프로그래밍" class="headerlink" title="Concurrency Programming (동시성 프로그래밍)"></a>Concurrency Programming (동시성 프로그래밍)</h3><ul><li><code>Asyncronous I/O</code><br>자바스크립트는 헤비한 연산 하지 않는다.<br>따라서 I/O bound 작업에만 쓴다.  </li></ul><h2 id="program-과-process"><a href="#program-과-process" class="headerlink" title="program 과 process"></a>program 과 process</h2><ul><li>program :<br>하드디스크에 저장되어 있는 “하나”의 이미지  </li><li>process :<br>메인 메모리에 올라와서 <code>실행</code>을 시작한 프로그램  </li></ul><p>notepad.exe 라는 프로그램은 하나이지만(program),<br>노트패드 창을 여러 개 띄워서 <code>실행</code>(process) 수 있다.<br>실행되고 있는 여러 개의 notepad 는 <code>PID</code> 를 부여하여 구분  </p><h3 id="선점형-스케줄링과-비선점형-스케줄링"><a href="#선점형-스케줄링과-비선점형-스케줄링" class="headerlink" title="선점형 스케줄링과 비선점형 스케줄링"></a>선점형 스케줄링과 비선점형 스케줄링</h3><ul><li><p>선점형 스케줄링(pre-emptive scheduling) : 새치기가 가능하다.  </p><ol><li><p>created : process 생성<br>OS의 스케줄러가 <strong>우선순위</strong>를 파악  </p></li><li><p>waiting : Queue 실행 대기 상태<br>우선순위가 높으면 이미 실행 중인 프로세스를 waiting 으로 보내고 실행됨<br>-&gt; <code>Priority Algorithm</code><br>우선순위가 같다면 <strong>정해진 시간동안</strong> 실행<br>-&gt; <code>Round Robin Algorithm</code>  </p></li></ol><ul><li>time slice  </li><li><p>quantum  </p><p>정해진 시간동안의 실행이 모두 끝나면 상태가 어떻든 무조건 queue 로 돌아감<br>-&gt; <code>aging</code><br>우선순위가 높은 프로세스들이 들어와서 우선순위가 낮은 프로세스가 실행되지 못하고<br>무한히 대기중인 상태인 <strong>기아상태</strong> 를 해결하기 위한 방법. 오랫동안 대기한<br>프로세스의 우선순위를 점진적으로 증가시켜 실행할 수 있도록 해준다. </p><p><em>I/O 작업</em><br>파일 입출력이나 네트워크 작업<br>CPU가 필요없고 미친듯이 느리다.<br>-&gt; blocked 로 가서 작업이 완료된 후 waiting 으로 갔다가 running 으로.  </p><p>-&gt; waiting 과 blocked<br>waiting 은 cpu 가 부르면 바로 올라갈 수 있다.<br>blocked 는 i/o 가 끝날 때까지 무조건 기다려야 함.</p></li></ul><ol start="3"><li>running : CPU 할당(실행)<br>실행이 끝나면 terminated  </li></ol></li><li><p>비선점형 스케줄링 : 새치기가 불가능하다.  </p></li></ul><h3 id="context-switching"><a href="#context-switching" class="headerlink" title="context switching"></a>context switching</h3><p>정해진 시간동안의 실행이 끝나면 무조건 queue 로 돌아가서 waiting 상태가 되는데,<br>queue 로 끌어내려지는 시점에서 CPU 레지스터에 저장되어있는 실행상태정보(IR과 PC 등)를<br>PCB라는 별도의 공간에 저장한다.  </p><ul><li>Instruction Register: 실행되고 있는 부분  </li><li>Program Counter: 다음 실행될 코드를 가리키고 있는 부분  </li><li>PCB(Process Control Block)<br>그리고 다시 실행할 차례가 돌아오면 PCB의 내용을 다시 CPU에 넣어서 실행할 수 있도록 한다.<br>  -&gt;(디스패치라고도 한다)  </li></ul><p>context switching 이 많이 일어나면 시스템에 과부하가 생긴다.<br>100분의 1초마다 프로세스가 전환이 되면, 1초에 컨텍스트스위칭이 100번 일어나는 것인데,<br>두 프로세스를 실행하기 위해 그 사이에 작업이 추가되는 것이니까<br>그만큼 일종의 오버헤드가 걸릴 수 있다. </p><p><em>context switching 을 안할 수 없는 이유</em><br>라운드로빈에서 시간이 다 될 때마다 끌어내려질건데<br>이때는 무조건 컨텍스트 스위칭이 일어날 수 밖에 없음.<br>그렇다고 컨텍스트스위칭을 줄이겠다고 5초마다 한 번 한다면<br>내가 뭔가 할때마다 최소 5초는 기다려야한다는 뜻.<br>즉, 멀티태스킹이 아니게 되는거임.<br>그렇다고 내가 기다리는 시간을 줄여서 컨텍스트 스위칭을 많이 하면 시스템 과부하가 일어나고.<br>-&gt;<code>sys.getswitchinterval() == 0.005</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;메모리-계층-주요-키워드&quot;&gt;&lt;a href=&quot;#메모리-계층-주요-키워드&quot; class=&quot;headerlink&quot; title=&quot;메모리 계층 (주요 키워드)&quot;&gt;&lt;/a&gt;메모리 계층 (주요 키워드)&lt;/h2&gt;&lt;p&gt;&lt;em&gt;지금은 모르더라도 나중에 꼭 알아
      
    
    </summary>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/categories/til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0423-2</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0423-2/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0423-2/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T02:44:30.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="process-와-thread"><a href="#process-와-thread" class="headerlink" title="process 와 thread"></a>process 와 thread</h2><p>process : 인스트럭션의 나열.<br>OS 가 프로세스에게 할당해주는 메모리는 실제 메모리가 아닌 <strong>가상 주소 공간(VAS)</strong><br>각 프로세스에 할당된 메모리는 가상메모리.  </p><h3 id="IPC-InterProcess-Communication-프로세스간-커뮤니케이션"><a href="#IPC-InterProcess-Communication-프로세스간-커뮤니케이션" class="headerlink" title="IPC: InterProcess Communication, 프로세스간 커뮤니케이션"></a>IPC: InterProcess Communication, 프로세스간 커뮤니케이션</h3><p>프로세스간 공간은 완전히 분리되어 있으므로,<br>기본적으로 프로세스끼리 서로의 데이터에 직접적으로 접근하거나 데이터를 바꿀 수는 없다.<br>그럼에도 불구하고 별도로 커뮤니케이션을 해야 할 때가 있다.<br>성능을 높이기 위해 여러 프로세스를 동시에 실행할 때<br>( ex) 웹 서버가 사용자 요청이 올 때마다 새로운 프로세스를 만들어 즉시 대응 )<br><em>프로세스간 상태 확인 및 데이터 송수신</em> 이 필요하기 때문이다. 이때 쓰는 것이 IPC기법이다.<br>대부분의 IPC기법은 각 프로세스가 공유하는 커널공간을 이용한다.  </p><ul><li><p>Shared resource</p></li><li><p>Multi Threading<br>여러 개의 실행흐름이 필요하다 -&gt; concurrency programming<br>동시에 도는 것 같은 실행흐름.  </p></li></ul><p>스레드는 프로세스에 포함된 개념.<br>우리가 만든 프로그램은 스레드가 하나.<br>스레드가 하나면 <code>싱글스레드</code>.<br>자바스크립트는 흐름이 하나밖에 없는 것.  </p><h3 id="멀티스레딩"><a href="#멀티스레딩" class="headerlink" title="멀티스레딩"></a>멀티스레딩</h3><p><code>멀티스레드</code>는 흐름이 여러 개인 것.<br>스레드가 각자의 스택을 따로 가지고 있다.<br>실행흐름이란게 인스트럭션인데 인스트럭션은 함수 실행. 함수가 실행되려면 스택프레임이 필요하고<br>이 스택프레임은 스택에 쌓인다.<br>코드와 데이터와 힙은 공유를 하고 스택만 따로 따로 가지고 있다.<br>여러 개의 스레드가 공유자원을 공유.  </p><p>Shared Resource(각 스레드가 접근하는 하나의 자원) 가 있을 때<br>race condition, 경쟁조건이 발생한다.<br>-&gt; 상호배제 를 통해 예방<br>-&gt; <strong>GIL : Global Interpreter Lock</strong><br>공유자원을 먼저 점유한 스레드가 작업을 마치고 릴리즈를 할 때까지 다른 스레드들이 기다리게 한다.  </p><p>모든 스레드가 접근해서 사용하는 리스트: shared list<br>각 스레드가 접근하는 리스트가 같을 때, 그 안에서 접근하는 데이터는 다른 것이 좋다.  </p><h3 id="동시성-프로그래밍과-병렬-프로그래밍"><a href="#동시성-프로그래밍과-병렬-프로그래밍" class="headerlink" title="동시성 프로그래밍과 병렬 프로그래밍"></a>동시성 프로그래밍과 병렬 프로그래밍</h3><p><strong>동시성 프로그래밍</strong>은 cpu(프로세스)가 하나여도 동시성 프로그래밍을 구현할 수 있다.<br>멀티스레딩을 하게되면 라운드로빈으로 돌아갈 수 있으니까.<br>하지만 여러 개를 하나씩 순서대로 돌리는거지, 엄밀한 의미의 병렬은 아니다.<br><strong>병렬 프로그래밍</strong>은 아예 하드웨어가 최소 두 개 이상 있어서<br>어떤 태스크가 있을 때 각 하드웨어가 일을 같이 처리하는 것이다.<br>2초 걸릴 일을 1초만에 할 수 있는 것이다.  </p><p>싱글코어 멀티스레딩: 단순하게 동시성프로그래밍. 스레드를 여러 개 만들어서 실행.<br>멀티코어 멀티스레딩: 병렬 + 동시성. 동시에 두 개 이상 돌 수 있는 것.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;process-와-thread&quot;&gt;&lt;a href=&quot;#process-와-thread&quot; class=&quot;headerlink&quot; title=&quot;process 와 thread&quot;&gt;&lt;/a&gt;process 와 thread&lt;/h2&gt;&lt;p&gt;process : 인스트럭
      
    
    </summary>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/categories/til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0422</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0422/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0422/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T02:44:13.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1><ol><li>namespace  </li><li>stack frame  </li><li>call by value<br>call by reference<br>call by object reference  </li></ol><p><em>“왜 call by value 와 call by reference 를 나누는가?”</em>  </p><h2 id="전역변수-vs-지역변수"><a href="#전역변수-vs-지역변수" class="headerlink" title="전역변수 vs 지역변수"></a>전역변수 vs 지역변수</h2><ul><li>지역변수가 생기는 시점은?<br><code>def func(): b=20</code><br>라고 함수를 선언해둘 때가 아니라, 함수를 실행할 때.  </li></ul><p>namespace = 변수가 저장되어 있는 공간. 함수가 가지는 자기만의 공간.  </p><h2 id="stack-frame"><a href="#stack-frame" class="headerlink" title="stack frame"></a>stack frame</h2><p>함수가 실행될 때 함수 내부적으로 연산에 필요한 지역변수들이 쌓이는 공간.<br>블로킹이 걸리면 새로운 함수에게 다시 주도권이 넘어감.<br>함수 실행(연산)이 끝나면 연산에 필요한 변수들은 사라지고 스택프레임도 사라짐.<br>그리고 블로킹 걸렸던 시점에서부터 다시 실행이 되고 원래 함수에게 주도권 넘어감.<br>함수 실행이 종료되면 연산에 필요없는 변수가 다 사라지고,<br>실행 주도권은 다시 글로벌 프레임으로 넘어온다.<br>(파이썬 튜터로 스택프레임을 비주얼적으로 보면 좋다.)  </p><ul><li>call by value :<br>  변수의 값 10을 복사해서 단순히 <strong>값</strong>을 스택프레임에 넘겨주는 것.  </li><li>call by reference :<br>  변수의 값이 아니라 <strong>주소값</strong>을 전달함. = 참조값을 전달하는 것과 같다.<br>  주소값을 알고 잇으면 주소값을 통해 접근할 수 있다.<br>  원래 블로킹 상태라면, 실행 중인 함수의 프레임을 벗어나서 참조할 수 없는데,<br>  주소값으로 전달하면 주소값을 참조하여 <strong>현재 실행중인 프레임의 바깥 스택프레임의 변수에 접근할 수 있다.</strong><br>  <code>*a = 30</code> -&gt; a의 메모리 자체에 접근하여, 그 메모리에 값 30을 넣겠다.  </li></ul><p><strong>call by value와 call by reference의 차이</strong><br>-&gt; 새로운 스택프레임이 쌓였을 때  </p><ul><li>call by value : 그 어떤 변수를 이용하더라도 바깥으로 접근할 수 없다.<br>실행하고 있는 프레임 바깥의 데이터에 접근하는게 완벽히 불가능하다.  </li><li>call by reference : 스택프레임이 갈라지고, 새로운 프레임이 실행하는 상황에서 특정 변수를 이용해<br>바깥 프레임의 데이터에 접근하여 값을 수정하는 것이 가능하다.  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;함수&quot;&gt;&lt;a href=&quot;#함수&quot; class=&quot;headerlink&quot; title=&quot;함수&quot;&gt;&lt;/a&gt;함수&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;namespace  &lt;/li&gt;
&lt;li&gt;stack frame  &lt;/li&gt;
&lt;li&gt;call by value&lt;br&gt;cal
      
    
    </summary>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/categories/til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0424</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0424/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0424/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T02:44:41.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOP-꼭-공부해야-함"><a href="#OOP-꼭-공부해야-함" class="headerlink" title="OOP (꼭 공부해야 함)"></a>OOP (꼭 공부해야 함)</h1><ol><li>캡슐화(encapsulation) : 정보 은닉을 포함  </li><li>정보 은닉(information hiding)  </li><li>다형성 (polymophism) : 상속(inheritance)<br> -&gt; 메소드 오버라이딩(method overriding)<br> -&gt; 함수 오버로딩과 헷갈리면 안됨.  </li><li>디자인 패턴(SOLID)  <ul><li>Single responsibility principle(단일 책임 원칙)  </li><li>Open-closed principle(확장-폐쇄 원칙)  </li><li>Liskov substitution principle(리스코브 치환 원칙)  </li><li>Interface segregation principle(인터페이스 분리 원칙)  </li><li>Dependancy inversion principle (의존 역전 원칙)  </li></ul></li></ol><p><strong>객체 지향</strong><br>객체지향 : 관련 있는 변수와 함수를 묶어둠.<br>    변수 : 상태정보(<code>데이터</code>)<br>    함수(여기선 함수가 아니라 메서드) : <code>기능</code>   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Account:</span><br><span class="line">    #생성자(constructor): 객체를 생성할 때 반드시 한번호출한다 --&gt; Account() 형태로 쓴다</span><br><span class="line">    def __init__(self, cust_name, init_balance):</span><br><span class="line">        # 인스턴스 멤버(속성, 데이터, 변수)를 설정</span><br><span class="line">        self.name=cust_name</span><br><span class="line">        self.balance=init_balance</span><br><span class="line">    #소멸자(destructor): 객체가 소멸될 때 반드시 한번 호출</span><br><span class="line">    def __del__(self):</span><br><span class="line">        pass</span><br><span class="line">    #인스턴스 메서드(기능, 행동)</span><br><span class="line">    def deposit(self, money):</span><br><span class="line">        if money &lt; 0:</span><br><span class="line">            return False</span><br><span class="line">        #관련 있는 변수 : 인스턴스멤버</span><br><span class="line">        self.balance+=money</span><br><span class="line">        return True</span><br><span class="line">        </span><br><span class="line">    def withdraw(self, money):</span><br><span class="line">        if money &gt; self.balance:</span><br><span class="line">            return 0</span><br><span class="line">        self.balance -= money</span><br><span class="line">        return money</span><br><span class="line">    </span><br><span class="line">    def transter(self, other, money):</span><br><span class="line">        self.balance -= money</span><br><span class="line">        #다른 객체의 멤버에 바로 접근하지 않는다는 것이 원칙이다</span><br><span class="line">        #다른 객체의 멤버값(데이터)을 변경할때는 반드시 상대 객체가 가진 메서드에 위임해야한다.</span><br><span class="line">        # = 메시지 패싱 </span><br><span class="line">        other.deposit(money)</span><br></pre></td></tr></table></figure><p>-&gt; <strong>입력값은 같지만 상태정보에 따라 결과값은 다르게 나온다</strong></p><h1 id="네트워크"><a href="#네트워크" class="headerlink" title="네트워크"></a>네트워크</h1><h2 id="Network-Interface-물리계층-데이터-링크-계층-mac-address-담당"><a href="#Network-Interface-물리계층-데이터-링크-계층-mac-address-담당" class="headerlink" title="Network Interface(물리계층, 데이터 링크 계층): mac address 담당"></a>Network Interface(물리계층, 데이터 링크 계층): mac address 담당</h2><h3 id="LAN-amp-WAN"><a href="#LAN-amp-WAN" class="headerlink" title="LAN &amp; WAN"></a>LAN &amp; WAN</h3><ul><li><p>LAN : <code>Local Area Network</code><br>같은 지역 내에서 라우터를 통해 서로 연결.<br>아이피주소가 필요없이 물리주소만 알고있으면 라우터를 거치지 않고도 연결이 가능.<br>맥주소를 통해 LAN 안에서만 데이터를 주고받는 프로토콜 = <code>이더넷 프로토콜</code><br>패킷 : 패킷의 맨 윗 부분에 이더넷 헤더가 들어감.<br>이더넷 헤더에는 패킷을 받을 상대방의 맥주소와 송신자의 맥주소가 들어감.<br>받는 사람과 보내는 사람은 같은 LAN 안에 존재해야함.<br><code>MTU(maximum transfer unit)</code> : 한번에 보낼 수 있는 데이터의 크기.<br>패킷은 한번에 1500바이트를 넘지 않는다.  </p></li><li><p>WAN : <code>Wide Area Network</code>  </p></li></ul><h2 id="Internet-네트워크-계층-IP담당"><a href="#Internet-네트워크-계층-IP담당" class="headerlink" title="Internet(네트워크 계층): IP담당"></a>Internet(네트워크 계층): IP담당</h2><p><code>ARP(Address Resolution Protocol)</code>: 브로드캐스트로 어떤 IP 를 사용하는 호스트의 맥 주소를 알아낸다.   </p><p><strong>How? :</strong><br>서로 맥 주소를 모르는 상태에서 호스트1과 호스트2가<br>이더넷 프로토콜을 이용해 데이터를 주고 받고 싶을 때.<br>이때 호스트1이 특별한 <code>패킷</code>을 만들어서 송신자부분에 자신의 아이피와 맥 주소를 쓴다.<br>그리고 수신자 부분엔 호스트2의 아이피를 써놓음. 맥주소는 00:00:00… 과 같이 쓴다.<br>라우터에게 패킷을 던진다.<br>“이거 <code>브로드캐스트</code>로 좀 쏴줄래?” -&gt; 마치 방송하듯이 모든 호스트에게 패킷을 다 보낸다.<br>다른 호스트들이 패킷을 받았을 때, 아이피주소를 보고 자신의 것과 같은지 확인한 후에 무시하거나 리스폰스 한다.<br>호스트2는 <code>리스폰스 패킷</code>을 보낸다.<br>보내는 호스트에다가 자신의 아이피주소와 맥주소를 쓰고<br>받는 호스트에는 처음에 보냈던 호스트1의 주소를 그대로 써서 보낸다.<br>-&gt; 이제 서로의 맥주소를 알게 되었으므로 <code>라우터를 거치지 않고 직접</code> 통신한다.<br>호스트1: “나 이제 호스트2 주소 알아! 직접 통신하자.”<br>한번 ARP를 하고 나면 <code>ARP 테이블</code>(모든 컴퓨터에 다 있음)에다가 맥주소를 저장해둔다.  </p><h3 id="IP프로토콜"><a href="#IP프로토콜" class="headerlink" title="IP프로토콜:"></a>IP프로토콜:</h3><p>IPv4 : 내 아이피주소, 서브넷마스크, 게이트웨이  </p><ul><li><code>아이피</code>는 주소. 4바이트로 구성이 되어있다. 한 자리당 1바이트, 0~255까지.<br>  첫번째 자리에서 클라스 단위를 구분한다.  </li><li><code>서브넷마스크</code>: 어디까지가 네트워크 주소인가?<br>호스트아이디에 할당된 비트를 서브넷으로 쪼갤 수 있다.<br>호스트아이디중에 앞의 두 개 비트를 서브넷아이디로.<br>네트워크가 여러 개일때 연결할 수 있는 호스트의 수는 적어진다.  </li></ul><p>전세계적으로 유니크한, 세상에 하나 뿐인 <code>공인 아이피(public IP)</code>.<br><code>사설 네트워크(privite network)</code>가 구성되어 공인 아이피를 공유하고,<br>그들이 쓰는 아이피가 <code>사설 아이피(privite IP)</code>.<br>사설아이피는 동적으로 할당되기때문에<br>컴퓨터를 껐다 키면 바뀌어있다.<br>(커피숍에서 해킹을 해도 날 잡으러 오기는 힘든 이유.)  </p><h2 id="정렬-알고리즘"><a href="#정렬-알고리즘" class="headerlink" title="정렬 알고리즘"></a>정렬 알고리즘</h2><p>단순 알고리즘(비교정렬) : <a href="https://blueshirudy.tistory.com/13" target="_blank" rel="noopener">버블 정렬</a>,<br><a href="https://blueshirudy.tistory.com/19" target="_blank" rel="noopener">삽입 정렬</a>, <a href="https://blueshirudy.tistory.com/20" target="_blank" rel="noopener">선택 정렬</a><br>분할 정복: <a href="https://blueshirudy.tistory.com/18" target="_blank" rel="noopener">퀵 정렬</a>, 병합 정렬, 힙 정렬  </p><p><strong>분할 정복 기법(divide &amp; conquer)</strong><br>어떤 어려운 문제를 잘개 <em>쪼개서</em>,  작게 쪼개진 문제를 하나씩 <em>해결</em> 해나감으로써<br>작은 솔루션들이 모여 전체 문제에 대한 솔루션을 구하는 기법.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OOP-꼭-공부해야-함&quot;&gt;&lt;a href=&quot;#OOP-꼭-공부해야-함&quot; class=&quot;headerlink&quot; title=&quot;OOP (꼭 공부해야 함)&quot;&gt;&lt;/a&gt;OOP (꼭 공부해야 함)&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;캡슐화(encapsulation) :
      
    
    </summary>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/categories/til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0425</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0425/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0425/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T02:44:49.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Internet-네트워크-계층-IP담당"><a href="#Internet-네트워크-계층-IP담당" class="headerlink" title="Internet(네트워크 계층): IP담당"></a>Internet(네트워크 계층): IP담당</h2><p>IP는 IP라우팅을 한다.<br>인터넷 계층 : 아이피.(아이피주소는 내가 데이터를 보내고자 하는 상대 호스트 컴퓨터)<br>최종적으로 도달하는 <strong>호스트를 특정</strong>하기 위해 아이피주소가 필요함.<br>상대방의 호스트를 특정하기 위한 <strong>아이피주소를 관리</strong>하는 계층이 네트워크 계층.<br>강사님 추천 책: “TCP/IP 완벽 가이드”  </p><p><strong>NAT</strong> : 호스트1이 유투브에게 데이터를 요구하면 유투브는 공인아이피인 라우터까지는 보낼 수 있는데 정확히<br>어느 호스트가 보낸 건지 사설아이피까지는 알 수 없다. 그렇다고 늘 브로드캐스트로 보낼 수는 없다.<br>그래서 라우터는 랜카드 중 하나를 임대하여 사설 아이피를 공인 아이피와 매핑한다.<br>그리고 소스 아이피를 자신의 공인아이피로 바꿔서 보낸다.<br>서버가 영상을 공인아이피로 보내면, 변환테이블에서 공인아이피와 연결된 사설아이피를 찾는다.<br>그리고 사설아이피를 다시 목적지로 설정하여 보내준다. 랜카드가 많이 필요하다는 단점이 있다.  </p><p><strong>NAPT</strong> : 호스트가 서버와 통신하고자 할때, 모든 호스트들이 같은 랜카드를 빌려오되,<br>구분을 해야하므로 포트번호까지 이용하여 구분한다. 같은 123.108.157.1 이라는 랜카드를 써도<br>포트번호를 달리해서 쓰면 구분지을 수 있는 것이다.  </p><h2 id="Transport-전송계층-포트담당"><a href="#Transport-전송계층-포트담당" class="headerlink" title="Transport(전송계층): 포트담당"></a>Transport(전송계층): 포트담당</h2><p>특정 컴퓨터에게 데이터가 잘 도착했을 때 해당 <strong>프로세스</strong>에게 데이터를 전달하기위해 <code>포트번호</code>가 필요.<br>이 포트는 패킷이 필요한 프로세스를 특정하기 위해 사용된다.<br>이 <strong>포트를 관리</strong>하는 계층이 전송계층. 포트번호는 2^16-1 까지 할당가능하다.<br>패킷에는 아이피주소 말고도 포트번호가 쓰여있어서,<br>해당 포트번호가 특정하는 프로세스에게 데이터를 전송된다.<br>ex) 데이터를 보내긴 보내는데, 유투브 프로세스가 3개 돌아가고 있다면 그 중 어느 프로세스에 데이터를<br>    보낼 것인가?</p><p>서버에는 소켓이 많다. 서버는 특정 컴퓨터의 특정 프로세스일 뿐이다.<br>포트가 특정 프로세스를 특정한다고 했는데, 포트는 소켓에 부여된 숫자이다.<br>이 숫자가 0부터 2^16-1 까지. 2바이트짜리 정수.<br>소켓에는 두 가지 종류가 있다.  </p><ol><li><p>데이터를 전송하고 있는 <code>데이터 소켓</code><br>실제로 클라이언트와 일대일로 매핑되어 데이터를 주고 받는다.  </p></li><li><p>서버를 대표하는 <code>리스닝 소켓</code><br>클라이언트가 리퀘스트를 날릴 때 서버에서 데이터를 받는 소켓<br>리스닝 소켓은 클라이언트로부터 최초의 접속 요청을 받는 소켓<br>접속 후에 실제로 데이터를 주고받는 것은 데이터 소켓  </p></li></ol><p><code>well-known port</code>: 자주 쓰이는 유명한 포트번호.<br>0~1023 번까지 있는데 서버가 특정 서비스에 따라 특정 포트를 쓴다.  </p><p>전송계층에는 두 가지 프로토콜이 있다.  </p><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP / UDP"></a>TCP / UDP</h2><ul><li><p><strong>TCP</strong><br>신뢰도가 높다. 패킷이 유실되면 <strong>재전송</strong>을 해준다. HTTP는 일반적으로 TCP 위에서 돈다.<br>패킷을 보낸 다음에 상대방이 패킷을 잘 받았는지 인증을 받아서 확인한다.<br>-&gt; 패킷이 유실되었는지 계속 관리해야하기 때문에 네트워크에 부담이 된다.<br>파일 전송이나 메일 전송은 TCP를 이용한다.<br>연결 지향성: 서버와 호스트가 데이터를 주고받을 때 소켓을 가지고 접속과 연결이 되어야 한다.  </p></li><li><p><strong>UDP</strong><br>신뢰도가 낮다. 패킷이 유실되더라도 재전송을 해주지 않는다. 보내면 끝.<br>-&gt; 한번 보내면 끝이기 때문에 가볍고 빠르다.<br>동영상이나 빠른 속도가 필요한 게임 등은 UDP를 이용한다.<br>비연결 지향성: 접속이나 연결이 없이 그냥 보내기만 한다.  </p></li></ul><h2 id="Application-응용-표현-세션-계층"><a href="#Application-응용-표현-세션-계층" class="headerlink" title="Application (응용, 표현, 세션 계층)"></a>Application (응용, 표현, 세션 계층)</h2><p><code>Secure Socket Layer(SSL)</code>(Transport Layer Security)를 어플리케이션과 트랜스포트 사이에 끼워넣는다.<br>이 레이어는 <strong>암호화</strong>를 한다. 내가 html 과 js를 만들어서 보내면<br>다른 해커가 스푸핑을 통해서 파일들을 뺏더라도 암호화가 되어있어서 볼 수 없다.<br>받는 상대방은 <strong>복호화</strong>를 해서 볼 수 있다.  </p><ul><li>http: 메세지 기반의 프로토콜. 단순한 문자열을 주고 받고 해석함.<br>(html 파일이나 js 파일도 결국 문자열일 뿐이다)  </li><li>dns: 도메인 네임 시스템. 사람이 읽고 기억하기 쉬운 이름.<br>원래 어떤 사이트에 가려면 아이피주소를 써야하는데,<br>우리는 그 누구도 페이스북에 접속하려고 아이피를 적지 않는다. 대신 도메인 위치를 적는다.<br>그리고 DNS SERVER 에서 도메인 네임에 대한 아이피를 알려준다.<br>받아온 아이피는 캐시로 저장된다.  </li></ul><p><code>HTTP</code> : 하이퍼 텍스트 트랜스퍼 프로토콜<br>“나 이번에 새로 쓴 논문이 있어 인터넷에 링크 걸어둘게!”<br>원래는 진짜 정적파일 텍스트만 보는 용도였다.<br>http 1.0 이하에서는 연결이 일시적이다. 한번 데이터 주고받으면 끝.<br>그런데 점점 컴퓨터 성능이 좋아지니까 이미지나 동영상, 스크립트 파일도 받게 되었다.<br>그래서 한번 리퀘스트를 받은 다음에 한번의 리스폰스로 끝나는 게 아니게 되었다.<br>그래서 http 1.1부터는 연결을 유지한다. 한번 연결하면 끊지 않고 계속 연결.<br>만약 일시적 연결을 원한다면 헤더에 <code>connection:close</code> 를 포함하면 된다.  </p><p><strong>메서드</strong>: 클라이언트 요청의 종류  </p><ul><li><code>GET</code> : URL 이 지원하는 자원을 찾아 클라이언트에 전송</li><li><code>POST</code> : 클라이언트가 임의의 데이터를 서버로 보낸다.<br>주로 form 형식을 사용하며 서버의 프로그램에 전달</li><li>HEAD: GET과 같지만 메세지 본문이 없다. 테스트 용도</li><li>PUT: 지정한 URL에 요청의 본문내용을 저장</li><li>DELETE: 지정한 자원을 지움</li><li>TRACE: 클라이언트가 서버에 보낸 요청의 복사본을 돌려받는다.</li></ul><h3 id="상태코드"><a href="#상태코드" class="headerlink" title="상태코드"></a>상태코드</h3><p>200번대 : 성공<br>300번대 : 서버가 옮겨간것같은데 저쪽으로 다시 시도해볼래?<br>400번대 : 클라이언트가 잘못했다<br>500번대 : 서버가 잘못했다  </p><h3 id="컨텐트-협상"><a href="#컨텐트-협상" class="headerlink" title="컨텐트 협상:"></a>컨텐트 협상:</h3><ol><li><p>서버 주도 협상:<br> -&gt; 최선 추측<br>클라이언트가 원하는 것이 없을 때, 요청과 가장 비슷한 것을 가져감.  </p></li><li><p>에이전트 주도 협상:<br> 클라이언트가 자원을 고를 수 있음<br>-&gt; 클라이언트: 글 좀 보내봐<br>서버: 한국어도 있고 영어도 있고 프랑스어도 있는데… 뭐 보내지?<br>클라이언트: Accept - Language: kr;q=0.7, fr;q=0, en;q=0.4<br> “한국어가 최우선이고 한국어 없으면 영어 보내줘. 프랑스어는 있어도 보내지마”  </p></li></ol><ul><li>random pivot<br>리스트의 첫번째, 중간, 마지막 값을 가져와서 중간값을 찾아서 pivot 으로 설정.<br>-&gt; 거의 average case 에 가깝게 구현이 되더라는 것이 정설.  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Internet-네트워크-계층-IP담당&quot;&gt;&lt;a href=&quot;#Internet-네트워크-계층-IP담당&quot; class=&quot;headerlink&quot; title=&quot;Internet(네트워크 계층): IP담당&quot;&gt;&lt;/a&gt;Internet(네트워크 계층): IP
      
    
    </summary>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/categories/til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0417</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0417/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0417/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T02:43:18.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="파이썬-기초와-알고리즘-1일차"><a href="#파이썬-기초와-알고리즘-1일차" class="headerlink" title="파이썬 기초와 알고리즘 1일차"></a>파이썬 기초와 알고리즘 1일차</h1><p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener">What the heck is the event loop anyway?</a><br>목표 : 수업이 끝나고 이 영상의 내용을 100% 이해할 수 있는 것  </p><p>자바스크립트는 웹을 위한 언어로서 발전해왔기 때문에<br>자바스크립트가 가지는 단점과 한계를 숙지하고 있어야 한다.  </p><p>Foundation knowledge quiz  </p><ul><li>Recursion, index, sort, binary search -&gt; 자료구조. 알고리즘  </li><li>Stack / heap -&gt; 메모리 레이아웃. 메모리 계층. 세그먼트.  </li><li>Process, thread -&gt; OS  </li><li>Call by value / call by reference -&gt; 함수관련  </li><li>Native code  </li><li>MVC Architecture  </li><li>Write simple text-based games  </li></ul><p>오늘 배울 내용  </p><ol><li>메모리.  32bit와 64bit 의 차이는 무엇인가?  </li><li>Number. 컴퓨터가 실제로 아는 것은 0과 1뿐인데 어떻게 정수와 실수, 문자를 인식하고 표현하는가.<br>( 픽셀 역시 4바이트짜리 숫자에 불과하다는 것. )  </li></ol><h2 id="메모리"><a href="#메모리" class="headerlink" title="메모리"></a>메모리</h2><ul><li>32bit 컴퓨터와 64bit 컴퓨터의 차이  </li></ul><ol><li><p>컴퓨터는 0과 1을 전압으로 읽는다. 0v는 0이고, 5v는 1이다.<br>CPU와 RAM 사이를 연결하는 와이어가 있다.<br>전압은 와이어로 흐르는데, 와이어가 8개라면 8bit 의 데이터를 보낼 수 있다.<br>16bit 는 16개, 32bit 는 32개, 64bit 는 64개의 와이어가 깔려 있는 것이다.<br>32bit 프로그램, 32bit 운영체제, 32bit 컴퓨터는 다 다른 것이다.</p></li><li><p>메모리 주소값.<br>2진수로 32개의 자릿수를 메모리주소로 쓴다. -&gt; 32bit<br>2진수로 64개의 자릿수를 메모리주소로 쓴다. -&gt; 64bit<br>메모리에서는 1byte 당 메모리주소 자릿수 하나를 할당해준다. (1byte = 8bit)<br>32bit 컴퓨터는 0 ~ 2^32-1 까지 메모리를 할당할 수 있는데, 4GB 짜리 램에 이미 메모리주소가 모두 할당되기 때문에<br>램을 하나 더 꽂더라도 메모리 주소가 할당될 수 없고 접근할 수 없기 때문에 사용할 수 없게 된다.  </p></li></ol><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><ul><li>기수법  </li></ul><ol><li>2진수  </li><li>10진수  </li><li>16진수  </li><li>~8진수~  </li></ol><ul><li>10진수 : 0,1,2,3,4,5,6,7,8,9 - 한 자릿수에 표현할 수 있는 숫자가 10개. -&gt; 밑수, radix  </li><li>2진수 : 0,1 - 한 자릿수에 표현할 수 있는 숫자가 2개.  </li><li>16진수 : 0,1,2,3 … 9, a,b,c,d,e,f -&gt; radix 가 16개.  </li></ul><p>16진수 하나는 2진수 4개로 표현된다.<br>32bit 메모리 주소는 16진수 8개로 표현된다.  </p><ul><li>2진수(BIN)  </li><li>10진수(DEC)  </li><li>16진수(HEX)  </li></ul><h3 id="10진수-gt-2진수"><a href="#10진수-gt-2진수" class="headerlink" title="10진수 -&gt; 2진수"></a>10진수 -&gt; 2진수</h3><p>37을 2진수로 바꾼다면,<br>32(2^<code>5</code>) + 4(2^<code>2</code>) + 1(2^<code>0</code>)<br><code>5</code>,4,3,<code>2</code>,1,<code>0</code><br>-&gt; 100101(2)</p><ul><li>연습문제</li></ul><ol><li>27</li><li>289</li><li>1125</li></ol><h3 id="2진수-gt-10진수"><a href="#2진수-gt-10진수" class="headerlink" title="2진수 -&gt; 10진수"></a>2진수 -&gt; 10진수</h3><p>ex) 110010(2) = 2^5 + 2^4 + 2^1 = 32 + 16 + 2 = 50<br>거꾸로 543210 적어서 더하기  </p><ul><li>연습문제</li></ul><ol><li>1101(2)</li><li>1010(2)</li><li>1111(2)</li></ol><h3 id="2진수-gt-16진수"><a href="#2진수-gt-16진수" class="headerlink" title="2진수 -&gt; 16진수"></a>2진수 -&gt; 16진수</h3><p>111 1011 -&gt; 뒤에서부터 4자리씩 자르고 앞에 빈자리는 0을 채워넣는다.<br>0111 1011 -&gt; 0x7b<br>16진수의 0 ~ 9는 2진수의 0 ~ 9와 똑같다.<br>9 이상의 10~16 이 나오면 a부터 f까지 할당.<br>a부터 f까지의 2진수는 외우면 된다.<br>a : 1010<br>b : 1011<br>c : 1100<br>d : 1101<br>e : 1110<br>f : 1111  </p><ul><li>연습문제  </li></ul><ol><li>1111 1010(2)  </li><li>11 0101(2)  </li><li>101 1111 0110(2)  </li><li>111 0011 0011(2)  </li><li>101 0011 1001(2)  </li><li>1111 0000 0101 1100(2)  </li><li>0101 1100 1111(2)  </li><li>1111 1010 1100 1101(2)  </li></ol><h3 id="16진수-gt-2진수"><a href="#16진수-gt-2진수" class="headerlink" title="16진수 -&gt; 2진수"></a>16진수 -&gt; 2진수</h3><p>거꾸로 세어나간 후에 맨 앞의 0들은 지워버리기.<br>ex) 0xf137 = 1111 0001 0011 0111<br>    0x1fac = 0001 1111 1010 1100  </p><ul><li>연습문제  </li></ul><ol><li>0x1234  </li><li>0xf1ac  </li><li>0x7523  </li><li>0xfacd  </li></ol><h2 id="숫자"><a href="#숫자" class="headerlink" title="숫자"></a>숫자</h2><p>자바스크립트는 모든 숫자가 double.<br>실수형 double 은 8byte. 더블을 헨들하려면 fpu. 무척 헤비한데<br>자바스크립트에서는 cpu 작업을 할일이 별로 없어서 그렇다.<br>자바스크립트는 웹을 위한 언어.<br>네트워크 통신을 할 때 일어나는 I/O bound(인풋아웃풋 작업) 가 많이 일어난다.<br>자바스크립트는 이러한 IO 작업을 헤비하게 처리할 수 있도록 만들어진 언어이다.<br>그래서 숫자가 double 이어도 큰 상관이 없는 것이다.  </p><p>var a = 10<br>var b = 2.34<br>typeof(a)==typeof(b)<br>true<br>다른 언어에선 이와같은 결과가 불가능하다.<br>자바스크립트는 모든 숫자를 더블로 보기에 가능한 결과.</p><h3 id="정수-integer"><a href="#정수-integer" class="headerlink" title="정수(integer)"></a>정수(integer)</h3><ul><li><p>인티져 오버플로우<br>1바이트짜리 변수(-128부터 127까지 담을 수 있음)에 128이 들어가면 결과가 -128이 나오고<br>129 -&gt; -127<br>130 -&gt; -126<br>왜냐면 8비트를 사용한다고는 하지만 양수음수를 표현하려면 맨 앞의 첫 비트는 양수 / 음수를 구별할 sign 으로 쓰여야 하기 때문에<br>사실상 7비트만으로, 즉 양수 음수 각각 2^7 까지의 숫자를 표현한다고 볼 수 있다.  </p></li><li><p>1바이트(= 8비트) : 2^8, 256개의 숫자 가능<br>양수: 0~255. (0 ~ 2^8-1)<br>양수, 음수:  - 2^7 ~ 2^7-1 (-128 ~ 127) </p></li><li><p>2바이트(= 16비트) : 2^16, 65,536개의 숫자 가능<br>양수: 0 ~ 65535. (0 ~ 2^16-1)<br>양수, 음수:  - 2^15 ~ 2^15-1</p></li><li><p>4바이트(= 32비트) : 2^32, 4,294,967,296개의 숫자 가능<br>양수: 0 ~ 65535. (0 ~ 2^32-1)<br>양수, 음수:  - 2^31 ~ 2^31-1</p></li></ul><h4 id="양수의-표현"><a href="#양수의-표현" class="headerlink" title="양수의 표현"></a>양수의 표현</h4><p>1바이트(8비트)로 양수를 표현할 때<br>ex) 34 = 2^5 + 2^1 -&gt; 100010(2)<br>총 여덟자리를 할당하고 첫 비트는 sign 으로 쓴다.<br>뒤에서부터 채운 뒤 남는 자리는 0으로 채운다.<br>-&gt; <code>0</code>0100010</p><h4 id="음수의-표현"><a href="#음수의-표현" class="headerlink" title="음수의 표현"></a>음수의 표현</h4><ul><li><p>9의 보수<br>자릿수가 바뀌지 않으면서 가장 큰 수가 되는 것.<br>6은 3의 9의 보수.<br>74는 25의 9의 보수.  </p></li><li><p>10의 보수 (모든 9의 보수에 1을 더하면 10의 보수가 됨)<br>어떤 숫자에 수를 더하면 자릿수가 바뀌는 것.<br>3의 10의 보수는 7.<br>25의 10의 보수는 75.  </p></li></ul><p>음수는 2의 보수로 표현함.<br>ex)-43<br>43을 2진수로 바꾼 뒤 1바이트 정수형으로 표현하고 1의 보수에 1을 더해 2의 보수를 만든다.  </p><p>43 = 2^5 + 2^3 + 2^1 + 2^0 = 101011(2)<br>00101011 의 1의 보수 = 11010100<br>+1 -&gt; 11010101<br>1101 = d<br>0101 = 5<br>-43 = 0xd5  </p><p>(+)<br><a href="https://blueshirudy.tistory.com/12" target="_blank" rel="noopener">연습문제 풀이</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;파이썬-기초와-알고리즘-1일차&quot;&gt;&lt;a href=&quot;#파이썬-기초와-알고리즘-1일차&quot; class=&quot;headerlink&quot; title=&quot;파이썬 기초와 알고리즘 1일차&quot;&gt;&lt;/a&gt;파이썬 기초와 알고리즘 1일차&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/categories/til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0426</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0426/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0426/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T02:44:57.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ADT-abstract-data-type-추상-자료형"><a href="#ADT-abstract-data-type-추상-자료형" class="headerlink" title="ADT(abstract data type), 추상 자료형"></a>ADT(abstract data type), 추상 자료형</h2><p>자료구조의 인터페이스(함수 시그니쳐를, 함수 사용법을) 명시해 놓은 것. 기능 명세.<br>구체적인 구현설명이 들어가면 안 된다.<br>-&gt; 인터페이스와 내부구현의 분리, 추상화.  </p><p>이미 존재하는 자료구조를 이용해서 새로운 자료구조를 구현.<br>스택 구현 방법:  </p><ol><li>배열  </li><li>연결 리스트  </li><li>파이썬의 리스트  </li></ol><h3 id="스택"><a href="#스택" class="headerlink" title="스택"></a>스택</h3><p>접시쌓기를 생각해보자.<br>접시를 하나씩 위로 쌓는다면 보통은 위에서부터 하나씩 가져간다.<br>이처럼, 데이터1, 데이터2, 데이터3, 데이터4 가 쌓였을 때 데이터4 부터 먼저 사라지는 것.<br>제일 나중에 들어오면 제일 먼저 나간다. : <code>Last In First Out</code> = 후입선출  </p><p>pop: 삭제하면서 반환<br>peek: 다음으로 나올 데이터를 반환만 하고 삭제하지 않음  </p><p>일반적으로 스택의 맨 위 데이터는 top 으로 가리킨다.  </p><p><em>나중에 꼭 풀어볼 것</em>  </p><ol><li>후위 표기법 계산기  </li><li>미로찾기  </li></ol><h3 id="큐"><a href="#큐" class="headerlink" title="큐"></a>큐</h3><p>줄서기와 같다.<br>맨 처음에 데이터1이 들어오고 그 다음에 데이터2, 데이터3가 들어온다면<br>제일 먼저 온 데이터1이 먼저 나간다. : <code>First In First Out</code> = 선입선출  </p><h2 id="연결-리스트-linked-list"><a href="#연결-리스트-linked-list" class="headerlink" title="연결 리스트(linked list)"></a>연결 리스트(linked list)</h2><ol><li><code>싱글 링크드 리스트</code><br>노드가 데이터 + 링크<br>싱글 링크드 리스트의 노드는 데이터에 대한 링크가 하나이다.<br>링크가 하나만 있으면 양방향이 아니게 된다.<br>1 -&gt; 2 -&gt; 1 이 안 됨.  </li><li><code>더미 더블 링크드 리스트</code> -&gt; 이중 연결 리스트<br>노드가 링크 + 데이터 + 링크<br>링크가 두 개이기 때문에 양방향이다.<br>1 -&gt; 2 -&gt; 1 이 가능함. </li></ol><p><code>더미 노드</code>:  </p><ul><li>데이터가 없다  </li><li><p>구현 편의성이 높아지면서 에러 가능성이 낮다<br>  구현이 좋아진다 = 프로그래머의 실수를 줄일 수 있다<br><code>dummy</code>(head)~<code>1</code>~<code>2</code>~<code>3</code>~<code>dummy</code>(tail)</p></li><li><p>delete<br>reference count 가 0 이 되면<br>(어떤 값을 참조하는 것들이 모두 사라지면)<br>garbage collection 에 의해 사라진다.  </p></li></ul><p>delete 도 이와 비슷하게<br>지우려는 노드를 참조하는 다른 노드의 연결을 끊어버리면 된다.  </p><h2 id="배열과-링크드리스트의-차이"><a href="#배열과-링크드리스트의-차이" class="headerlink" title="배열과 링크드리스트의 차이"></a>배열과 링크드리스트의 차이</h2><p><strong>배열 :</strong><br>실제 메모리에도 데이터가 일렬로 들어간다.<br>인덱싱이 가능하므로 검색도 빠르다. O(1)<br>단, 데이터 삽입이나 삭제를 할 때 최악의 경우 O(n)<br>검색을 자주 할 때 배열을 쓴다.  </p><p><strong>연결리스트 :</strong><br>실제 메모리에서 데이터가 일렬로 들어가지 않고 흩어져있으며 서로 연결되어 있다.<br>인덱싱을 하려면 모든 데이터를 순회해야 하므로 검색이 느리다. O(n)<br>데이터 삽입을 할 때 싱글 링크드 리스트의 경우 O(1),<br>더블 링크드 리스트의 경우도 O(1).<br>삽입과 삭제를 자주 할 때 연결리스트를 쓴다.  </p><h1 id="앞으로-공부하라고-하신-내용"><a href="#앞으로-공부하라고-하신-내용" class="headerlink" title="앞으로 공부하라고 하신 내용"></a>앞으로 공부하라고 하신 내용</h1><p>linked list, stack, queue 는 선형 자료구조.<br>앞으로는 비선형 자료구조도 공부해야 할 것.  </p><ul><li>tree(이진트리)  <ul><li>순회(travorsal)  <ul><li>전위(preorder)  </li><li>중위(inorder)  </li><li>후위(postorder)<br>-&gt; 전위, 중위, 후위는 스택의 일종이고, 스택은 DFS의 일종.<br>  반복문과 재귀로 구현  </li><li>레벨 순서(level order)  </li></ul></li></ul></li><li>BST(Binary Search Tree)<br>  O(n^2)  </li><li><p>균형이진트리 (Balanced, self balancing)  </p><ul><li>AVL 트리  </li><li>RED-BLACK 트리  </li></ul></li><li><p>B-Tree (데이터베이스의 인덱스에 쓰임)<br>  : 균형이진트리 + 하드웨어 아키텍쳐  </p></li><li><p>Heap (완전이진트리, 배열로 구현한다)  </p></li><li><p>Hash Table(map)  </p><ul><li>hash function  </li><li>collision(충돌)  <ul><li>chaining(체이닝)  </li><li>open-addressing 기법  </li></ul></li></ul></li><li><p>Graph(그래프)  </p><ul><li>순회  <ul><li>DFS (깊이 우선 탐색) -&gt; 스택 기반  </li><li>BFS (너비 우선 탐색) -&gt; 큐 기반  </li></ul></li><li>MST(Minimum Spanning Tree) 최소 신장 트리  <ul><li>그리디 알고리즘 기반  </li><li>kruskal algorithm  </li><li>prim algorithm  </li></ul></li><li>최단 경로 문제(shortest path)  <ul><li>dijkstra algorithm -&gt; 그리디 알고리즘  </li><li>Balman-ford algorithm  </li><li>flord-warshall -&gt; 다이나믹 프로그래밍  </li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ADT-abstract-data-type-추상-자료형&quot;&gt;&lt;a href=&quot;#ADT-abstract-data-type-추상-자료형&quot; class=&quot;headerlink&quot; title=&quot;ADT(abstract data type), 추상 자료형&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/categories/til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>블로그 공사</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/diary/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/diary/</id>
    <published>2019-05-03T02:23:30.000Z</published>
    <updated>2019-05-03T02:25:22.616Z</updated>
    
    <content type="html"><![CDATA[<p>깃헙 블로그를 시작해보려고 했는데<br>공사만 며칠 걸린건지….<br>테마가 중국에서 만들어진거라서<br>눈에 보이는 알 수 없는 한자들을 찾아서 지우고<br>url 주소 연결때문에 골치 썩다보니<br>시간이 너무 많이 흘렀다.<br>그래도 다 해놓고 나니까 개운하군  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;깃헙 블로그를 시작해보려고 했는데&lt;br&gt;공사만 며칠 걸린건지….&lt;br&gt;테마가 중국에서 만들어진거라서&lt;br&gt;눈에 보이는 알 수 없는 한자들을 찾아서 지우고&lt;br&gt;url 주소 연결때문에 골치 썩다보니&lt;br&gt;시간이 너무 많이 흘렀다.&lt;br&gt;그래도 다 
      
    
    </summary>
    
      <category term="잡담" scheme="https://dearjsmc4.github.io/categories/%EC%9E%A1%EB%8B%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>예습과 질문정리(2)</title>
    <link href="https://dearjsmc4.github.io/2019/05/02/0502/"/>
    <id>https://dearjsmc4.github.io/2019/05/02/0502/</id>
    <published>2019-05-02T11:47:59.000Z</published>
    <updated>2019-05-03T02:45:43.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-제어문"><a href="#7-제어문" class="headerlink" title="7. 제어문"></a>7. 제어문</h2><p>코드는 원래 위에서부터 아래로 흐르며 순차적으로 진행되지만<br>제어문을 사용하게 되면 그 흐름을 깨고 실행순서를 인위적으로 변경할 수 있다.<br>그러나 코드의 흐름을 혼란스럽게 해 가독성을 해칠 수 있다.  </p><h3 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h3><p>주어진 조건식의 평가 결과(불리언 값)에 따라 코드 블록의 실행을 결정한다.  </p><ul><li>블록문<br>0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">질문1: 0개 이상이라는 것은 빈 블록도 가능하다는 뜻인가요. 빈 블록은 언제, 왜 쓰는 것인가요?</span><br></pre></td></tr></table></figure></li></ul><p>만약 조건식의 평가 결과가 불리언값이 아니면 불리언값으로 강제 변환된다. 조건식의 평가 결과가 true 일 경우 if문 다음의 코드 블록이 실행되고, false 일 경우 else문 다음의 코드 블록이 실행된다. else if문을 사용해 조건식을 여러 개 추가할 수도 있다. if문과 else문은 2번 이상 사용할 수 없고, else if문은 여러 번 사용할 수 있다. 코드 블록 내에 문이 하나 뿐일 때에는 중괄호를 생략할 수도 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">질문2:  </span><br><span class="line">같은 함수 안에 if문을 두 번 써도 에러는 안 나는데 그냥 통상적으로 if는 두 번 쓰지 않기로 약속한 것인가요?</span><br></pre></td></tr></table></figure></p><ul><li>삼항 조건 연산자로 바꿔쓰기<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">a === 1 ? &apos;맞다&apos; : &apos;아니다&apos;;</span><br></pre></td></tr></table></figure></li></ul><p>변수 a 에 값 1 을 할당하고<br>a 가 1 이면 ‘맞다’, 아니면 ‘아니다’ 를 반환한다.<br>삼항 조건 연산자 표현식은 값처럼 사용할 수 있으나 if…else 문은 값처럼 사용할 수 없다.  </p><ul><li>switch 문<br>switch 문은 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용된다.<br>if…else 문과 다른 점은, 코드 블록이 중괄호로 묶여 있지 않고 case문에 해당하는 문의 마지막에 break; 를 걸어주지 않으면 다음 case문으로 폴스루된다는 것이다.<br><strong>폴스루</strong>: break 문이 없다면 표현식과 일치하는 case 문에 해당하는 문을 실행한 후 switch 문을 탈출하지 않고 다음 case 문으로 넘어가서 표현식이 일치하지 않더라도 case 문을 실행하게 된다.  </li></ul><h3 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h3><p>주어진 조건식의 평가 결과가 true 인 경우에 코드 블록을 실행하고, 조건식이 거짓이 될 때까지 반복한다.  </p><ul><li><p>for 문<br>조건식이 거짓이 될 때까지 코드블록을 반복 실행한다. 아래의 형태가 일반적인 for 문이며 for 문을 중첩하여 쓸 수도 있다.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for([변수 선언문 또는 할당문]; [조건식]; [증감식])</span><br><span class="line">&#123;</span><br><span class="line">    실행할 코드</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>while 문<br>주어진 조건식의 평가 결과가 참이면 코드 블록을 반복 실행하고 조건식의 평가 결과가 거짓이 되면 실행을 종료한다.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while([조건식])&#123;</span><br><span class="line">    [실행할 코드]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>조건식이 언제나 참이고 탈출 조건이 명시되어 있지 않으면 while 문은 무한으로 반복하게 된다.<br>코드 블록 내에 if 문으로 탈출 조건을 만들고 break 를 걸어서 탈출할 수 있다.  </p><ul><li>do…while 문<br>while 문과 비슷하지만, 코드 블록을 최소 한 번은 무조건 실행한 후에 조건식을 확인한다.  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    [실행할 코드]</span><br><span class="line">&#125; while([조건식])</span><br></pre></td></tr></table></figure></li></ul><h3 id="break-문"><a href="#break-문" class="headerlink" title="break 문"></a>break 문</h3><p>레이블 문, 반복문, switch 문의 코드 블록을 탈출한다. </p><ul><li>레이블 문 : 식별자가 붙은 문  </li></ul><h3 id="continue-문"><a href="#continue-문" class="headerlink" title="continue 문"></a>continue 문</h3><p>반복문의 코드 블록 실행을 중단하고 증감식으로 이동한다.  </p><h2 id="8-타입-변환과-단축-평가"><a href="#8-타입-변환과-단축-평가" class="headerlink" title="8. 타입 변환과 단축 평가"></a>8. 타입 변환과 단축 평가</h2><p>개발자가 의도적으로 값의 타입을 변환하는 것을 <strong>명시적 타입 변환</strong>(Explicit coercion) 또는 타입 캐스팅(Type casting) 이라고 한다. 반면 개발자의 의도와 상관없이 자바스크립트 엔진이 암묵적으로 타입을 변환하는 것은 <strong>암묵적 타입 변환</strong>(Implicit coercion) 또는 타입 강제변환(Type coercion) 이라고 한다.<br><code>x.toString()</code> 이나 <code>x + &#39;&#39;</code> 등의 방법으로 타입 변환을 한다고 해도 원래 변수 x의 타입이 변하는 것은 아니다.  </p><ul><li><p>암묵적 타입 변환이 어떻게 실행될까  </p><ol><li><code>+</code> 연산자는 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작한다. 따라서 문자열 타입이 아닌 피연산자를 <strong>문자열 타입</strong>으로 변환한다.  </li><li>산술 연산자는 숫자 값을 만들어야 하므로, 숫자 타입이 아닌 피연산자를 모두 숫자 타입으로 변환한다. 비교 연산자나 단항 연산자도 마찬가지다. 만약 피연산자를 <strong>숫자 타입</strong>으로 바꿀 수 없을 때에는 NaN 의 결과가 나온다.  </li><li>if 문이나 for 문 같은 제어문이나 삼항 조건 연산자의 조건식은 참/거짓 을 반환해야 하므로 조건식의 평가 결과를 Truthy 값 또는 Falsy 값으로 구분하여 <strong>불리언 타입</strong>으로 암묵적 변환한다. </li></ol></li><li><p>명시적 타입 변환  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">질문3: 명시적 타입 변환 방법 중에 true * 1 가 있는데, 이 표현식의 평가 결과가 1로 나오는 것은 </span><br><span class="line">산술 연산자 * 가 있고 산술 연산자는 숫자 값을 만들어야 하기 때문에 숫자타입이 아닌 true 를 </span><br><span class="line">자바스크립트 엔진이 암묵적으로 숫자 타입으로 바꾸는 암묵적 타입 변환 아닌가요?  </span><br><span class="line">산술연산자를 이용해 타입 변환을 하는 것은 명시적 타입 변환인가요, 암묵적 타입 변환인가요?</span><br></pre></td></tr></table></figure></li><li><p>단축 평가<br>논리곱 연산자 <code>&amp;&amp;</code> 와 논리합 연산자 <code>||</code> 는 논리 평가를 결정한 피연산자를 그대로 반환한다.  </p></li></ul><ul><li><em>단축 평가를 사용한 매개변수의 기본값 설정에서 헷갈렸던 부분 정리</em>  </li></ul><p><code>undefined &amp;&amp; true</code><br>undefined 은 falsy 값이므로 false 로 간주되어 undefined 을 반환한다.<br><code>undefined || true</code><br>undefined 이 falsy 값이어도 두 번째 피연산자가 true 인지 확인해야 하므로 true 를 반환한다.  </p><p>따라서<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getStringLength(str) &#123;</span><br><span class="line">  str = str || &apos;&apos;;</span><br><span class="line">  return str.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>undefined || &#39;&#39;;</code><br>getStringLength() 함수는 인자를 전달받지 않았을 경우 매개변수에 undefined 가 할당되고,<br>undefined 는 falsy 값이므로 두 번째 피연산자까지 확인한 후 빈 문자열 ‘’ 을 반환한다.<br>함수는 undefined 의 length 가 아니라 빈 문자열의 length(0) 를 반환하게 된다.  </p><h2 id="9-객체-리터럴"><a href="#9-객체-리터럴" class="headerlink" title="9. 객체 리터럴"></a>9. 객체 리터럴</h2><p>자바스크립트의 객체는 키(key)와 값(value)으로 구성된 프로퍼티(property)들의 집합이다. 프로퍼티들은 쉼표로 구분한다. 객체 리터럴은 중괄호 내에 0개 이상의 프로퍼티를 정의한다.  </p><ul><li><p>프로퍼티의 키  </p><ul><li>빈 문자열을 포함하여 모든 문자열 또는 symbol 값을 사용할 수 있다.  </li><li>그러나 빈 문자열은 키로서의 의미를 갖지 못하므로 권장하지 않는다.  </li><li>문자열이나 symbol 값 외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다.  </li><li>식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키의 경우 반드시 따옴표를 사용해야 한다.  </li><li>var, function 과 같은 예약어를 프로퍼티 키로 사용해도 에러는 없지만 권장하지 않는다.  </li><li>프로퍼티 키를 중복선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.  </li><li>문자열이나 문자열로 변환 가능한 값을 반환하는 표현식으로 프로퍼티 키를 동적으로 생성할 수 있으며<br>  이를 계산된 프로퍼티 이름(Computed Property name) 이라고 한다.  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">질문4: 프로퍼티 키는 식별자 역할을 할 뿐 식별자는 아닌 건가요?  </span><br><span class="line">존재하지 않는 프로퍼티 키에 접근했을 때 undefined 가 나오는 이유는 무엇인가요?</span><br></pre></td></tr></table></figure></li></ul></li><li><p>프로퍼티의 값  </p><ul><li>자바스크립트에서 사용 가능한 모든 값을 사용할 수 있다.  </li><li>프로퍼티 값이 함수일 경우 메소드(method) 라고 부른다.  </li><li>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.  </li><li>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 값이 할당된다.  </li></ul></li><li><p>프로퍼티에 접근하는 방법  </p><ol><li>마침표 표기법 : <code>person.name</code>  </li><li>대괄호 표기법  <code>person[&#39;name&#39;]</code> -&gt; 따옴표로 감싸주지 않으면 식별자로 인식해 에러가 난다.  </li></ol></li><li><p>프로퍼티 삭제<br>  delete 연산자를 사용하며 존재하지 않는 프로퍼티를 삭제하려 할 경우 무시되고 에러가 나지 않는다.  </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;7-제어문&quot;&gt;&lt;a href=&quot;#7-제어문&quot; class=&quot;headerlink&quot; title=&quot;7. 제어문&quot;&gt;&lt;/a&gt;7. 제어문&lt;/h2&gt;&lt;p&gt;코드는 원래 위에서부터 아래로 흐르며 순차적으로 진행되지만&lt;br&gt;제어문을 사용하게 되면 그 흐름을 깨
      
    
    </summary>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/categories/javascript/"/>
    
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Browser Rendering</title>
    <link href="https://dearjsmc4.github.io/2019/05/02/0501/"/>
    <id>https://dearjsmc4.github.io/2019/05/02/0501/</id>
    <published>2019-05-01T15:00:00.000Z</published>
    <updated>2019-05-03T01:21:42.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>브라우저와 서버는 대부분 다른 컴퓨터에 있다.<br>브라우저는 사용자 컴퓨터(어느나라의 어디의 누가 어떤 브라우저로 접속할지는 모른다)에 있고,<br>서버는 모든 상황에, 최대한 많은 브라우저를 대응하려 노력한다. 심지어 익스 7,8까지도…<br>(한국에서는 익스 9이상은 지원해줘야한다)  </p><p>브라우저와 서버는 통신을 해야 하는데, 이를 위해 서버사이드 프로그램과 브라우저가 약속을 한다.<br>“http:// 는 <strong>http</strong> 라는 통신규약(서버와 브라우저간의 약속)을 사용해 정보를 교환하겠다는 뜻이다.”<br>브라우저가 서버에게 이니셜 요청을 했을때 주소창의 주소가 <code>https://www.naver.com</code> 이라면,<br>“나는 통신을 <code>https</code> 로 할거고, <code>www.naver.com</code> 이라는 서버로 페이지를 요청할거야.” 라는 뜻.<br>도메인네임서버에서 도메인을 IP주소로 변환한 뒤, IP주소로 서버의 위치를 알고 연결해준다.<br>만약 페이지를 요청하는 구문이 아무것도 없으면 서버는 메인페이지(index.html)을 보내는 것으로 기본 설정이 되어 있기에,<br>브라우저는 네이버의 메인 페이지를 받게 된다.  </p><pre><code>파일은 어떻게 받지? -&gt; 케이블을 타고 패킷으로!  컴퓨터가 갖고 있는 파일은 0과 1로 이루어진 이진수의 집합체.  패킷은 데이터를 일정한 크기로 자른 것이다.  그 패킷들이 순서대로 시냇물 흐르듯 전송된다고 해서 스트림(stream) 이라고 한다.  </code></pre><h2 id="HTML-CSS-파싱"><a href="#HTML-CSS-파싱" class="headerlink" title="HTML/CSS 파싱"></a>HTML/CSS 파싱</h2><p>클라이언트 사이드에서는 index.html 파일(순수한 텍스트파일)을 받아서 메모리에 올린 후 파싱(해석)한다.<br><strong>파싱</strong>은 사람이 보기 좋으라고 써둔 소스코드를 브라우저가 이해하고 실행할 수 있도록 해석하는 것이다.<br>파일을 로드한(다운로드 받은) 상태에서 코드를 한 줄씩 읽다가<br>의미가 있는 내용이면 메모리에 기억하는데, 그 유의미한 정보를 <strong>토큰</strong>이라고 한다.  </p><pre><code>HTML은 부자관계로 이루어진다. nesting, 중첩.  네스팅된 자식태그는 자식노드가 된다.  </code></pre><p>만약 link태그를 만나 CSS를 로딩해야 할 때가 되면, HTML의 파싱을 중단하고 다시 http를 이용해 서버에게 요청한다.<br>“나 style.css 라는 것 좀 줘.”(모든 파일은 서버에 있으니까)<br>서버는 해당 파일을 가지고 있는 곳에 가서 파일을 찾아서 패킷으로 잘라서 보낸다.<br>클라이언트는 파일을 받아서 메모리에 올리고 <strong>CSS 파싱</strong>을 시작한다.<br>CSS에는 선택자(selector)가 있고, 선택자와 선언블럭으로 이루어진 것을 룰셋이라고 부른다.  </p><pre><code>body{    font-size : 16px;}</code></pre><p>이 룰셋들을 파서가 읽고 메모리에 써둔다. “body는 font-size가 16픽셀이더라” 라고.  </p><p>CSS 파싱을 다 마치면 <strong>CSSOM 트리</strong>가 완성되고, HTML 파싱을 중단한 시점부터 다시 시작한다.<br>HTML 파싱을 다 마치면 <strong>DOM 트리</strong>가 완성된다.  </p><p>DOM 트리(HTML의 파싱결과)와 CSSOM 트리(CSS의 파싱결과)가<br>브라우저가 관리하고있는 메모리에 자료구조로 만들어지면<br>DOM 트리와 CSSOM 트리를 합쳐서(merge) 렌더트리(렌더링 하기위한 트리)를 만든다.<br>이 렌더트리를 가지고 드디어 화면에 그리기 시작한다.  </p><p>이 모든 일은 브라우저안에있는 <strong>렌더링 엔진</strong>이라는 프로그램이 한다.  </p><h2 id="자바스크립트-파싱"><a href="#자바스크립트-파싱" class="headerlink" title="자바스크립트 파싱"></a>자바스크립트 파싱</h2><p>자바스크립트의 처리는 <strong>자바스크립트엔진</strong>이라는 프로그램이 한다.<br>HTML 파싱을 하다가 스크립트 태그를 만나면 HTML파싱이 멈춘다.<br>이것을 <strong>블로킹</strong>이 걸렸다고 한다.<br>스크립트 태그가 src 속성을 안 가지고 있다면 스크립트가 내장되어 있는 것이고,<br>src 속성을 가지고 있다면 서버에서 파일을 가져온다.  </p><p>자바스크립트 엔진은 소스코드를 분석하며 의미를 갖는 최소 단위인 토큰들로 분리한다.  </p><p><code>var a = 0;</code> 일 때<br><code>var</code>, <code>a</code>, <code>=</code>, <code>0</code>, <code>;</code> 이 모두 토큰이다.</p><p>그리고 토큰들의 집합을 파싱하면서 <strong>신택스 트리</strong>, AST(Abstract Syntax Tree)를 만든다.  </p><p>(자바스크립트엔진이 자바스크립트문법으로 이해했다는 뜻.<br>이해할 수 있다면 실행할 수 있다는 뜻이고, 명령을 할 수 있다는 뜻이다.)  </p><p>파싱한 상태에서 바이트코드로 한 번 더 바꾼 후 실행을 하는데,<br>이때 돔과 관련이 있다면 <strong>돔을 조작</strong>할 수 있게 된다.<br>만약 스크립트가 헤드에 있다면 돔트리가 완성이 안된 상태라서 돔 조작이 불가능하다.<br>자바스크립트는 돔트리와 씨솜트리가 완성된 상태에서 실행해야 의미가 있다.  </p><pre><code>- 그럼에도 스크립트태그를 헤드에 써야 한다면...  async: 병렬처리. 비동기. HTML파싱이 안 끝나도 js파싱이 끝나면 바로 실행한다.  defer: 파싱은 빨리하고 실행은 HTML 파싱이 끝나고 나중에 한다.  (그러나 둘 다 IE9이하에서는 지원이 안 되거나 부분지원 된다고 하니 그냥 body태그 아래에 쓰도록 하자)  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h2&gt;&lt;p&gt;브라우저와 서버는 대부분 다른 컴퓨터에 있다.&lt;br&gt;브라우저는 사용자 컴퓨터(어느나라의 어디의 누가 어떤 브라우
      
    
    </summary>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/categories/javascript/"/>
    
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
      <category term="Web" scheme="https://dearjsmc4.github.io/tags/web/"/>
    
      <category term="HTML" scheme="https://dearjsmc4.github.io/tags/html/"/>
    
      <category term="CSS" scheme="https://dearjsmc4.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Basic</title>
    <link href="https://dearjsmc4.github.io/2019/05/02/js-basic/"/>
    <id>https://dearjsmc4.github.io/2019/05/02/js-basic/</id>
    <published>2019-05-01T15:00:00.000Z</published>
    <updated>2019-05-03T01:32:03.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><p><strong>프로그래밍 입력, 저장, 처리, 출력에 관한 문법을 배워야 한다.</strong>  </p><ul><li>입력: ex) prompt.<br>보통 웹상에서의 입력은 form 으로 받는다.  </li><li>저장: 변수를 이용한 저장. 쿠키 or 웹 스토리지  </li><li>처리: 연산. 분기. 반복.  </li><li>출력: 화면에 DOM을 추가.  </li></ul><h2 id="변수란"><a href="#변수란" class="headerlink" title="변수란?"></a>변수란?</h2><p>컴퓨터 프로그래밍에서 어떤 값을 담는 그릇. 이 그릇에도 종류라는 것이 있는데,  </p><ul><li>일반/원시타입: <strong>숫자, 문자, 불대수</strong>  </li><li>여러종류를 담는 그릇: <strong>배열. (리스트. 딕트. 튜플. 셋)</strong><br>변수는 만들고, 값을 읽고, 값을 바꾸고, 값을 사용(연산의 피연산자, 함수의 매개변수)하게 된다.  </li></ul><p><code>a = “hi”</code> -&gt; a라는 이름을 가진 저장공간을 만들고, 그 안에 “hi”라는 값을 저장(할당)한다는 뜻.<br><code>alert(a);</code> -&gt; 알림창에 hi<br>a : a라는 저장공간의 이름(이름으로 부를때) / a라는 이름을 가진 저장공간(사용할 때)<br>= : 할당연산자. 저장하는 연산자. hi 를 a에 저장하라는 의미.<br>보통 = 은 같다는 의미인데. 프로그래밍에서는 저장한다는 의미가 되고, 같다는 == 로 표현.  </p><p>변수명을 사용하게 되면 해당 내용의 용도가 명확해진다.<br>그러므로 무엇이 담겼는지 명확히 알려줘야한다.  </p><p>숫자, 불리언값 등은 값을 그대로 쓰지만,<br>문자열은 홑따옴표/쌍따옴표로 감싸서 표기한다. 왜? -&gt; 그냥 쓰면 변수 혹은 예약어등과 헷갈릴 수 있기 때문이다.<br><code>Name = jake;</code> -&gt; jake 가 다른 변수인가?</p><p><strong>이스케이프 문자</strong><br>쌍따옴표안에 쌍따옴표를 쓰고 싶을 때 백슬래시를 넣으면 되는데 이를 이스케이프문자라고 한다.<br>어떤 특별한 목적과 기능이 있는 문자라는 것. ex) <code>\n</code> 은 줄바꿈. New line 이라는 것.  </p><h3 id="변수명을-만들-때-주의할-것"><a href="#변수명을-만들-때-주의할-것" class="headerlink" title="변수명을 만들 때 주의할 것"></a>변수명을 만들 때 주의할 것</h3><ol><li>숫자는 변수이름 맨 앞에 사용하지 않을 것.  </li><li>특수문자는 언더바만 사용할 것.  </li><li>대소문자를 구분할 것.  </li><li>명사, 동사로만 작성할 것.  </li><li>예약어는 사용 금지.  </li></ol><h3 id="변수명을-작성하는-방법"><a href="#변수명을-작성하는-방법" class="headerlink" title="변수명을 작성하는 방법"></a>변수명을 작성하는 방법</h3><ol><li>카멜 케이스 : yourName  </li><li>파스칼 케이스 : YourName  </li><li>스네이크 케이스 : your_name  </li><li>+헝가리안 표기법 : strName/ intNumber (변수명 앞에 어떤 데이터타입인지 적어주는 방법)  </li></ol><p>demo 라는 아이디를 찾지 못한다고 오류가 떴던 이유 :<br>자바스크립트는 dom객체를 제어해서 글씨를 띄우려고 했는데,<br>위에서부터 읽다보니 demo 를 찾기도 전에 자바스크립트를 만나버린 것. 순차문제인것이다.<br>그래서 스크립트블록을 바디 맨 아래로 바꾸면 해결된다.  </p><h2 id="프로그래밍-진행방식-세-가지"><a href="#프로그래밍-진행방식-세-가지" class="headerlink" title="프로그래밍 진행방식 세 가지"></a>프로그래밍 진행방식 세 가지</h2><ul><li>순차: 위에서부터 아래로 한줄씩 실행해나가는 것.  </li><li>분기: a를 실행할지 b를 실행할지 선택하는 것. (조건에 따라서)  </li><li>반복: 컴퓨터는 반복적으로 빠르게 일을 잘한다. a,b중에 실행할 코드를 여러 번 반복하는 것.  </li></ul><p>document는 페이지문서 자체를 말한다.<br>document 에서 요소를 아이디로 찾을 때 -&gt; <code>document.getElementById</code></p><p>Prompt 로 받은 값은 모두 문자열이 된다. 그래서 1+2 = 12    </p><ul><li>산술연산자: +, -, *, /, %(나머지 구하기.), **(거듭제곱)  </li><li>문자연산자: + (문자를 이어붙임)  </li></ul><p>문자로 받았지만 산술연산을 해야 할 때 -&gt; type casting 형변환이 필요하다.<br><code>number(“값”)</code> -&gt; 값이 숫자가 된다. (꼭 대문자로 시작하게 써줘야함!)  </p><h2 id="자바스크립트의-5가지-데이터-타입"><a href="#자바스크립트의-5가지-데이터-타입" class="headerlink" title="자바스크립트의 5가지 데이터 타입"></a>자바스크립트의 5가지 데이터 타입</h2><ul><li>number  </li><li>string  </li><li>boolean<br>(숫자, 문자, 불린은 형변환 가능)  </li><li>null(아무값도없음)  </li><li>undefines(정의되지않음)  </li></ul><h2 id="if-조건문"><a href="#if-조건문" class="headerlink" title="if 조건문"></a>if 조건문</h2><p>if문에서는 if 가 필수고, else if 나 else 는 필수가 아니다.  </p><p>if : 만약 조건식이 참이라면, 해당 부분의 실행구문을 실행하겠다.(하나의 if문에는 하나의 if만 들어갈수있다.)<br>else if : 그게 아니라 다음 조건식이 참이라면, 해당 부분의 실행구문을 실행하겠다.(0번부터 여러 번)<br>else : 이도저도 아니면, 해당 부분의 실행구문을 실행하겠다. (여긴 조건식이 없다. 이도저도 아닐때니까.)<br>실행구문은, 우리가 쓰고싶은 어떤 코드든 가능하다.  </p><p><strong>조건식은 명제</strong><br>참과 거짓을 판별할 수 있는 문장. 결과값이 참과 거짓으로만 나오는 문장.<br>True/false,  1/0 로 표기. -&gt; boolean 값. Bool.<br>비교구문이 제일 많다. &gt;, &lt;, &gt;=, &lt;=, ==, != …  </p><p>===, !== 는 종류까지 같은지 판별한다.  </p><ul><li>1 == true<br>true. 1은 곧 true 이다.  </li><li>1 === true<br>false. 데이터타입이 다르다. 1은 숫자이고 true 는 불린 값이다.</li></ul><h2 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h2><ul><li><p>몇 번을 반복할 것인가<br>for([초기화] ; [조건문] ; [증감식]){<br>  [실행할 코드]<br>}  </p></li><li><p>조건에 맞는 동안 반복<br>  While ([조건식]) { [실행할 코드] }<br>  While(true) = 무한반복  </p><ul><li>break : 만나는 순간 가장 가까운 반복문을 탈출한다.  </li><li>continue : 만나는 순간 반복문이 다음 회차로 이동하여 넘어간다.  </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Javascript&quot;&gt;&lt;a href=&quot;#Javascript&quot; class=&quot;headerlink&quot; title=&quot;Javascript&quot;&gt;&lt;/a&gt;Javascript&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;프로그래밍 입력, 저장, 처리, 출력에 관한 문법을 배
      
    
    </summary>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/categories/javascript/"/>
    
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>예습과 질문정리(1)</title>
    <link href="https://dearjsmc4.github.io/2019/05/02/0430/"/>
    <id>https://dearjsmc4.github.io/2019/05/02/0430/</id>
    <published>2019-05-01T15:00:00.000Z</published>
    <updated>2019-05-03T01:31:58.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-자바스크립트-개발-환경과-실행-방법"><a href="#3-자바스크립트-개발-환경과-실행-방법" class="headerlink" title="3. 자바스크립트 개발 환경과 실행 방법"></a>3. 자바스크립트 개발 환경과 실행 방법</h2><p>자바스크립트는 브라우저와 Node.js 환경에서 실행할 수 있지만 브라우저와 Node.js는 존재 목적이 다르기에 ECMAScript 외의 추가적 기능은 서로 호환되지 않고 각각의 환경에 맞게 제공되는 API가 따로 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">질문1: 런타임은 코드가 실행되는 시점이고 런타임 환경은 코드가 돌아가는 환경이라고 이해하면 되는지?</span><br><span class="line">-&gt; 그렇게 이해하면 된다.</span><br></pre></td></tr></table></figure></p><p>웹 브라우저에서 자바스크립트를 body의 아래쪽에 두어 DOM이 완성된 후에 조작할 수 있도록 하면 에러를 방지하고 렌더링에 지장을 주지 않을 수 있다.  브라우저의 개발자도구에서는 웹 개발에 필요한 여러 기능을 사용할 수 있다. 특히 콘솔에서는 에러를 확인하거나 간편하게 값을 확인할 수 있고, 에러 확인 후 Source 패널에서 바로 디버깅을 할 수 있어 유용하다.<br>서버 개발 환경을 제공하는 Node.js 에서는 서버 사이드 개발에 필요한 API를 제공한다.<br><strong>Single Page Application</strong>: 서버로부터 새로운 페이지를 불러오는 게 아니라 현재의 페이지를 동적으로 다시 작성하는 웹 애플리케이션이나 웹 사이트. 어떤 사이트에서 메뉴를 클릭했을 때 새로운 페이지를 불러오는 게 아니라 현재 페이지에서 내용만 바뀌도록 하는 것. HTML 페이지가 아니라 데이터만 오간다. 그래서 I/O가 빈번하게 일어남. 페이지가 하나뿐인 사이트. 싱글페이지.</p><h2 id="4-변수"><a href="#4-변수" class="headerlink" title="4. 변수"></a>4. 변수</h2><p>어떤 값을 메모리에 저장하고 재사용하기 위해 쓰는 것이 변수.<br>var num = 10; 의 형태로 선언한다.<br>변수에 값을 저장하는 것을 <strong>할당</strong>이라 하고 불러올 때는 <strong>참조</strong>한다고 한다.<br>이때 var는 <strong>키워드</strong>, num은 <strong>변수명(식별자)</strong>, = 는 <strong>할당연산자</strong>, 10은 <strong>변수값</strong>이다.<br>식별자는 단지 변수명만 뜻하는 것이 아니라 함수명이나 클래스 등 값을 구별하여 식별할 수 있는 모든 고유한 이름을 의미한다.<br>자바스크립트 엔진이 키워드를 만나면 약속되어진 동작을 실행한다. 키워드는 일종의 명령어이다.<br>var 키워드를 만나면 자바스크립트 엔진은 변수를 선언한다.<br>변수 선언에는 두 단계가 있다.  </p><ol><li>선언 단계:<br>자바스크립트 엔진에 새로운 변수의 존재를 알려 값을 저장할 메모리 공간을 확보한다. 메모리 주소에 변수명을 매핑한다.  </li><li>초기화 단계:<br>선언 한 후 아무런 값도 할당하지 않으면 자바스크립트 엔진은 메모리공간에 undefined 라는 값을 암묵적으로 할당한다.<br>초기화단계를 거치지 않으면 이전에 다른 애플리케이션이 사용했던 쓰레기값이 남아 참조될 수 있다.  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">질문2: 변수를 참조하는 것이 아무것도 없으면 자동으로 해제되는데 쓰레기값이 어떻게 남아있을 수 있는지?  </span><br><span class="line">-&gt; 메모리는 브라우저만 쓰는 것이 아니라 다른 애플리케이션들과 함께 쓰는 것이다.  </span><br><span class="line">내가 변수를 직접 할당한 적이 한 번도 없지만 다른 애플리케이션이 썼을 수도 있고,  </span><br><span class="line">그래서 쓰레기값이 남아있을 수도 있다.</span><br></pre></td></tr></table></figure></li></ol><p>변수를 사용하려면 꼭 선언을 해야 한다.<br>내가 선언하지않은 변수를 불러오려하면 자바스크립트 엔진은 당연히 선언한 적 없는 변수명과 변수값을 찾아야하고 결국 못찾으므로 참조에러가 난다.<br><strong>호이스팅</strong>:<br>Hoist = 들어올리다. 변수선언문이 마치 변수를 참조하는 코드 위쪽으로 끌어올려진 것처럼 동작하는 것.<br>자바스크립트 엔진은 코드를 한 줄 한줄 읽어내려가기 전에 먼저 소스코드 전체를 평가하고 선언문을 찾아내서 식별자를 등록한다.<br>그래서 변수선언문이 변수를 참조할 코드보다 늦게 쓰였음에도 참조에러가 나지 않는다.<br>코드가 한줄씩 실행될때에는 이미 식별자가 등록이 된 상태이기때문이다. 단, 선언은 파싱타임때 되지만 값의 <strong>할당</strong>은 런타임에 실행된다.  </p><p>값을 재할당할때에는 메모리공간에 할당되어있던 원래 값을 지우는 것이 아니라 새로운 메모리 공간에 할당된다.<br>그리고 이전에 할당된 메모리공간은 가비지컬렉터에 의해 자동으로 해제된다.</p><h2 id="5-데이터타입"><a href="#5-데이터타입" class="headerlink" title="5. 데이터타입"></a>5. 데이터타입</h2><p>값은 데이터타입을 가진다. 데이터타입은 값을 저장할 때 확보해야하는 메모리공간의 크기를 결정한다.<br>그리고 값을 불러올 때 그 데이터타입에 할당되는 메모리공간만큼 한번에 읽어야 손실이 없다.<br>또한 그 읽어들인 2진수를 어떻게 해석할지 역시 데이터타입을 참고하여 결정한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">질문3: 데이터타입마다 할당되는 메모리 공간이 다르기 때문에 그 공간의 크기를 참고해서 어떻게 해석할지 결정하는 것인가?</span><br></pre></td></tr></table></figure></p><p>값: 더 이상 평가할 수 없다. 30을 평가하면 30이다.<br>값을 생성하는 다양한 방법. 표현식.  </p><ol><li>리터럴 표기법: 리터럴을 생성.<br>리터럴은 직접 고정된 값 자체.  </li><li>표현식: 하나의 값으로 평가되는 문. 10+20을 평가하면 30이다.  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">질문4: 리터럴은 내가 직접 지정한 값이고 리터럴과 연산자의 조합인 표현식으로 만들어진 값은 리터럴이 아닌가?  </span><br><span class="line">왜 리터럴과 다른 값을 구분하는지?</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">질문5: 자바스크립트는 숫자타입을 왜 다 실수로 처리하나(컴공시간에 배운것같은데 잘 이해하지 못했음)  </span><br><span class="line">-&gt; 자바스크립트는 다른 언어들과 달리 short, int, float 과 같은 다양한 숫자타입이 없으니까 </span><br><span class="line">International IEEE 754 standard에 따라 double로 처리하는 것이라고 한다.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">질문6: 널값은 변수에 값이 없다는 것을 의도적으로 명시한것임에도 가비지컬렉터가 메모리를 해제하나?  </span><br><span class="line">어차피 가비지컬렉터에 의해 해제될 빈 메모리공간이라면 널값을 의도적으로 명시하는 상황은 어떤 경우인지?  </span><br><span class="line">그럼 널값 할당은 메모리공간을 비우라는 명령이 될 수도 있는건가?  </span><br><span class="line">-&gt; 자바스크립트의 널값이 다른 언어와 달라서 생긴 의문인 듯 하다. 변수에 null 을 할당하는 것은 사실  </span><br><span class="line">메모리공간에 null 이 들어가는 것이 아니라 변수의 참조를 끊는 것과 같다. 참조가 끊어지니  </span><br><span class="line">메모리공간에 있던 값은 자연스럽게 가비지컬렉터에 의해 사라지고, 식별자만 남는다.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">질문7: null의 데이터타입이 null 이 아니라 object 가 나오는 이유?  </span><br><span class="line">-&gt; 설계의 문제인듯.. null타입 확인 시에는 일치연산자 사용할것.. 그럼 애초에 왜 그렇게 설계된건지  </span><br><span class="line">-&gt; 이것은 토끼굴에 빠질 가능성이 높은 듯 하다</span><br></pre></td></tr></table></figure><p>동적타입언어: 변수에 할당되는 값에 따라 데이터타입이 동적으로 바뀐다.<br>정적타입언어: 선언된 변수의 데이터타입에 맞는 값만을 할당할 수 있다.  </p><h2 id="6-연산자"><a href="#6-연산자" class="headerlink" title="6. 연산자"></a>6. 연산자</h2><p>문과 표현식.<br>문(statement): 하나 이상의 표현식과 키워드의 조합으로 자바스크립트 엔진에게 내리는 명령.<br>문이 실행되면 무슨 일이 일어나게 되어있다. 이 명령의 집합으로 이루어진 것이 프로그램. 문의 끝에는 세미콜론을 붙인다.<br>표현식은 평가되어 값을 만들고, 문은 표현식으로 생성한 값을 사용해 명령을 내린다.<br>표현식인 문은 값으로 평가할 수 있고, 표현식이 아닌 문은 값으로 평가할 수 없다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">질문8: 문이 표현식이 될 수 없다는 건 무슨 뜻인지  </span><br><span class="line">-&gt; 표현식은 값을 만들어내는 것에 비해 조건문, 반복문 같은 문들은 값을 만드는 것이 아니라 어떤 일을 하기 때문이다.  </span><br><span class="line">물론 표현식도 평가라는 일을 하고, 조건문도 비교연산을 통해 불리언 값을 만들긴 하지만,  </span><br><span class="line">그건 표현식과 문이 중점적으로 하는 일은 아니다.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">질문9: 표현식이 문이 될 수 있다는 건 표현식이 어떤 값으로 평가되는 &apos;일&apos;이 일어나기 때문인가?</span><br></pre></td></tr></table></figure><p>이항산술연산자: 두 개의 피연산자를 산술연산하여 새로운 값을 만든다. 피연산자의 값이 바뀌지 않는다.<br>단항산술연산자: 한 개의 피연산자를 산술연산하여 숫자타입값을 만든다. 피연산자의 값이 바뀐다.  </p><p>증가/감소 연산자(++/–)는 위치에 따라 의미가 다르다.<br>피연산자 앞에 위치하면 먼저 피연산자의 값을 증가/감소 시킨 후 다른 연산을 수행하고,<br>피연산자 뒤에 위치하면 다른 연산을 수행한 후에 피연산자 값을 증가/감소 시킨다.  </p><p><code>+</code> 단항 연산자는 숫자타입이 아닌 피연산자에 사용 시 피연산자를 숫자타입으로 변환시킨 값을 반환한다.<br><code>-</code> 단항 연산자는 <code>+</code> 단항 연산자와 같은 기능을 하고, 피연산자의 부호를 반전한 값을 반환한다.<br>삼항조건연산자: 조건식의 평가결과에 따라(조건식이 true일 때 &amp; false일 때) 반환할 값을 결정.  </p><p>논리합 연산자(||) : 둘 중 하나만 true 이더라도 true 반환<br>논리곱 연산자(&amp;&amp;) : 둘 다 true 여야 true 반환<br>논리부정 연산자(!) : 부정을 긍정으로, 긍정을 부정으로 바꾼다.  </p><ul><li>!true = false  </li><li>!false = true  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-자바스크립트-개발-환경과-실행-방법&quot;&gt;&lt;a href=&quot;#3-자바스크립트-개발-환경과-실행-방법&quot; class=&quot;headerlink&quot; title=&quot;3. 자바스크립트 개발 환경과 실행 방법&quot;&gt;&lt;/a&gt;3. 자바스크립트 개발 환경과 실행 방법
      
    
    </summary>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/categories/javascript/"/>
    
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript &amp; Javascript</title>
    <link href="https://dearjsmc4.github.io/2019/05/02/0429/"/>
    <id>https://dearjsmc4.github.io/2019/05/02/0429/</id>
    <published>2019-05-01T15:00:00.000Z</published>
    <updated>2019-05-03T02:45:04.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="자바스크립트와-ECMA스크립트"><a href="#자바스크립트와-ECMA스크립트" class="headerlink" title="자바스크립트와 ECMA스크립트"></a>자바스크립트와 ECMA스크립트</h2><p>참고: <a href="https://medium.freecodecamp.org/whats-the-difference-between-javascript-and-ECMAscript-cba48c73a2b5" target="_blank" rel="noopener">What’s the difference between JavaScript and ECMAScript?</a></p><p><strong>ECMA International</strong>:<br>표준을 만드는 단체.<br>대부분의 키보드들이 같은 순서의 자음모음 순서를 가지고 있고 같은 위치의 스페이스 엔터 등등이 있다.<br>그건 바로 대부분의 키보드 회사들이 쿼티레이아웃이라는 표준을 가지고 키보드를 만들기 때문이다.<br>그런 표준을 만들어내는 곳이다.  </p><p><strong>ECMA-262</strong>:<br>ECMA international 에서 발표하는 표준.<br>스크립트 언어에서 통용되는 구체적 사양, 설명을 포함하고 있다.<br>ECMAScript의 명세번호라고 이해하자.  </p><p><strong>Scripting Language</strong>:<br>요소나 시스템 위에서의 <strong>동작</strong>을 위해 만들어진 프로그래밍 언어.<br>걷다, 달리다, 점프하다 와 같은 명령들을 생각해보자.<br>이런 동작들은 사람이나 개나 게임캐릭터들처럼 그것을 수행해줄 무언가가 필요하다.<br>이 명령을 수행할 대상이 없이는 걷고 뛰고 점프하는 행동 자체가 불가능하다.<br>이러한 행동들이 스크립트언어가 겉으로 보이는 요소들을 조작하고 제어하는것과 비슷하다.<br>(그러니까 내가 요소이고 나를 걷고 뛰고 점프하도록 조작하고 제어하는 역할을 하는 것이 스크립트언어 라고 보면 될 듯?<br>그래서 웹상에서 동작을 제어하는 자바스크립트가 스크립트언어라고 불리는 것이겠지.)  </p><p><strong>ECMAScript</strong>:<br>ECMA-262 기술규격에 정의된, 표준화된 스크립트 프로그래밍 언어.<br>스크립트 언어가 ECMAscript를 준수한다고 여겨지려면 반드시 지켜야하는 규칙과 세부사항, 가이드라인을 제공함.<br>스크립트언어의 기본 뼈대(코어)를 이룬다. 모든 스크립트 언어들이 기본적으로 갖춰야 하는 내용이니까.  </p><p><strong>Javascript</strong>:<br>ECMAscript 표준을 준수하는 스크립트 언어. ECMAscript 와 브라우저가 별도로 지원하는 WEB API 를 포함하는 개념.  </p><p><strong>Javascript Engine</strong>:<br>자바스크립트 코드를 이해하고 실행시킬 수 있는 통역기.<br>크롬의 v8, 파이어폭스의 스파이더몽키 등 웹 브라우저에서 사용된다.<br>브라우저의 자바스크립트 엔진은 사람이 언어를 이해하는 능력과 비슷하다.<br>자바스크립트 엔진은 걷다, 뛰다, 점프하다 와 같은 행동들이 어떤 뜻인지 <strong>이해</strong>한다.<br>사람이 걸으랄 때 걷고 점프하랄때 점프하고 뛰랄 때 뛸 수 있는 것도<br>그 행동들이 어떤 의미인지 알아듣기때문에 가능한 것.<br>그러니까 사람에게도 이런 자바스크립트 엔진이 들어있어서 그것들을 이해할 수 있다고 생각하면 될 듯.<br>해석해줄 엔진이 없다면 스크립트언어가 아무리 명령해도 알아들을 수 없겠지.<br>브라우저마다 엔진의 차이는 있다. 왜냐면 ECMAScript가 업데이트될 때 모든 브라우저들이 한꺼번에<br>업데이트 하는 것이 아니기 때문이며 각 브라우저의 엔진마다 어떻게 해석하고 구현할 것인지가 다르기 때문이다.  </p><h2 id="WEB-API"><a href="#WEB-API" class="headerlink" title="WEB API?"></a>WEB API?</h2><p>그 전에 API가 무엇인지부터 생각해보자.<br><strong>API</strong>는 어플리케이션 프로그래밍 인터페이스.<br>모든 언어는 API를 지원하고, 그 API를 사용해서 코딩을 하는 것이다.<br>우리가 애플리케이션을 구현하기 위해 시간의 순서대로 배치해야할 부품들.<br>우리가 쓰는 함수들. 우리가 만들지는 않았지만 간편히 사용 가능한, 그 언어가 가지고 있는 조작장치.  </p><p><strong>WEB API</strong>는 웹에서 여러 유용한 작업을 할 수 있도록 제공되는 API.<br>예를 들어 웹 오디오 API는 브라우저의 오디오를 조작하기 위한 메서드를 제공.<br>근데 그 뒷편에서 브라우저는 사실 더 복잡한 로우레벨코드를 실행 중.<br>내가 직접 그런 복잡한 일을 하지 않아도 되게 해주는 것이 브라우저 API.<br><code>setTimeout()</code>, <code>alert()</code> 같은 것들이 그 예시.<br>W3C에서 표준을 관리.<br>( 내가 직접 하려면 정말 복잡한 코드를 이해하고 쓸 줄 알아야 하지만<br>WEB API가 있음으로써 브라우저에서 내가 쉽게 할 수 있는 일들이 더 많아지는 것이라고 이해하면 되겠다. )  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;자바스크립트와-ECMA스크립트&quot;&gt;&lt;a href=&quot;#자바스크립트와-ECMA스크립트&quot; class=&quot;headerlink&quot; title=&quot;자바스크립트와 ECMA스크립트&quot;&gt;&lt;/a&gt;자바스크립트와 ECMA스크립트&lt;/h2&gt;&lt;p&gt;참고: &lt;a href=&quot;h
      
    
    </summary>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/categories/javascript/"/>
    
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Installing Hexo</title>
    <link href="https://dearjsmc4.github.io/2019/03/17/Installing-Hexo/"/>
    <id>https://dearjsmc4.github.io/2019/03/17/Installing-Hexo/</id>
    <published>2019-03-17T03:27:59.000Z</published>
    <updated>2019-05-02T04:35:44.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="헥소-설치"><a href="#헥소-설치" class="headerlink" title="헥소 설치"></a>헥소 설치</h2><p><a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a><br>헥소 사이트로 이동하여 시키는 대로 하다보면 되던데<br>기억을 더듬어서 순서를 적어보자…</p><p><img src="/img/git.png" alt="screenshot"></p><p>갑자기 망할 놈(…) 소리를 들었는데<br>다른 게 아니라 Git 이다. <del>번역기가 잘못했네</del><br>헥소 설치 전에 Node.js와 Git 을 설치해야 한다.</p><p>$ npm install -g hexo-cli<br>그리고 설치 시작</p><p>Hexo가 설치되면 다음 명령을 실행하여 초기화한다.</p><p>$ hexo init 폴더명<br>폴더를 만들고<br>$ cd 폴더명<br>그 폴더로 이동하여<br>$ npm install<br>설치</p><p>앞으로 글을 쓸 때 내가 init 한 그 폴더에서 작업하면 된다.</p><p>글을 올릴 때는<br>$ hexo deploy<br>명령을 쓰면 되는데 그 전에 내가 글을 올릴 곳을 설정해줘야한다.</p><p>나는 깃을 쓰니까<br>$ npm install hexo-deployer-git –save<br>hexo-deployer-git 을 설치해야한다.<br>그리고 _config.yml 파일을 열면 설정을 수정할 수 있다.</p><p>몇 가지 커맨드로 간단히 글을 포스팅할 수 있다.</p><p>$ hexo new post 포스트제목<br>포스트제목에 만약 공백이 있으면 “” 로 묶어줘야한다.</p><p>$ hexo generate<br>(정적 파일을 생성)<br>$ hexo server<br>(서버를 확인)<br>$ hexo deploy<br>(글을 업로드)</p><p>정리하다보니 이게 정말 간단한건지…<br>네이버 블로그에 익숙한 내게는 조금 불편하긴 하다.<br>아직 익숙하지 않아서 그럴지도.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;헥소-설치&quot;&gt;&lt;a href=&quot;#헥소-설치&quot; class=&quot;headerlink&quot; title=&quot;헥소 설치&quot;&gt;&lt;/a&gt;헥소 설치&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
      <category term="기타" scheme="https://dearjsmc4.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
    
  </entry>
  
</feed>
