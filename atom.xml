<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rudy&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dearjsmc4.github.io/"/>
  <updated>2019-09-19T10:03:52.673Z</updated>
  <id>https://dearjsmc4.github.io/</id>
  
  <author>
    <name>Hwang Yu-Soon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>이벤트 설치, bind(this)</title>
    <link href="https://dearjsmc4.github.io/2019/09/19/0919/"/>
    <id>https://dearjsmc4.github.io/2019/09/19/0919/</id>
    <published>2019-09-18T15:00:00.000Z</published>
    <updated>2019-09-19T10:03:52.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- App.js --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Subject</span> <span class="attr">title</span>=<span class="string">"My Favorite Movies"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onChangePage</span>=<span class="string">&#123;this.goToMain&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Subject</span>&gt;</span></span><br></pre></td></tr></table></figure><p>제목을 클릭하면 goToMain() 함수가 동작하여 state 를 바꾸도록 할 것이다.<br>state 가 바뀌었음을 리액트가 감지하면 렌더 함수를 다시 호출하여 화면을 새로 그려준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Subject.js --&gt;</span><br><span class="line"></span><br><span class="line">class Subject extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;header&gt;</span><br><span class="line">        &lt;h1&gt;</span><br><span class="line">          &lt;a href=&quot;/&quot; onClick=&#123;function(e)&#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            this.props.onChangePage();</span><br><span class="line">          &#125;.bind(this)&#125;&gt;</span><br><span class="line">          &#123;this.props.title&#125;  </span><br><span class="line">          &lt;/a&gt;</span><br><span class="line">        &lt;/h1&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onClick</code> 이벤트가 발생하면<br>a 태그의 기본적인 동작(주소창을 바꾸고 페이지를 리로드)을 <code>e.preventDefault();</code> 로 막아주었고,<br>JSX 어트리뷰트는 해당 컴포넌트에 단일 객체로 전달되었으므로<br>Subject 컴포넌트 내에서 <code>this.props.onChangePage();</code> 로 호출해준다.<br><code>bind(this)</code> 를 해주어야 this 가 Subject 컴포넌트를 가리키게 되어<br><code>this.props.onChangePage();</code> 가 정상적으로 동작할 수 있다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line">goToMain = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* setState 로 state 를 바꾸면 렌더함수가 다시 호출됨.</span></span><br><span class="line"><span class="comment">    this.state = ~~ 로 바꾸면 바뀌긴 하지만 </span></span><br><span class="line"><span class="comment">    react 는 바뀐줄 모르기때문에 다시 렌더되지 않음. */</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      mode: <span class="string">'main'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>onChangePage</code> 에 연결된 <code>goToMain()</code> 함수는 <code>this.setState()</code> 메소드로<br>mode 를 main 으로 바꿔준다. </p><h2 id="bind-this"><a href="#bind-this" class="headerlink" title="bind(this)"></a>bind(this)</h2><p>사실 <code>bind(this)</code> 를 왜 굳이 해줘야하는지는 아직 이해가 완전히 되진 않았다.<br>글을 여러 개 찾아보았는데도…<br><a href="https://stackoverflow.com/questions/33973648/react-this-is-undefined-inside-a-component-function" target="_blank" rel="noopener">스택오버플로우</a>에서는 ‘리액트 컴포넌트는 메소드를 자동으로 바인딩하지 않는다. 생성자 내부에서 직접 바인드 해주어야 한다’ 고 했다. 실제로 <code>bind(this)</code>를 하지 않고 메소드를 호출하면 this 는 undefined 가 된다. </p><h3 id="this-문제를-해결하기"><a href="#this-문제를-해결하기" class="headerlink" title="this 문제를 해결하기"></a>this 문제를 해결하기</h3><ol><li><p>화살표 함수<br>화살표 함수의 this는 사용된 곳의 상위 스코프의 this 를 가리키게 된다.<br>따라서 App 컴포넌트를 가리키는 this 에 자동으로 바인딩된 것과 마찬가지.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myFunction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>생성자에서 this 바인딩 해주기<br>메소드를 화살표 함수가 아닌 일반 함수로 정의했다면<br>생성자에서 <code>bind(this)</code> 를 해주면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      mode: <span class="string">'read'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.goToMain = <span class="keyword">this</span>.goToMain.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>이벤트 걸 때 this 바인딩 해주기</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onClick=&#123;<span class="keyword">this</span>.goToMain.bind(<span class="keyword">this</span>)&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Event&quot;&gt;&lt;a href=&quot;#Event&quot; class=&quot;headerlink&quot; title=&quot;Event&quot;&gt;&lt;/a&gt;Event&lt;/h2&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="React" scheme="https://dearjsmc4.github.io/categories/react/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="React" scheme="https://dearjsmc4.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>State</title>
    <link href="https://dearjsmc4.github.io/2019/09/18/0918/"/>
    <id>https://dearjsmc4.github.io/2019/09/18/0918/</id>
    <published>2019-09-17T15:00:00.000Z</published>
    <updated>2019-09-19T08:20:48.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p><a href="https://ko.reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">State 와 생명주기</a><br>공식 문서가 읽기 좋게 되어 있어서 다행이다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      mode: <span class="string">'read'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>state 초기 설정은 <code>this.state = {}</code></li><li>state 업데이트는 <code>this.setState()</code><br>→ state 를 설정할 수 있는 곳은 constructor 뿐이며,<br><code>this.state.mode = &#39;main&#39;</code> 처럼 직접 수정할 수 없다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;State&quot;&gt;&lt;a href=&quot;#State&quot; class=&quot;headerlink&quot; title=&quot;State&quot;&gt;&lt;/a&gt;State&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ko.reactjs.org/docs/state-and-lifecycle.h
      
    
    </summary>
    
      <category term="React" scheme="https://dearjsmc4.github.io/categories/react/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="React" scheme="https://dearjsmc4.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Props</title>
    <link href="https://dearjsmc4.github.io/2019/09/17/0917-2/"/>
    <id>https://dearjsmc4.github.io/2019/09/17/0917-2/</id>
    <published>2019-09-16T15:00:00.000Z</published>
    <updated>2019-09-17T12:57:17.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Content</span> <span class="attr">title</span>=<span class="string">"Miss Sloane"</span> <span class="attr">desc</span>=<span class="string">"Lobbying is about foresight."</span>&gt;</span><span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br></pre></td></tr></table></figure><p>사용자 정의 태그에 위와 같은 어트리뷰트를 추가하고,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Content extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;article&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.props.title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.props.desc&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/article&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>렌더 함수에 <code>{this.props.title}</code> 과 <code>{this.props.desc}</code> 를 추가해준다.<br>이렇게 되면 같은 컴포넌트일지라도 사용자 정의 태그의 어트리뷰트 입력값에 따라 달라진 내용을 출력할 수 있다.</p><h3 id="Props-객체"><a href="#Props-객체" class="headerlink" title="Props 객체"></a>Props 객체</h3><p><a href="https://ko.reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">Components and Props</a>에서 살펴보았다.</p><blockquote><p>React가 사용자 정의 컴포넌트로 작성한 엘리먼트를 발견하면 JSX 어트리뷰트를 해당 컴포넌트에 단일 객체로 전달합니다. 이 객체를 “props”라고 합니다.</p></blockquote><p>Content 컴포넌트에서 this 를 콘솔창에 출력해보면 다음과 같은 내용을 확인할 수 있다.<br>​<img src="/../img/consoleprops.png" alt="콘솔창에서 확인할 수 있는 props"><br>props 객체 안에 title 과 desc 라는 키와 함께 내가 작성한 값이 들어있는 것을 확인할 수 있다.</p><p>(+)<br>props 라는 객체를 확인해보려다가 좋은 개발자도구 툴을 발견했다.<br><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" target="_blank" rel="noopener">React Developer Tools</a> 을 크롬에 추가하면 된다.</p><p>​<img src="/../img/props.png" alt="props">  </p><p>이 툴을 이용하면 props 의 값을 임의로 바꿔볼 수도 있다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Props&quot;&gt;&lt;a href=&quot;#Props&quot; class=&quot;headerlink&quot; title=&quot;Props&quot;&gt;&lt;/a&gt;Props&lt;/h2&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="React" scheme="https://dearjsmc4.github.io/categories/react/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="React" scheme="https://dearjsmc4.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>컴포넌트 파일 분리</title>
    <link href="https://dearjsmc4.github.io/2019/09/17/0917/"/>
    <id>https://dearjsmc4.github.io/2019/09/17/0917/</id>
    <published>2019-09-16T15:00:00.000Z</published>
    <updated>2019-09-18T04:56:18.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="컴포넌트-파일-분리"><a href="#컴포넌트-파일-분리" class="headerlink" title="컴포넌트 파일 분리"></a>컴포넌트 파일 분리</h2><ol><li>src 디렉토리에 components 라는 폴더를 만들었다.</li><li>js 파일을 만들었다. </li><li>코드를 작성한다. </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class Subject extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;header&gt;</span><br><span class="line">        &lt;h1&gt;My Favorite Movies&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;... that most of my friends don&apos;t know&lt;/p&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Subject;</span><br></pre></td></tr></table></figure><p>export 를 꼭 해주자.<br>이렇게 파일로 분리를 해두면 다른 파일에서도 import 하여 쓸 수 있다. </p><h3 id="export-default"><a href="#export-default" class="headerlink" title="export default?"></a>export default?</h3><p><a href="https://create-react-app.dev/docs/importing-a-component" target="_blank" rel="noopener">Create React App</a> 에서 살펴보았다.</p><blockquote><p>Be aware of the difference between default and named exports. It is a common source of mistakes.<br><strong>(default export 와 named export 의 차이점을 잘 알아두세요. 흔한 실수의 원인입니다.)</strong><br>We suggest that you stick to using default imports and exports when a module only exports a single thing (for example, a component).<br><strong>(모듈이 단 하나만(컴포넌트 하나라든지) export 할 경우에는 꼭 default imports 와 exports 를 사용하길 권장합니다.)</strong><br>That’s what you get when you use <code>export default Button</code> and <code>import Button from &#39;./Button&#39;</code>.<br><strong>(<code>export default Button</code> 와 <code>import Button from &#39;./Button&#39;</code> 를 쓰면 디폴트로 적용됩니다.)</strong><br>Named exports are useful for utility modules that export several functions. A module may have at most one default export and as many named exports as you like.<br><strong>(Named exports 는 다수의 함수를 export 하는 유틸리티 모듈에 유용합니다. 이 경우에 모듈은 최대 하나의 default export 와 다수의 named exports 를 포함할 수 있습니다.)</strong></p></blockquote><p>app.js 로 import 할 때에는 아래와 같이 작성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Subject <span class="keyword">from</span> <span class="string">'./components/subject'</span>;</span><br></pre></td></tr></table></figure><p>(+)<br>index.js 에서 App 의 이름을 바꿔도 상관없었던 이유가<br>App 이 디폴트로 export 되고 있었기 때문이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;컴포넌트-파일-분리&quot;&gt;&lt;a href=&quot;#컴포넌트-파일-분리&quot; class=&quot;headerlink&quot; title=&quot;컴포넌트 파일 분리&quot;&gt;&lt;/a&gt;컴포넌트 파일 분리&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;src 디렉토리에 components 라는 폴더를 만들었다
      
    
    </summary>
    
      <category term="React" scheme="https://dearjsmc4.github.io/categories/react/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="React" scheme="https://dearjsmc4.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>디렉토리 구조, 배포, 컴포넌트</title>
    <link href="https://dearjsmc4.github.io/2019/09/10/0910/"/>
    <id>https://dearjsmc4.github.io/2019/09/10/0910/</id>
    <published>2019-09-09T15:00:00.000Z</published>
    <updated>2019-09-17T12:56:59.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Create-React-App-의-디렉토리-구조"><a href="#Create-React-App-의-디렉토리-구조" class="headerlink" title="Create React App 의 디렉토리 구조"></a>Create React App 의 디렉토리 구조</h2><ul><li><p><strong>public</strong><br><code>npm run start</code> 했을 때의 document root 이다.<br>index.html 이 있는 곳이며, 그 안에서는<br><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code> 이 부분이 가장 중요하다.<br>내가 만든 컴포넌트들은 id 가 root 인 이 div 안에 모두 들어가기 때문이다.<br>그 컴포넌트들은 <strong>src</strong> 안에서 작업한다. </p></li><li><p><strong>src</strong><br>대부분의 파일들은 이 폴더에 들어간다.<br>entry 파일은 index.js 이다.<br>index.js 에서 눈여겨 볼 부분은<code>document.getElementById(&#39;root&#39;)</code>.<br>index.html 에 있었던 root div 를 참조한다.<br><code>&lt;App /&gt;</code> 은, 사용자 정의 태그인 컴포넌트이며, 이 컴포넌트의 실제 구현은 <strong>App.js</strong> 에서 한다.<br>Create React App이 샘플로 만든 컴포넌트의 실제 구현은 App.js 안에 들어있고,<br>실제 태그의 내용(JSX 식이라고 한다)은 return 문 안에 들어있다. </p></li></ul><h2 id="CSS-는"><a href="#CSS-는" class="headerlink" title="CSS 는?"></a>CSS 는?</h2><p>index.js 에서 index.css 를 import 하고 있고,<br>app.js 는 app.css 의 스타일이 적용된다.<br>(앵귤러의 app.component 가 리액트에서는 app.js 라고 생각된다.<br>앵귤러에서의 index.html, index.css 는 리액트와 같고.)</p><h2 id="배포"><a href="#배포" class="headerlink" title="배포"></a>배포</h2><p>Create React App 의 개발환경은 파일의 무게가 무겁다.<br>개발자만 쓸 때는 상관없지만, 배포할 때에는 문제가 있다.<br>그래서, 개발환경을 실행할 때에는 <code>npm run start</code> 를 쓰지만,<br>서비스하고자 빌드할 때에는 <code>npm run build</code> 라고 한다.<br>그러면 build 라는 디렉토리가 새로 생기게 되고,<br>서비스할 때에는 build 안에 있는 파일들을 쓰면 된다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g serve</span><br></pre></td></tr></table></figure><p>npm 을 통해 설치할 수 있는 간단한 서버이다.<br><code>serve -s build</code> 를 입력하면<br>내 컴퓨터 어디에서나 serve 라는 명령어를 통해 웹서버를 다운로드할 수 있게 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx serve -s build</span><br></pre></td></tr></table></figure><p>일회용 서버를 설치한다.<br>-s 는, 웹 서버를 다운로드 받아 실행할 때<br>build 디렉토리를 document root 로 하겠다는 뜻이다. </p><p>빌드하고나면 불필요하게 용량을 차지하는 정보가 모두 사라져 용량이 작아진다.<br>(npm run start 했을 때에는 1.8MB 였지만<br>빌드하고나면 130KB 정도밖에 되지 않았다.)</p><h2 id="컴포넌트"><a href="#컴포넌트" class="headerlink" title="컴포넌트"></a>컴포넌트</h2><p>정리의 도구.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// React 의 Component 를 상속받는 Subject 컴포넌트를 제작</span><br><span class="line">class Subject extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;header&gt;</span><br><span class="line">        &lt;h1&gt;My Favorite Movies&lt;/h1&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>render 함수의 return 문 안에는 최상위 태그가 하나 꼭 있어야 한다.<br>그렇지 않으면 return 문을 닫는 괄호에 빨간줄이 그어지면서<br><u>‘JSX 식에는 부모 요소가 하나 있어야 합니다’</u> 라는 메세지가 뜬다.<br>-&gt; <a href="https://reactjs-kr.firebaseapp.com/docs/introducing-jsx.html" target="_blank" rel="noopener">JSX 소개</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Create-React-App-의-디렉토리-구조&quot;&gt;&lt;a href=&quot;#Create-React-App-의-디렉토리-구조&quot; class=&quot;headerlink&quot; title=&quot;Create React App 의 디렉토리 구조&quot;&gt;&lt;/a&gt;Create R
      
    
    </summary>
    
      <category term="React" scheme="https://dearjsmc4.github.io/categories/react/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="React" scheme="https://dearjsmc4.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>개발환경 셋팅</title>
    <link href="https://dearjsmc4.github.io/2019/09/09/0909/"/>
    <id>https://dearjsmc4.github.io/2019/09/09/0909/</id>
    <published>2019-09-08T15:00:00.000Z</published>
    <updated>2019-09-17T12:57:40.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="리액트"><a href="#리액트" class="headerlink" title="리액트?"></a>리액트?</h2><ul><li>페이스북에서 만든 자바스크립트 UI 라이브러리</li></ul><p>웹사이트는 빠른 속도로 복잡해지고, HTML 코드는 정보에 따라 기하급수적으로 늘어난다.<br>이 많은 HTML 코드들을 정리정돈 하고 복잡한 코드 덩어리에 이름을 붙인다 -&gt; <strong>사용자 정의 태그</strong><br>그리고 index.html 에서는 사용자 정의 태그만 갖다 쓰면 끝.<br>-&gt; 앵귤러에서 컴포넌트를 <app-navigation></app-navigation> 이렇게 불러서 쓰는 것과 똑같다!</p><ul><li>장점: 가독성 / 재사용성 / 유지보수성 </li></ul><h2 id="개발환경-셋팅"><a href="#개발환경-셋팅" class="headerlink" title="개발환경 셋팅"></a>개발환경 셋팅</h2><p>툴 체인: 내게 필요한 여러가지 개발환경과 도구를 제공해준다.<br>-&gt; 나는 Create React App 을 사용</p><p>우선 npm 을 다운로드 한 후에 Create React App 설치<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g create-react-app</span><br></pre></td></tr></table></figure></p><p>(버전 확인은 <code>$ npm -v</code>)<br>(버전 업데이트는 <code>$ npm install npm@latest -g</code>)</p><p>앱을 관리할 디렉토리를 만들고 cd 로 이동한 뒤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ create-react-app .</span><br></pre></td></tr></table></figure></p><p>해당 디렉토리 안에 개발 환경이 셋팅된다.</p><p>(+)<br><code>npx create-react-app</code> 은<br>일회용으로 다운받아 실행하고 지워버리므로 항상 최신버전에서 작업할 수 있다.<br>실무에서는 npx 를 쓰기를 권장.</p><h2 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h2><p>해당 디렉토리에서<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run start</span><br></pre></td></tr></table></figure></p><p>하면 브라우저에 리액트의 샘플 웹앱이 나타난다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;리액트&quot;&gt;&lt;a href=&quot;#리액트&quot; class=&quot;headerlink&quot; title=&quot;리액트?&quot;&gt;&lt;/a&gt;리액트?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;페이스북에서 만든 자바스크립트 UI 라이브러리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;웹사이트는 빠른 속도로 복잡해지고
      
    
    </summary>
    
      <category term="React" scheme="https://dearjsmc4.github.io/categories/react/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="React" scheme="https://dearjsmc4.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Routing</title>
    <link href="https://dearjsmc4.github.io/2019/07/10/0710/"/>
    <id>https://dearjsmc4.github.io/2019/07/10/0710/</id>
    <published>2019-07-09T15:00:00.000Z</published>
    <updated>2019-07-12T08:48:51.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Angular-Routing"><a href="#Angular-Routing" class="headerlink" title="Angular Routing"></a>Angular Routing</h1><h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><p><strong>검색엔진최적화</strong>(Search Engine Optimization, SEO).<br>검색로봇이 24시간을 전세계 사이트를 돌아다닌다.<br>사이트들을 페이지별로 검색하고 다니면서 페이지의 HTML구조까지 들여다본다.<br>여기서 시맨틱구조가 중요한데, 검색엔진이 태그의 이름을 보고 이 페이지가 무엇에 대한 페이지인지 알 수 있기 때문이다.<br>예를 들어 <code>nav</code>태그는 중요한 메인메뉴를 가지고있을텐데, 그럼 그 네비게이션을 유심히 들여다볼 것이다.<br>사실 검색엔진이 무엇을 중요히 여기는지는 기밀이다.<br>검색엔진 동작원리에 맞춰 상위노출을 시도할 수 있기 때문이다.  </p><p>SEO가 적용되도록 만들려면 모든 페이지마다 고유한 URL을 가져야 한다.<br>Ajax의 경우 주소창이 변하지않는데, 그러면 모든 페이지가 주소가 하나이며, 검색엔진이 이게 한 페이지인지 열 페이지인지 알 수가 없다. 그래서 대부분의 SPA 애플리케이션은 라우터기능을 제공하고 있다. 단, SEO를 완전하게 충족시키려면 조금 다른 방법이 필요하다. 서버가 페이지를 제공해 주는 것이다. 앵귤러는 자체적으로 서버사이드 렌더링을 하기위한 모듈이 따로있고, 그것을 앵귤러 유니버설이라고 한다. 서버사이드렌더링으로 SPA를 구축하는 경우도 많고, 리액트도 그렇다. 리액트는 Next.js같은 서버사이드 렌더링을 지원해주는 프레임워크가 따로 있다.  </p><p>애플리케이션은 웹사이트가 아니기때문에 SEO에 그렇게 민감하지 않아도 될 수도 있다.<br>그러나 <strong>정보성</strong>을 띈 웹 앱이라면 SEO가 중요하다.  </p><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>라우팅모듈은 <strong>라우팅에 대한 정보</strong>를 담는 모듈이다. 모든 라우팅을 관리한다.<br>라우팅모듈이 주소창을 계속 주시하고 있다가, 주소창의 path가 바뀌면 그에 해당하는 컴포넌트를 화면에 활성화시켜 화면 전환이 이루어진다. </p><p>라우트를 구성하려면 모듈을 추가해주어야 하는데, <code>ng new</code> 로 앵귤러 프로젝트를 생성할 때 라우팅 옵션에 yes 라고 답하면 app-routing-module.ts 파일이 생성된다.  </p><ul><li>또는 <code>ng g m 모듈이름 --routing</code> 을 하면 모듈과 함께 라우팅 모듈도 함께 생성된다.<br>라우팅모듈은 모듈이 가지고 있는 컴포넌트들의 라우팅을 관리한다.<br>라우팅모듈에는 필요한 컴포넌트들을 임포트 해주어야 하며, 라우트 구성을 작성해준다.<br>라우팅모듈은 라우팅을 사용하는 피쳐모듈이 임포트하고, 그 모듈은 루트모듈이 임포트한다.<br>루트모듈에 임포트할 때에는, 반드시 AppRoutingModule 이전에 등록해준다.  </li></ul><p>루트모듈에 라우팅모듈을 등록해준다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AppRoutingModule &#125; <span class="keyword">from</span> <span class="string">'./app-routing.module'</span>;</span><br><span class="line"></span><br><span class="line">imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    AppRoutingModule </span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><p>라우팅 모듈은 다음과 같이 작성된다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; IndexComponent &#125; <span class="keyword">from</span> <span class="string">'./components/index.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ServiceComponent &#125; <span class="keyword">from</span> <span class="string">'./components/service.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AboutComponent &#125; <span class="keyword">from</span> <span class="string">'./components/about.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NotFoundComponent &#125; <span class="keyword">from</span> <span class="string">'./components/not-found.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 라우트 구성</span></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123; path: <span class="string">''</span>, redirectTo: <span class="string">'home'</span>, pathMatch: <span class="string">'full'</span> &#125;,</span><br><span class="line">  &#123; path: <span class="string">'home'</span>, component: IndexComponent &#125;,</span><br><span class="line">  &#123; path: <span class="string">'service'</span>, component: ServiceComponent &#125;,</span><br><span class="line">  &#123; path: <span class="string">'about'</span>, component: AboutComponent &#125;,</span><br><span class="line">  &#123; path: <span class="string">'**'</span>, component: NotFoundComponent &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes)],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppRoutingModule &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>라우팅 모듈에는 라우트 구성이 등록된다.<br>객체로 이루어진 배열에서 path와 일치하는 컴포넌트를 찾아 화면에 활성화시켜준다.  </p><p><code>imports: [RouterModule.forRoot(routes)]</code><br>모든 라우트 구성을 포함한 라우터 모듈을 생성하고, 루트모듈에 등록한다. forRoot라는 함수를 호출하고, 우리가 사용할 routes를 인수로 던져준다. 만약 자식에서 쓰려면 forChild로 쓰인다. 반드시 export 해주어야한다.  </p><p>라우팅을 위한 템플릿은 다음과 같이 작성한다.  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/"</span>&gt;</span>Logo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/service"</span>&gt;</span>Service<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>활성화시킬 컴포넌트를 사용하는 컴포넌트에선 컴포넌트의 태그명으로 쓰는게아니라 <code>router-outlet</code>을 이용한다. </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-navigation</span>&gt;</span><span class="tag">&lt;/<span class="name">app-navigation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>404페이지를 만들고싶을때에는, 라우트모듈의 path 를 <code>**</code>로 해준다. ‘배열 안의 그 어떤 path에도 해당하지 않으면,’ 이라는 뜻이다. 항상 맨 마지막에 달아주도록 한다. </p></li><li><p>만약 로고를 눌러도, 다른 메뉴를 눌러도 인덱스 페이지로 돌아가게 해주고 싶으면, <code>redirectTo: &#39;home&#39;</code> 으로 설정해준다. <code>pathMatch</code>와 함께 써야 한다.  </p></li></ul><!-- 그러나 라우팅은 네비게이션에서만 하는게 아니다. 로그인에 따라 라우팅이 달라질수있고 네비게이션도 없을때 어떻게하면될까.movies/:id 이렇게 보낼때에는, 라우터링크에 배열을 할당한다. 이렇게 해서 이동한 페이지에서, 그 컴포넌트에서는 서버에 아이디를 주고 그에 맞는 데이터를 가져와서 보여줘야한다. 여기서 activateroute를 쓰는구나. 왜 굳이 파라미터를 가져와야하나 싶었는데. 이걸 디테일페이지에서 캐치해서 서버와 통신해야하니까...this.route.paramMap.subscribe(  params => params.get('id'))옵저버블이라는 뜻이고, 파라미터가 변하는지를 주시하고있다는 뜻. 여기서 id 를 가져올 수 있음.만약 파라미터가 동적인 변수가 아니라 정적인 값을 보내야한다면path, component, 그리고 data를 준다data: { cart: true } => 이 컴포넌트에서는 카트를 표시해라.그래서 컴포넌트 안에서 data를 받아서 this.data에 할당해주면. data가 트루이면 보여지고 아니면 안보여지고.돔을 그리는 것: 컴포넌트컴포넌트를 활성화할지 결정하는것: 라우터 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Angular-Routing&quot;&gt;&lt;a href=&quot;#Angular-Routing&quot; class=&quot;headerlink&quot; title=&quot;Angular Routing&quot;&gt;&lt;/a&gt;Angular Routing&lt;/h1&gt;&lt;h2 id=&quot;SEO&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular Template Driven Form</title>
    <link href="https://dearjsmc4.github.io/2019/07/08/template-form/"/>
    <id>https://dearjsmc4.github.io/2019/07/08/template-form/</id>
    <published>2019-07-07T15:00:00.000Z</published>
    <updated>2019-07-11T09:42:01.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Angular-Forms"><a href="#Angular-Forms" class="headerlink" title="Angular Forms"></a>Angular Forms</h1><h2 id="Template-driven-forms"><a href="#Template-driven-forms" class="headerlink" title="Template driven forms"></a>Template driven forms</h2><p>컴포넌트 클래스는 거의 쓰지않고 템플릿에서 폼을 관리한다. 리액티브 폼(컴포넌트 클래스에서 폼을 관리)과는 반대되는 방식이다.  </p><p>템플릿 기반 폼은 NgForm, NgModel, NgModelGroup 디렉티브를 중심으로 동작하는데, 이들을 이용할 때에는 먼저 루트 모듈에 <code>FormsModule</code> 을 추가해준다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FormsModule</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><p>이렇게 하면 모든 폼에 <strong>NgForm 디렉티브가 자동 적용</strong>되어 템플릿 기반 폼으로 동작한다. 이제 폼은 HTML 표준 폼으로서가 아니라 앵귤러가 관리하는 폼으로서 동작한다. 콘솔에서 폼을 확인해보면 form 태그 안에 novalidate 가 추가되어 있음을 확인할 수 있다.<br>(novalidate 와 반대로 <code>ngNoForm</code> 은 HTML 표준 폼으로 동작하게 한다.)<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> #<span class="attr">userForm</span>=<span class="string">"ngForm"</span> (<span class="attr">ngSubmit</span>)=<span class="string">"onSubmit(userForm)"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>템플릿 기반 폼에도 참조변수를 사용할 수 있으며, 이때 참조변수가 <code>NgForm</code> 인스턴스를 가리킬 수 있도록 바인딩 해주어야 한다.<br>앞으로 컨트롤 요소값을 확인할 때 이 참조변수명을 이용하여 확인한다. <code>ex) userForm.value</code><br>또한 현재 폼은 NgForm 디렉티브가 적용되어 있으므로 HTML 표준 폼으로서의 submit 이벤트가 실행되지 않는다. 따라서 대신 <code>ngSubmit</code> 이벤트를 사용해야 한다.  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userid"</span> #<span class="attr">userid</span>=<span class="string">"ngModel"</span> <span class="attr">ngModel</span>&gt;</span></span><br></pre></td></tr></table></figure><p>NgForm 디렉티브는 폼 요소의 자식 폼 컨트롤 요소 중에 <code>NgModel</code> 디렉티브가 적용된 요소를 탐색하여 <code>FormGroup</code> 인스턴스에 추가한다. NgModel 디렉티브는 <code>FormControl</code> 인스턴스를 생성하는데, FormControl 은 FormGroup 의 프로퍼티로 추가된다. 따라서 템플릿 기반 폼의 구조는 다음과 같아진다.  </p><ul><li>NgForm  <ul><li>FormGroup  <ul><li>FormControl</li><li>FormControl</li><li>FormControl<br>(…)  </li></ul></li></ul></li></ul><p>템플릿 기반 폼은 input 태그 내에 <code>name</code> 어트리뷰트가 없으면 에러가 난다. 왜냐면<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userForm.value: &#123;</span><br><span class="line">  <span class="string">"userid"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"password"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>userForm.value 로 상태값을 찍어보면 위와 같이 나오는데, 폼 컨트롤 요소의 상태값을 나타낼 때의 키는 name 어트리뷰트의 값이기 때문이다. 따라서 name 어트리뷰트가 반드시 있어야 한다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userid"</span> </span></span><br><span class="line"><span class="tag">  #<span class="attr">userid</span>=<span class="string">"ngModel"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"user.userid"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>NgModel 디렉티브에 <code>[()]</code> 문법을 사용하면 양방향 데이터 바인딩으로 사용가능하다. 양방향 바인딩은 이벤트 바인딩(ngModelChange)과 프로퍼티 바인딩(ngModel)의 축약표현이다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Angular-Forms&quot;&gt;&lt;a href=&quot;#Angular-Forms&quot; class=&quot;headerlink&quot; title=&quot;Angular Forms&quot;&gt;&lt;/a&gt;Angular Forms&lt;/h1&gt;&lt;h2 id=&quot;Template-driven-forms
      
    
    </summary>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/categories/angular/"/>
    
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>Module</title>
    <link href="https://dearjsmc4.github.io/2019/07/08/0708/"/>
    <id>https://dearjsmc4.github.io/2019/07/08/0708/</id>
    <published>2019-07-07T15:00:00.000Z</published>
    <updated>2019-07-11T09:37:51.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Angular-NgModule"><a href="#Angular-NgModule" class="headerlink" title="Angular NgModule"></a>Angular NgModule</h1><p>모듈은 컴포넌트를 가지고 있다.  </p><p>Angular의 큰 덩어리 하나하나가 합쳐져 하나의 모듈이 된다.<br>키워드: <strong>재사용성</strong>. 같은 기능을 하나로 합친다.  </p><ul><li>Angular의 모듈<ol><li><strong>기능모듈</strong>  <ul><li>프론트에게 가장 중요한 건 화면이다.  </li></ul></li><li><strong>공유모듈</strong><ul><li>여러 화면에 쓰이는 공유모듈은 shared라는 이름으로 만들어주는게 통상적이다. 기능모듈이 공유모듈을 import 한다.  </li></ul></li><li><strong>코어모듈</strong>  <ul><li>서비스 위주이다.  </li></ul></li></ol></li></ul><h2 id="About-Module"><a href="#About-Module" class="headerlink" title="About Module"></a>About Module</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure><p>데코레이터의 인자는 <strong>메타데이터 객체</strong>이다. 메타데이터 객체에는 컴퓨터에게 알려주는 정보들이 담겨있다. 메타데이터 객체 안의 정보를 전달하여 데코레이터가 장식하는 클래스의 인스턴스가 만들어질 때 관여한다. 위의 상황에서는 AppModule 인스턴스가 만들어질 때 메타데이터 객체가 필요한 것이다.  </p><p>가장 중요한 부분은 <strong>선언부(declarations)</strong>이다. 이 부분에는 우리가 만드는 모든 컴포넌트, 모든 파이프, 모든 디렉티브를 나열하여준다. 그러면 루트모듈이 관장하는 전체 애플리케이션에서 루트모듈 선언부에 등록된 것들이 사용가능해진다. </p><p><strong>imports</strong>에서는 루트모듈이 사용하는 <strong>모듈</strong>을 쓴다. 모듈은 모듈을 사용할 수 있다. 루트모듈이 기능모듈과 코어모듈을 임포트하여 쓴다고 했듯이. 루트모듈은 <code>BrowserModule</code> 을 사용하고있는데, BrowserModule 은 루트모듈에 반드시 들어가있어야한다. BrowserModule 은 브라우저에서 동작하는 애플리케이션을 만들 때 필요한 모듈들을 모아놓은 것이다. 코어모듈을 자체적으로 임포트하고 있는데, 그 코어모듈안에는 ngIf, ngFor 같은 디렉티브들이 들어가있다. BrowserModule 은 루트모듈에만 정의해두면된다. 추후에 만들 모듈에는 BrowserModule 이 아닌 <code>CommonModule</code> 만 있다. CommonModule 은 코어모듈의 디렉티브들을 지원하는 것들이 있다. </p><p><strong>providers</strong>는 서비스만 써준다. 요즘에는 역할이 무색해졌는데, Angular6로 넘어오면서 Injectable 데코레이터에 <code>provideIn</code> 이 생기면서 여기에 서비스를 써줄 수 있게 되었기 때문이다. 만약 provideIn 에 쓰지 않으면 providers에 적어주면 된다. </p><p>루트모듈은  <code>bootstrap: [AppComponent]</code> 를 갖고있어야 한다. Angular 애플리케이션을 가동하면 루트모듈이 돌면서 필요한 모듈이나 컴포넌트, 디렉티브를 불러모으는데, 가장 먼저 실행하는 것이 모든 컴포넌트들의 부모인 <strong>App Component 를 발화</strong>하는 것이다. 즉, 진입점인 App Component 가 뜨지 않으면 다른 컴포넌트들도 다 뜨지 않는다. 루트컴포넌트가 발화하면 루트컴포넌트의 템플릿에 쓰여진 내용이 가장 먼저 기동된다. 보통 라우터를 먼저 쓴다. </p><!-- 서비스내의 providedIn 이 있으니까 모듈에 따로 안 넣어도 되고, root 라는 말은 전역에서 사용할 수 있는 서비스라는 뜻이다. root 를 코어모듈로 바꿔주면 된다. exports는 모듈이 아니라 컴포넌트를 가지고 한다.  -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Angular-NgModule&quot;&gt;&lt;a href=&quot;#Angular-NgModule&quot; class=&quot;headerlink&quot; title=&quot;Angular NgModule&quot;&gt;&lt;/a&gt;Angular NgModule&lt;/h1&gt;&lt;p&gt;모듈은 컴포넌트를 가지고 
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>Forms</title>
    <link href="https://dearjsmc4.github.io/2019/07/03/0703/"/>
    <id>https://dearjsmc4.github.io/2019/07/03/0703/</id>
    <published>2019-07-02T15:00:00.000Z</published>
    <updated>2019-07-04T01:13:00.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h2><h3 id="HTML-Forms"><a href="#HTML-Forms" class="headerlink" title="HTML Forms"></a>HTML Forms</h3><p>폼은 직접 사용자와 대면하는 곳이기 때문에 친절해야하고 사용하기 편해야 하며, 깨끗하고 아름다워야 한다. 꼼꼼히 만들어야 한다. 폼이 있으면 폼 상에 submit 이벤트가 발생할 수 있도록 submit 타입의 버튼이 있어야 한다. (요즘은 button tag에 submit 타입을 걸어주는 경우가 많다고 한다)  </p><p>서버에 스트레스를 주지 않기 위해 폼에 대한 <strong>유효성 검사</strong>(validation check)는 클라이언트 측에서 해주어야 한다. 그리고 틀린 곳이 있다면 사용자에게 알려주어서 다시 데이터를 입력할 수 있게 안내해야 한다. 모든 절차가 끝난 후에야 서버로 날리는 것이다. 그리고 데이터를 보낼 때에는 조금씩 여러 번 보내는 것이 아니라, 한번에 보내는 것이 좋다. 서버는 요청이 와야 동작하고, 서버와 클라이언트는 일대다 관계이기 때문에 최소한의 요청을 보내야 서버의 스트레스를 줄여줄 수 있다.  </p><ul><li>폼 요소 : form 태그 전체  </li><li>폼 컨트롤 : form 태그 안의 요소들  </li></ul><p>폼에는 <code>action</code> 과 <code>method</code> 라는 두 어트리뷰트를 쓰는데,<br><code>action=&quot;url&quot;</code><br><code>method=&quot;GET/POST&quot;</code><br>와 같은 형태로 써준다.<br>클라이언트가 서버에게 정보를 주는 방식은 다양한데 그 중 대표적인건 GET과 POST<br>url의 <strong>쿼리</strong>에 담아서 보낸다. 쿼리부분은 ?키=밸류&amp;키=밸류&amp;키=밸류… 형식으로 이루어진 부분이다.  </p><!-- 그러나 ajax에서는 폼요소가 아니라 폼컨트롤들만 써서 그걸로 객체를 만들어서 페이로드를 날렷엇는데, 앵귤러에서는 폼요소를 쓴다.--><p>폼을 왜 쓰냐면, 모든 폼 컨트롤의 유효성검사 결과가 true이면 폼 전체의 유효성검사 결과 역시 true이므로, <strong>폼 컨트롤 전체를 하나로 관리</strong>하기 위해서 쓰는 것이다. 앵귤러에서는 두 가지 방식이 있는데,  </p><ol><li><strong>템플릿 기반 폼</strong> -&gt; 폼 관리의 주체가 템플릿 -&gt; 템플릿이 복잡해지는 단점 -&gt; 간단한 폼일 때 쓴다  </li><li><strong>리액티브 폼</strong> -&gt; 폼 관리의 주체가 컴포넌트 클래스 -&gt; 폼이 클 때 쓴다<br>이 두 가지 방식으로는 특히 에러처리가 편하다. </li></ol><p>ex) <code>action=&quot;/signup&quot;</code> 일 때 -&gt; REST API 라는 뜻이다. 파일명으로 요청하는 게 아니라 path 로 요청하고 있기 때문이다. HTML 파일을 준 서버와 데이터를 요청할 서버가 다를 수 있는데, 이 상황에선 같은 곳에 있다는 뜻이다.  </p><p>input 태그의 어트리뷰트  </p><ul><li><strong>required</strong> : 값이 반드시 입력되어야 함    </li><li><strong>pattern</strong> : 정규표현식  </li></ul><h3 id="Angular-Forms"><a href="#Angular-Forms" class="headerlink" title="Angular Forms"></a>Angular Forms</h3><p><code>FormsModule</code> 을 추가한 순간, <code>novalidate</code> 가 자동으로 form 태그에 추가된다. 이는 HTML 표준 폼으로써의 동작을 막는다. 그로 인해 submit 의 기본동작도 막는다: form action 에 걸려있는 경로로 리퀘스트를 날리고, 화면 전환하는 동작을 막는다. 따라서 앵귤러에서는 대신 <code>ngSubmit</code> 이벤트를 이용한다.  </p><p>폼 요소는 폼 컨트롤 요소의 부모로서 존재하며, 모든 폼 컨트롤 요소들의 유효성검증 상태가 true 이면 폼 자체의 유효성검증상태도 true가 된다.</p><p><code>#form=&quot;ngForm&quot;</code><br>템플릿 참조변수를 선언하고, 앵귤러가 관리하는 폼에 대한 인스턴스를 바인딩한다.<br>폼 컨트롤 요소에 ngModel 을 추가하면 앵귤러가 관리하게 되고, 이때부터는 앵귤러가 관리하는 폼 컨트롤 요소에 name 어트리뷰트가 없으면 에러가 난다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Forms&quot;&gt;&lt;a href=&quot;#Forms&quot; class=&quot;headerlink&quot; title=&quot;Forms&quot;&gt;&lt;/a&gt;Forms&lt;/h2&gt;&lt;h3 id=&quot;HTML-Forms&quot;&gt;&lt;a href=&quot;#HTML-Forms&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>옵저버블, 에러핸들러, 인터셉터</title>
    <link href="https://dearjsmc4.github.io/2019/07/01/0701/"/>
    <id>https://dearjsmc4.github.io/2019/07/01/0701/</id>
    <published>2019-06-30T15:00:00.000Z</published>
    <updated>2019-07-01T10:36:34.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="subscribe-옵저버블-옵저버"><a href="#subscribe-옵저버블-옵저버" class="headerlink" title="subscribe, 옵저버블, 옵저버"></a>subscribe, 옵저버블, 옵저버</h2><p>http 메소드 get 을 날렸을 때, <strong>subscribe</strong>를 안 하면 요청을 받을 수 없다.<br>옵저버블은 관측 대상이므로, 그것을 지켜보고 있는 옵저버가 없으면 아무것도 하지 않는다.<br>옵저버블과 옵저버를 이어주어야 하는데(옵저버가 옵저버블을 바라보게), 그것이 바로 subscribe 이다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.http.get&lt;Todo[]&gt;(<span class="keyword">this</span>.url)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">todos</span> =&gt;</span> <span class="keyword">this</span>.todos = todos);</span><br></pre></td></tr></table></figure><p>옵저버는 subscribe 라는 메소드를 통해서 옵저버블을 지켜보고 있다.<br>데이터를 가져온 결과물을 옵저버에게 notification 해준다.  </p><ul><li>옵저버블: 데이터 스트림을 방출할 수 있는 객체.<br>즉, 데이터 스트림을 가지고 있다. 옵저버가 있으면 옵저버에게 방출하고, 옵저버가 없으면 방출하지 않는다.  </li><li>옵저버: 관측자. 옵저버블을 관측하며 데이터를 받는다.  </li><li>subscribe: 옵저버블과 옵저버를 이어준다.  </li></ul><p>subscribe의 인수로 전달하는 것이 옵저버이다.<br>옵저버블이 객체고, 옵저버는 함수.<br><code>옵저버블.subscribe(옵저버)</code><br>=&gt; 인수로 전달한 옵저버가 옵저버블을 subscribe한다는 뜻이다.<br>뭔가 행위를 통해서 가져온 데이터를 옵저버의 인수로 넘겨준다.<br>따라서 인수의 네이밍을 제대로 하려면 우리가 무엇을 가져올 지를 알아야 한다.  </p><p>위의 예제에서, 옵저버블은 todos를 옵저버에게 전달한다.<br>get 메소드는 자기가 무엇을 가져올 지를 모른다. 그래서 무조건 <strong>객체를 리턴</strong>하도록 되어있고, 타입을 맞춰서 할당해주어야 하므로 <code>&lt;Todo[]&gt;</code> 를 해주는 것이다. -&gt; 제네릭!<br>or,<br><code>todos as Todo[]</code> -&gt; todos는 Todo[]타입으로 보겠다. -&gt; 강제형변환. 타입캐스팅.  </p><p>subscribe 안에는 데이터가 왔을 때 할 일을 적어주는 것이다.<br>-&gt; 옵저버블님, 데이터 가져오시면 todos에 주세요. 그럼 제가 어떠한 일을 하겠습니다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.http.delete&lt;Todo&gt;(<span class="string">`<span class="subst">$&#123;this.url&#125;</span><span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.todos = <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id !== id));</span><br><span class="line">  <span class="comment">// subscribe(_ =&gt; this.todos = this.todos.filter(todo =&gt; todo.id !== id));</span></span><br></pre></td></tr></table></figure><p>위의 예제에서는 빈 객체가 넘어오는 상황이고, 빈 객체는 받아줄 필요가 없으므로 함수의 매개변수는 비워둔다.<br><code>()</code> 대신 <code>_</code> 를 쓰면, 인수가 넘어왔을 때 쓰지 않겠다는 명확한 의사표시이다.  </p><p>subscribe도 then과 마찬가지로, 두 번째 함수를 주면 에러를 캐치하게 된다.  </p><h2 id="에러핸들러"><a href="#에러핸들러" class="headerlink" title="에러핸들러"></a>에러핸들러</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.http.get&lt;Todo[]&gt;(<span class="keyword">this</span>.url)</span><br><span class="line">  .subscribe(</span><br><span class="line">    <span class="comment">// 요청 성공 처리 콜백 함수 (Observer의 next 메소드)</span></span><br><span class="line">    todos =&gt; <span class="keyword">this</span>.todos = todos,</span><br><span class="line">    <span class="comment">// 요청 실패 처리 콜백 함수 (Observer의 error 메소드)</span></span><br><span class="line">    (error: HttpErrorResponse) =&gt; <span class="built_in">console</span>.error(error)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>에러핸들러에 인수로 에러를 전달해서, 에러가 이벤트객체타입이다, 라고 판별되면 클라이언트 에러이고, 아니면 백엔드의 에러로 판별된다.  </p><p><code>todos$</code> 처럼 달러가 뒤에 붙으면 옵저버블이라는 암묵적 표시이다.  </p><p>파이프로 <code>shareReplay</code>를 걸어주면 옵저버블이 <strong>공유옵저버블</strong>이 된다.  </p><h3 id="콜드-옵저버블-핫-옵저버블"><a href="#콜드-옵저버블-핫-옵저버블" class="headerlink" title="콜드 옵저버블, 핫 옵저버블"></a>콜드 옵저버블, 핫 옵저버블</h3><p><strong>콜드 옵저버블</strong>: 옵저버와 옵저버블이 일대일관계. 유니캐스트.<br><strong>핫 옵저버블</strong>: 여러 개의 옵저버가 하나의 옵저버블을 <strong>공유</strong>. 멀티캐스트.  </p><p>shareReplay 라는 오퍼레이터는, 콜드 옵저버블을 핫 옵저버블로 만든다.<br>-&gt; 여러번 subscribe을 해도 동일한 데이터가 간다.  </p><h2 id="인터셉터"><a href="#인터셉터" class="headerlink" title="인터셉터"></a>인터셉터</h2><!-- 좀 어려운데, 프로젝트에 쓰일 수도 있음.  --><ul><li><p>인터셉터가 왜 필요한가<br>만약 로그인을 하지 않은 상태에서 메인페이지로 바로 접근하려고 하면 튕겨낼 필요가 있다.<br>이때 로그인을 했는지 안 했는지 확인하고 튕겨내야 하는데, 보통 서버가 보안을 걸어놓는다.<br>그럼 우리는, 로그인에 성공하면 백엔드가 우리에게 넘겨주는 토큰을(지금은 일단 JWT(JSON Web Token)방법) 받는다. 로그인에 성공했으므로 토큰이라는 객체를 json으로 주고, 그것을 받아서 클라이언트가 가지고 있어야 한다(이 방법은 여러가지인데 심플하게는 로컬스토리지나 쿠키에 담는다. 보안 측면에서는 쿠키가 조금 더 낫지만 둘 다 장단점이 있다). 토큰은 암호화되어서 오기 때문에 우리가 열어봐도 뭔지 모른다. 로그인 페이지 이후에 보안이 필요한 다른 페이지로 갈때는 항상 토큰을 들고 간다. 그럼 토큰을 어떻게 서버에 줄것인가? 결론은 ‘<strong>헤더</strong>에 담는다’. 라우팅을 써서 이동할 때마다 헤더셋팅을 해야한다는 말인데, 귀찮다! 그래서 인터셉터라는 것을 만들어둬서 무조건 토큰을 담아가게 만든다. 인터셉터를 만들어두면, 우리가 요청할 때마다 헤더셋팅을 일일이 해줄 필요가 없어진다.  </p></li><li><p>파이프라인이란?<br>우리가 서버에 요청을 보내려고 코드로 적는 모든 과정들을 파이프라인이라고 한다.<br>인터셉터를 한 번 만들어두면 HTTP 요청을 검사하거나 변환할 수 있다.  </p></li></ul><p>인터셉터를 작성하려면 HttpInterceptor 인터페이스를 implements 해야 한다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AuthInterceptor <span class="keyword">implements</span> HttpInterceptor &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> auth: AuthService</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  intercept(req: HttpRequest&lt;<span class="built_in">any</span>&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;<span class="built_in">any</span>&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> authToken = <span class="keyword">this</span>.auth.getToken();</span><br><span class="line">    <span class="keyword">const</span> clonedRequest = req.clone(&#123;</span><br><span class="line">      headers: req.headers.set(<span class="string">'Authorization'</span>, authToken)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next.handle(clonedRequest);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  ...</span><br><span class="line">  providers: [&#123;</span><br><span class="line">    provide: HTTP_INTERCEPTORS,</span><br><span class="line">    useClass: AuthInterceptor,</span><br><span class="line">    multi: <span class="literal">true</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>리퀘스트 메세지에 있는 헤더에는 키가 있고 값이 있다. 요청할 때 우리가 authorization(백엔드와 합의된 키 이름)이라는 키를 넣고, 값으로는 토큰의 전체문자열을 넣고 서버에 날린다. 서버는 우리와 합의된 그 authorization이라는 키에 토큰이 담겨있겠거니 생각하고 그것을 꺼내서 서버에서 확인한다. 암호화된 토큰을 서버에서는 풀 수 있기 때문에, 확인해서 권한이 있는지 없는지를 확인한다. 따라서 JWT를 쓸 것이라면 서버와 클라이언트는 이 키를 합의해놓아야 한다. 그리고 그 키의 값으로 로컬스토리지에 담아놓은 토큰을 꺼내서 요청할 때 키와 값을 담아서 보내는 것이다.<br>인터셉트는 첫번째 인수로 우리가 날릴 리퀘스트 객체를 준다. (여기에서 백엔드와 합의한 키와 토큰값을 셋팅한다)<br>그리고 루트모듈에 providers 를 추가한다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;subscribe-옵저버블-옵저버&quot;&gt;&lt;a href=&quot;#subscribe-옵저버블-옵저버&quot; class=&quot;headerlink&quot; title=&quot;subscribe, 옵저버블, 옵저버&quot;&gt;&lt;/a&gt;subscribe, 옵저버블, 옵저버&lt;/h2&gt;&lt;p&gt;ht
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>생명주기, 서비스, RxJS</title>
    <link href="https://dearjsmc4.github.io/2019/06/25/0625/"/>
    <id>https://dearjsmc4.github.io/2019/06/25/0625/</id>
    <published>2019-06-24T15:00:00.000Z</published>
    <updated>2019-07-01T10:41:20.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="생명주기"><a href="#생명주기" class="headerlink" title="생명주기"></a>생명주기</h2><p>태어나서 죽을 때까지의 과정. 컴포넌트가 생성되어서 Input프로퍼티에 값이 들어오거나, 변경되거나, 모든 뷰의 초기화가 완료되었을 때(컴포넌트가 사망하면) 그때마다 우리가 무언가 작업을 해야한다면 앵귤러는 그때 필요한 훅 메소드를 제공한다. 어떤 일을 아무 때나 하는게 아니라 타이밍에 맞춰서 해야한다는 것이다. </p><p>(constructor는 생명주기와 큰 상관이 없음.)  </p><p>인터페이스는 하나 이상의 추상메소드를 가질 수 있다. 정의만 되고 실체가 없는데,<br>이것을 implement 했을 때에는 추상 메소드를 구현해야한다. 훅 메소드는 항상 <code>ng</code>가 붙고, 그 뒤의 이름은 인터페이스 이름과 일치한다. <strong>ngOnInit</strong>은 활용빈도가 높아 중요하다. 모든 초기화작업은 <code>ngOnInit</code>에서 하는 것이 좋다. 앵귤러는 자바스크립트와 달리 constructor에서는 많은 일을 하지 말 것을 요구하기 때문이다. (앞으로 웬만하면 constructor 에서는 아무것도 하지말고 대신 <code>ngOnInit</code>에서 하도록 한다)<br>앵귤러가 Input프로퍼티에 값을 넣어주는 것을 보장하는 때는 <code>ngOnInit</code>이 호출될 때이다.  </p><ul><li><p><strong>ngOnChanges</strong><br>Input프로퍼티가 있을 때, 처음으로 값이 들어오거나 변경되었을 때 실행된다.  </p></li><li><p><strong>ngOnInit</strong><br>무조건 한 번만 호출  </p></li><li><p><strong>ngDoCheck</strong><br>혹여나 변화를 감지하지 못하는 경우에 쓴다. 그러나 퍼포먼스상 안 좋으니 쓰지말자.  </p></li></ul><!-- 이제까지는 컴포넌트를 호출할때 컨텐트를 주지 않았지만, 원래 할 수 있다. <app-root>content</app-root> 컨텐트 프로젝션이라고 한다. --><ul><li><p><strong>ngAfterViewInit</strong><br>화면에 DOM요소를 동적으로 추가할 때 이 훅 메소드를 써야 한다.<br>추가된 요소들은 DOM이 완성된 후에야 참조가 가능하니까, 이 메소드로 뷰가 모두 완성되면, 이라는 타이밍에 추가된 요소들을 이 메소드 안에서 참조하도록 한다. </p></li><li><p>ngOnDestroy<br>컴포넌트와 디렉티브가 사망(…)할 때  </p></li></ul><h2 id="서비스"><a href="#서비스" class="headerlink" title="서비스"></a>서비스</h2><p>디자인패턴이 등장한다. 우리 선배들이 개발할 때 고민했던 부분들의 해결방법. 그래서 어렵다.  </p><p>서비스는, 우리 어플에서 중복적으로 사용하는 기능을 따로 떼어내는것. 마치 함수처럼!<br>뷰를 담당하는 것이 아니기 때문에 템플릿이 없다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 루트컴포넌트</span></span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greetingService = <span class="keyword">new</span> GreetingService();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>루트컴포넌트가 인스턴스를 직접 생성한다면 서비스에 의존하고 있는 것이다. 인스턴스가 없으면 일을 못하기 때문이다. 이때 서비스를 <code>의존성</code>이라고 부른다.<br>컴포넌트는 의존성의 메소드를 사용하기 위해서는 인스턴스를 직접 생성해야하며, 생성방법도 알아야하며, 메소드의 사용법도 알아야한다. 컴포넌트가 알아야할것이 너무 많다! -&gt; 긴밀히 결합되어있다.  </p><p>이로인해 문제가 생긴다. 만약 서비스가 메소드의 이름을 바꾸거나, 인수를 안 받았었는데 받기로 바꾸거나 하면 컴포넌트의 코드도 바뀌어야한다. 만약 클래스의 이름이 바뀐다면 new 코드도 바뀌어야한다. 결국 <strong>유지보수성이 나빠진다</strong>. 서비스가 바뀌더라도 컴포넌트는 바뀌지 말아야 한다! -&gt; 결합을 느슨하게 하자. 많은걸 알지않아도 되게.  </p><p>외부환경에게 의존성의 생성을 의뢰한다. 그리고 그 생성된 의존성을 주입받는것을 <strong>의존성 주입</strong>이라고 한다.<br>외부환경에서 어떻게 생성해야하는지 정보가 필요한 건 변함없다. 그러나 컴포넌트는 생성방법을 몰라도 된다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> greetingService: GreetingService</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>이때 GreetingService가 greetingService를 만드는 서비스인지는 알 수 없음. 반드시 만들어 줄 것이라는 보장이 없다. </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>서비스에 이 내용이 있어야 한다. 특히 <code>providedIn: &#39;root&#39;</code> 는, 애플리케이션 전역에서 사용할 수 있는 서비스가 된다는 뜻이다. 이걸 안 써주면 서비스가 아니며, 주입할 수 없다.  </p><p>아니면 루트모듈이나 루트컴포넌트에 아래와 같이 추가한다.<br><code>providers: [GreetingService]</code><br>그러나 만약 루트컴포넌트에 등록하면, 루트컴포넌트와 루트컴포넌트의 자식들만 서비스를 참조할 수 있다. 스코프가 제한된다.<br>따라서 모든 서비스가 전역서비스라면 서비스에서 등록한다.(만약 서비스에 등록했다면 루트모듈에 providers에 추가하지 않는다)  </p><h2 id="쉐도우-DOM-스타일-셀렉터"><a href="#쉐도우-DOM-스타일-셀렉터" class="headerlink" title="쉐도우 DOM 스타일 셀렉터"></a>쉐도우 DOM 스타일 셀렉터</h2><p>앵귤러가 제공하는 스타일 셀렉터. 웹 컴포넌트에 있는 내용이다. 이것은 앵귤러가 아니라 W3C가 관리한다. 우리가 커스텀한 컴포넌트는 아예 <code>display</code>(block/inline-block/inline 등)속성이 없다. 그러나 브라우저가 기본적인 CSS를 가지고는 있다. 그래서 브라우저마다 외양이 조금씩 다른 것이 문제가 되니까 리셋 CSS를 쓰는 것이다. 컴포넌트는 앵귤러가 제공하는 스타일 셀렉터를 이용할 필요가 있다.  </p><h2 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h2><p>‘Rx’ = 리액티브 프로그래밍<br>이것은 자바스크립트에 한정된 기능이 아니고 새로운 패러다임이다. 객체지향 / 절차지향과 유사한 느낌.<br>앵귤러는 기본적으로 리액티브 프로그래밍을 지원한다. 앵귤러에서 템플릿에 쓰는 모든 요소는 리액티브하게 코딩할 수 있으며, 그 기능을 다 제공하고 있다. </p><p>이제껏 내가 했던 모든 프로그래밍은 <em>입력 -&gt; 로직 -&gt; 출력</em> 의 반복이었는데,<br>문제는 입력의 형태가 다를 수 있다는거다. 문자, 숫자, 객체, 함수, 프로미스, 이벤트 등등.<br>입력값의 종류에 따라 코딩하는 방법이 제각각이었고 이런 방식이 혼란을 일으킨다(비동기입력의 경우 특히나).<br>입력이 동기데이터인지 비동기데이터인지 보고 코딩방식을 결정했었다.<br>그런데 RxJS는 <strong>이렇게 하지말고, 정적데이터든 동적데이터든 동기든 비동기든 전부 다 stream으로 만들자!!!</strong><br>데이터소비자는 가만히 있고, 데이터가 알아서 물길타고 흘러내려오는 것이다. 이벤트처리와 비슷하다. 우리가 가만있어도 이벤트는 주입되었었고, 우리는 할 일만 입력해줬었다.<br>입력데이터는 <strong>옵저버블</strong>이라는 하나의 타입으로 맞춰버리자.  </p><p>리액티브 프로그래밍은 <strong>푸시 시나리오</strong>를 기본으로 한다. 데이터 프로바이더가 무조건 데이터를 송출하며, 데이터 소비자가 그걸 알아서 받는다. 우리는 밀려들어오는 데이터에 <strong>‘반응’</strong>을 한다고 해서 리액티브 프로그래밍이다.  </p><p>외부 환경에서 애플리케이션 내부로 연속적으로 흐르는 데이터, 즉 데이터 스트림을 생성하고 방출하는 객체를 <strong>옵저버블</strong>  (Observable)이라 하고 -&gt; 방송국<br>옵저버블이 방출한(emit) <strong>노티피케이션</strong>(Notification: 옵저버블이 방출할 수 있는 푸시 기반 이벤트 또는 값) -&gt; 영상정보<br>… 을 획득하여 사용하는 객체를 <strong>옵저버</strong>(Observer)라 한다. -&gt; 내 티비<br>옵저버는 데이터 생산자(Data producer)인 옵저버블을 <strong>구독</strong>(subscription)한다. -&gt; 지켜보고있다, 관측하고있다<br>그러니까 옵저버블과 옵저버는 구독이라는 관계로 이루어진 것이다.  </p><p>옵저버블과 옵저버가 일대다의 관계일 수 있다. 방송국은 하나지만 티비는 여러 개인 것처럼.<br>RxJS에서 제공하는 메소드들은 다 <strong>오퍼레이터</strong>라고 부른다.  </p><h3 id="옵저버패턴"><a href="#옵저버패턴" class="headerlink" title="옵저버패턴"></a>옵저버패턴</h3><p><strong>Subject:</strong>  </p><ul><li>데이터<br><code>ObserverCollection</code>: 옵저버들의 모음  </li><li>메소드<br><code>register</code>: 옵저버 등록<br><code>unregister</code>: 옵저버 삭제<br><code>nofity</code>: 전달하려는 메세지를 옵저버에게 보내기  </li></ul><p><strong>Observer</strong>  </p><ul><li>메소드<br><code>update</code>: 상태 변화에 대응  </li></ul><p>서브젝트는 데이터가 바뀌면 자신을 구독하는 모든 옵저버들에게 새로운 데이터를 <code>notify</code> 하고, 옵저버들은 데이터가 바뀌면 최신데이터를 무조건 받는다(<code>update</code>).<br>옵저버패턴은 이해가안되면 외워야 한다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;생명주기&quot;&gt;&lt;a href=&quot;#생명주기&quot; class=&quot;headerlink&quot; title=&quot;생명주기&quot;&gt;&lt;/a&gt;생명주기&lt;/h2&gt;&lt;p&gt;태어나서 죽을 때까지의 과정. 컴포넌트가 생성되어서 Input프로퍼티에 값이 들어오거나, 변경되거나, 모든 뷰의
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>Directive</title>
    <link href="https://dearjsmc4.github.io/2019/06/24/0624/"/>
    <id>https://dearjsmc4.github.io/2019/06/24/0624/</id>
    <published>2019-06-23T15:00:00.000Z</published>
    <updated>2019-07-01T10:31:46.316Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>상태는 stateful 컴포넌트에서만 관리한다.<br>다른 컴포넌트들은 상태를 직접적으로 고치지 않고, <code>stateful</code>(or <code>smart</code>) 컴포넌트에게 ‘의뢰’ 한다. stateful 컴포넌트는, 상태를 직접 고칠 자격을 부여한 컴포넌트이다. 마치 사령관처럼! 자격이 없는 컴포넌트는 stateless 컴포넌트, 혹은 dumb 컴포넌트라고 한다. todos-container 는 다른 컴포넌트들을 호출할 뿐, 자신만의 템플릿은 없다. 즉, 다른 컴포넌트들을 관장하는 것이다. stateless 의 주 역할은, view 만 생성하는 것이다. view를 생성하기 위한 상태데이터는 container 가 보내주어야 한다. 만약 stateless 에서 상태가 변하면(인풋에 데이터가 입력되었다거나 하는) 상태 변경에 필요한 데이터를 보내줄 뿐, 직접 변경하진 않는다.  </p></li><li><p>ngModel content<br>양방향 데이터 바인딩. 템플릿에서 변경된 값을 클래스 컴포넌트에 갱신하고, 클래스 컴포넌트에서 변경된 값은 템플릿에 갱신된다. 따라서 인풋에 글자가 한 자 한자 입력될때마다 클래스 컴포넌트의 content에 갱신되고, 인풋 폼의 값은 content와 항상 같다.  </p></li><li><p>앵귤러의 css style<br>컴포넌트의 스코프 단위로 적용된다.  </p></li><li><p>변화감지 매커니즘<br>이 매커니즘을 이해하는 것은 어려운 일이니, 일단 참조를 바꾸는 것에 중점을 두자. 그래서 변화감지를 하기 쉽게 만들어주자.  </p></li></ul><h2 id="디렉티브"><a href="#디렉티브" class="headerlink" title="디렉티브"></a>디렉티브</h2><p>컴포넌트들의 <strong>공통된 기능</strong>이 있다면, 그 기능을 빼내서 디렉티브로 만든다.<br>디렉티브의 셀렉터는, 대괄호 안에 있는 텍스트가 어트리뷰트로써 사용될 것이라는 뜻이다. css의 셀렉터문법에서 어트리뷰트는 대괄호를 이용해 지정했었다.<br><code>input[type=text]</code> =&gt; input 태그이고, type 이라는 어트리뷰트 값이 text인 요소를 선택<br>디렉티브의 셀렉터를 클래스로써 사용하고 싶다면 대괄호대신 <code>.</code>을 붙여주면 된다. 그러나 가급적 어트리뷰트로 사용하기로 한다.<br>디렉티브는, 호스트요소를 서포트한다.  </p><ul><li><code>public el: ElementRef</code><br>‘앵귤러야, ElementRef 타입의 객체를 생성해서 내게 인수로 전달해줘.’ =&gt; 의존성주입<br>el이라는 참조를 디렉티브 전역에서 사용할 수 있게 된다. public 이기때문에.<br>el은 객체이며, 이 객체는 프로퍼티로 호스트요소를 가지고 있다.<br>그래서 <code>el.nativeElement.style.color = &quot;blue&quot;;</code> 으로 할 수 있지만 보안문제로 쓰지않는다.<br>-&gt; <strong>Renderer2</strong> 를 쓰자. DOM을 컨트롤할때 쓰는 API를 제공한다.<br><code>this.renderer.setStyle(this.el.nativeElement, &#39;color&#39;, &#39;blue&#39;);</code><br>-&gt; 위와 동일하게 동작한다.<br><code>@HostListener()</code> : 이벤트를 적용한다.<br><code>window.pageYOffset</code> : 스크롤이 얼마나 되었는지 잡아낸다.  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;상태는 stateful 컴포넌트에서만 관리한다.&lt;br&gt;다른 컴포넌트들은 상태를 직접적으로 고치지 않고, &lt;code&gt;stateful&lt;/code&gt;(or &lt;code&gt;smart&lt;/code&gt;) 컴포넌트에게 ‘의뢰’ 한다. stateful 
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>Generic, Angular</title>
    <link href="https://dearjsmc4.github.io/2019/06/17/0617/"/>
    <id>https://dearjsmc4.github.io/2019/06/17/0617/</id>
    <published>2019-06-16T15:00:00.000Z</published>
    <updated>2019-07-01T10:28:33.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="제네릭"><a href="#제네릭" class="headerlink" title="제네릭"></a>제네릭</h2><p>shift, unshift, pop, push 등은 원본 배열을 변형시키기 때문에 잘 쓰지 않는다.<br>pop과 push 의 대체문법은 concat, […todos, {…}] -&gt; 순서만 바꾸면 shift, unshift를 대체가능하다.<br>위의 네 가지는 쓸 필요도 없고 안 쓰는 것이 좋다.  </p><!-- <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  protected data = []; <span class="comment">// data: any[]</span></span><br><span class="line"></span><br><span class="line">  push(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(item); </span><br><span class="line">    <span class="comment">// 뭘 넣을지 모르기때문에 배열도 any타입.</span></span><br><span class="line">    <span class="comment">// 여기에서 타입을 지정해주는 순간 모든 프로퍼티가 영향받는다</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">0</span>);</span><br><span class="line">queue.push(<span class="string">'1'</span>); <span class="comment">// 의도하지 않은 실수!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed()); <span class="comment">// Runtime error</span></span><br></pre></td></tr></table></figure><p>원래 배열은 똑같은 타입의 요소만을 나열하는 것이 정석이다. 배열을 쓴다는 것은 순회하겠다는 의미이다. 순회하면서 똑같은 처리를 연속적으로 하겠다는 의미. 그런데 타입이 다르면 문제가 생긴다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// number 타입의 요소만을 push한다.</span></span><br><span class="line">  push(item: number) &#123;</span><br><span class="line">    <span class="keyword">super</span>.push(item); <span class="comment">// 부모 클래스의 push 함수를 그대로 쓰겠다.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop(): number &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그래서 숫자만 넣을 수 있는 클래스를 따로 만들었다!<br>근데 이런일 있을때마다 클래스 몽땅 새로 만들 수는 없잖아, 그래서 제네릭이 나왔다.  –&gt;</p><p><strong>제네릭</strong>은 <strong>타입 매개변수</strong>라고 한다. 타입을 외부에서 결정하게 한다. 정의할 때에 타입을 결정할 수 없다면 실행할 때에 타입을 결정할 수 있게.  </p><!-- `const numberQueue = new Queue<number>();`number 는 T로 넘어간다.  ~하나의 클래스로 여러가지 타입에 대응하는 큐를 만들 수 있게 되었다~ --><p>제네릭은 함수에도 쓸 수 있다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 어떤 타입의 배열을 매개변수로 받아서 어떤 타입의 배열을 반환하겠다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.reverse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implements 가능 -&gt; 얘가 제일 낫다</span></span><br><span class="line"><span class="keyword">interface</span> User = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 순수하게 타입만 만든다</span></span><br><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 인스턴스를 생성하지 않는 클래스는 이상하다! </span></span><br><span class="line"><span class="keyword">class</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.reverse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arg = [&#123; name: <span class="string">'Lee'</span> &#125;, &#123; name: <span class="string">'Kim'</span> &#125;, &#123; name: <span class="string">'Park'</span>, age: <span class="number">20</span> &#125;];</span><br><span class="line"><span class="comment">// 인수에 의해 타입 매개변수가 결정된다.</span></span><br><span class="line"><span class="keyword">const</span> reversed = reverse(arg);</span><br><span class="line"><span class="built_in">console</span>.log(reversed); <span class="comment">// [ &#123; name: 'Kim' &#125;, &#123; name: 'Lee' &#125; ]</span></span><br></pre></td></tr></table></figure><h2 id="Angular-template"><a href="#Angular-template" class="headerlink" title="Angular - template"></a>Angular - template</h2><h3 id="템플릿"><a href="#템플릿" class="headerlink" title="템플릿"></a>템플릿</h3><p>사실 HTML이 아니고 문자열이다. 그 안에 템플릿 문법이 포함되어 있다. 템플릿은 컴파일되어 뷰를 만든다.  </p><p><strong>데이터바인딩</strong>:<br>템플릿과 컴포넌트 클래스를 연결시키겠다는 의미. 템플릿이 컴포넌트 클래스에서 필요한 데이터를 가져와서 바인딩한다. 프로퍼티는 표현식이므로 템플릿 문법에 포함될 수 있다. 이때 자동적으로 프로퍼티 표현식은 문자열로 변환된다. 데이터가 HTML과 합쳐져서 우리가 원하는 뷰가 만들어진다. 결국 뷰는 HTML 과 CSS 로 만들어져야한다. 컴포넌트는 뷰를 만들기 위한 데이터를 제공한다.  </p><p>앵귤러는 <strong>MVW</strong> 이다. Model, View, Whatever(아무거나)(ㅋㅋㅋㅋ)<br><!-- DOM을 만들기 위해 모델을 가지고 있는데, 모델은 컴포넌트에 가지고 있을수도 있고 서비스나 디렉티브에 가지고 을수도 있다. --><br>템플릿과 연동하여 뷰(DOM)을 만든다. 템플릿이 일방적으로 데이터를 끌어간다. 왜냐면 컴포넌트 클래스는 템플릿을 모르기 때문이다.<br>그러나 이벤트 발생 시에는 다른데, 브라우저에서 이벤트가 발생하면 이벤트 핸들러를 통해 컴포넌트 클래스로 연결된다. 이벤트는 상태변화를 나타낸다. 상태변화는 DOM에서 발생하고, 모델은 할 일을 수행한다. 뷰를 다시 만들 때에는, 바뀐 부분만 다시 만들어야 한다.  </p><h2 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h2><p>자바스크립트가 HTML에 의존하지 않는 방식이 필요하다!<br>데이터바인딩의 핵심은, 템플릿이 주도권을 갖는다는 것.<br>템플릿은 컴포넌트 클래스의 클래스 필드를 참조하며 필요한 데이터를 가져온다.<br>컴포넌트 클래스는 자기 일만 묵묵히 하면 된다.  </p><ul><li>왜 이벤트바인딩은 템플릿 -&gt; 컴포넌트클래스 방향인가?<br>DOM 이벤트는 view에서 발생하기 때문.  <!-- 뷰의 돔이벤트가 발생하면 데이터가 바뀌었겠거니 하고 생각한다.  timer함수나 ajax통신도 마찬가지. 데이터가 바뀔 가능성이 높다.   --></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;제네릭&quot;&gt;&lt;a href=&quot;#제네릭&quot; class=&quot;headerlink&quot; title=&quot;제네릭&quot;&gt;&lt;/a&gt;제네릭&lt;/h2&gt;&lt;p&gt;shift, unshift, pop, push 등은 원본 배열을 변형시키기 때문에 잘 쓰지 않는다.&lt;br&gt;pop과 pu
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Typescript" scheme="https://dearjsmc4.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Angular</title>
    <link href="https://dearjsmc4.github.io/2019/06/14/0614/"/>
    <id>https://dearjsmc4.github.io/2019/06/14/0614/</id>
    <published>2019-06-13T15:00:00.000Z</published>
    <updated>2019-07-01T10:38:21.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Augular"><a href="#Augular" class="headerlink" title="Augular"></a>Augular</h2><h3 id="프레임워크-라이브러리"><a href="#프레임워크-라이브러리" class="headerlink" title="프레임워크 / 라이브러리"></a>프레임워크 / 라이브러리</h3><p>라이브러리는 본래 빌트인 함수가 아닌, 업무에 필요한 함수를 만들어서 파일로 만들어 둔 것이었으나 현대에는 특정 기능을 서폿해주는 것으로 받아들여진다. 프레임워크과 라이브러리의 기본적인 차이는 구조다.<br>프레임워크는 강제성이 크고 규모가 큰 개발에 적합하며, 라이브러리는 자유도가 높아 규모가 작은 개발에 적합하다. 그리고 특정 기능에만 관심이 있기 때문에 크기도 작다.<br>사실 강제성이 높을수록 쓰기 편하다. 자바스크립트의 관대한 문법이 언제 편한 적 있었던가.<br>이런 관점에서 보면 앵귤러는 프레임워크고 리액트는 라이브러리다.<br>앵귤러는 프레임워크고, 강제성이 높고, 크기가 크다.  </p><h3 id="왜-앵귤러를-쓰나"><a href="#왜-앵귤러를-쓰나" class="headerlink" title="왜 앵귤러를 쓰나?"></a>왜 앵귤러를 쓰나?</h3><p>원래 HTML/CSS는 정적이다. 이제까지는 JS가 주도권을 가지고 HTML/CSS 를 마음대로 가져오고, 추가하고, 삭제했다. HTML/CSS 를 파악한 후에 JS에서 일할 수 있었다는 것은 JS가 HTML/CSS에 의존하고 있었다는 뜻이다. 의존하고 있으면 영향을 받게 되어있다. HTML/CSS 구조가 틀어지는 순간 JS가 심각하게 흔들린다.   </p><p>따라서 HTML/CSS 와 JS 간의 의존을 끊는 새로운 개발방법론이 나타났다. 그래야 서로 영향을 주지않으니까. 하지만 관계는 끊으면 안 되므로, 영향을 덜 받는 방식으로 의존도를 갖도록 하였다. 즉, 반대로 HTML/CSS 가 JS를 의존하게 하자는 것이다.  </p><p>어떻게?<br>문자열상태로 넣는 것이다(템플릿). 이건 결국 HTML/CSS가 아니라 그냥 자바스크립트라고 보면 된다. index.html 만 유일한 HTML이다. 옛날엔 화면을 그려줄 함수를 코드 내에서 직접 불렀고, 우리가 신경 써야할 요소들이 많았다(이벤트를 달아준다든지, 타이밍에 맞게 렌더함수를 그려준다든지). 그런 전형적인 일들은 이제 프레임워크가 해줄 것이고, 우리는 로직개발에 집중하면 된다. 이제 HTML/CSS 가 JS의 상태데이터를 보고 있다. <code></code>은 데이터바인딩이라고 하는데, HTML/CSS 가 바라볼 상태데이터와 연결해준다. </p><p>컴포넌트는 크게 3가지 구조로 나뉘어져있다. </p><ol><li>import - 필요한 컴포넌트와 api를 import</li><li>template  - html, CSS</li><li>component - class</li></ol><h3 id="앵귤러"><a href="#앵귤러" class="headerlink" title="앵귤러"></a>앵귤러</h3><p>내용이 방대하기 때문에 한번에 다 배울 수 없고, 당장 필요한 기능을 찾아서 쓰면서 배운다.  </p><ul><li><p>높은 개발생산성: 내가 공부한 것보다 더 많은 효율과 결과를 낼 수 있다.  </p></li><li><p>컴포넌트: 레고 조각과 같다. 화면을 그리는데 필요한 부품과 같으며, 분리하고 조립하여 사용한다.   </p></li><li><p>웹에서 왜 컴포넌트 기반 개발이 어려운가 -&gt; CSS 때문에<br>컴포넌트는 HTML/CSS/JS 가 한몸으로 view를 그려야하는데, 컴포넌트가 조립되었을 때 CSS가 서로 영향을 주면 곤란하다. 어떻게 CSS 를 컴포넌트화하느냐의 문제.  </p></li><li><p>타입스크립트: 반드시 타입스크립트를 써야하는건 아니지만, 일반적으로는 타입스크립트를 쓴다.  </p></li><li><p>게으른 로딩: 현재 사용하는데에 무리가 없는 부분만큼의 리소스만 받자.<br>-&gt; SPA의 단점인 초기로딩속도를 생각해보면, 그보다 훨씬 빠를 것이다.  </p></li><li><p>코드최적화: <code>build</code> - 서버에 올릴 최종 산출물을 만들라는 명령. 이 최종 결과의 용량은 작아야 한다. 따라서 빌드하면 만들어질 코드의 용량을 줄이는데에 노력을 많이 하고 있다.  </p></li></ul><h3 id="실습하며-배운-내용"><a href="#실습하며-배운-내용" class="headerlink" title="실습하며 배운 내용"></a>실습하며 배운 내용</h3><ul><li>루트 컴포넌트: 기본 컴포넌트중에 app.module.ts 를 제외한 app 폴더의 모든 것  </li><li><p>루트 모듈: 컴포넌트를 관리한다. 모듈을 만질 줄 알아야 한다.  </p><ul><li>선언부: 컴포넌트 등록 -&gt; 새로 만들어진 컴포넌트는 이 곳에 넣어줘야한다. </li><li>임포트: 모듈을 넣어주는 곳</li><li>프로바이더스: 서비스<!-- 컴포넌트 html은 순수한 html이다. html과 CSS 컴포넌트를 분리할 수 있으면 다른 사람에게 따로 줄수도 있고... 좋다.  --></li></ul></li><li><p><code>ng serve</code> : 아직 개발 중. 개발용 서버.  </p></li><li><code>ng build</code> : 개발 다했다! 최적화!  <!-- .map : 서버에 올릴 때 map은 다 지우고 올라간다. JS파일과 ts파일을 묶어주는데에 필요한게 map 파일. 디버깅용이니까 배포할땐 필요없다.  --></li></ul><!-- 컴포넌트는 태그로 불려졌을때 태어난다. -> 태어나면 view를 그림커스텀 태그를 만든것과 같다! --><ul><li><code>-t</code> : 인라인 템플릿  </li><li><code>-s</code> : 인라인 스타일  </li><li><code>-S</code> : 스킵 테스트 (spec.ts을 안 만든다)(컴포넌트에서는 축약형이 먹히지 않는다)  </li><li><code>--flat</code> : 폴더를 만들지 않는 컴포넌트  </li></ul><!-- app-home은 app-root의 자식.html은 중첩관계에 의해 부자관계를 맺으니까. root컴포넌트는 필수적이다. 조상중의 조상이다. 아무거나 갖다두면 안된다.  --><!-- path: url의 path. 도메인 이후 슬래시 다음부터 오는 것. 여기에 내가 활성화시킬 컴포넌트를 적어줌.  --><!-- 컴포넌트는 ui를 만드는것이 주목적. --><ul><li><p>서비스: 서버에서 데이터를 가져오거나, 상태가 바뀌면 서버에 데이터를 보내거나, 로딩하거나 하는, 프로젝트 전체적으로 쓰여야하는 필요한 기능들. 화면을 그리는데에 직접적인 연관은 없는 기능을 컴포넌트로부터 분리.  </p></li><li><p><code>main.ts</code> : 앵귤러가 가동되면 가장 먼저 시작 될 파일.  </p><!-- 루트모듈에 부트스트랩에 루트컴포넌트를 적어준다고 했는데, 그 루트컴포넌트를 띄운다.  --></li></ul><!-- 컴포넌트는 하늘에서 뚝 떨진게 아니라 웹컴포넌트라는 기반이 있었다.컴포넌트를 만드는건 태그를 만드는 것과 같다. shadowDom: 나중에 컴포넌트가 합쳐졌을때 다른 컴포넌트의 간섭을 받으면 안된다. 컴포넌트의 연결은, 데이터를 주고받을 수 있어야 한다는 뜻.어 --><ul><li>데코레이터: 메타데이터 객체라고 한다. 함수이므로 사용할 때 호출이 필요하다.   </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Augular&quot;&gt;&lt;a href=&quot;#Augular&quot; class=&quot;headerlink&quot; title=&quot;Augular&quot;&gt;&lt;/a&gt;Augular&lt;/h2&gt;&lt;h3 id=&quot;프레임워크-라이브러리&quot;&gt;&lt;a href=&quot;#프레임워크-라이브러리&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>SPA, Routing</title>
    <link href="https://dearjsmc4.github.io/2019/06/11/0611/"/>
    <id>https://dearjsmc4.github.io/2019/06/11/0611/</id>
    <published>2019-06-10T15:00:00.000Z</published>
    <updated>2019-06-12T10:15:40.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPA-Single-Page-Application"><a href="#SPA-Single-Page-Application" class="headerlink" title="SPA(Single Page Application)"></a>SPA(Single Page Application)</h2><p>앵귤러, 뷰, 리액트 등을 배우려면 SPA부터 잘 알아야 한다.  </p><p>SPA는 페이지가 여러 개일지라도 <strong>HTML파일은 단 하나</strong>다. 자바스크립트는 하나일수도, 여러개일수도(웹팩으로 쪼갤 수 있다). 게다가 HTML파일에는 빈 태그가 있고, 그것을 루트태그라고 하는데 JS가 돌면서 루트태그 안에 view를 집어넣는다.<br><!-- Ajax를 쓸 때 생기는 여러 제약사항을 커버하기 위한 모던 웹 패러다임이다.??   --><br>HTML을 처음 부르면 리소스를 가져올텐데, 첫 페이지를 로딩하는 순간 모든 리소스를 한번에 다운로드하는 것이 기본이다. 그래서 <strong>첫 페이지 로딩이 느리다</strong>는 단점이 있다. 하지만 뒷 페이지부터는 화면을 갈아끼기만 하면 되므로 퍼포먼스가 좋다. SPA를 사용하는 가장 큰 이유는, <strong>사용자 경험</strong>이 일반 네이티브 앱과 비교할 때 손색이 없기 때문이다. <strong>부드러운 화면전환</strong>이 가능하다. 화면전환이라는 건 HTML을 완전히 새로 그린다는건데 쓸데없는 통신, 쓸데없는 렌더링이 발생한다. 화면이 깜빡하면 네이티브 앱처럼 동작하는 게 아니다.(엑셀이 화면깜빡거리지 않잖아) AJAX에서의 화면전환은 전부 다 그리는 게 아니라 필요한 부분만 그린다.<br><!-- 웹은 원래 문서 공유/문서 간 이동을 위해 만들어졌다. --></p><p>a태그는 기본적으로 화면전환을 일으키는데, 이때 <code>e.preventDefault</code>를 써서 화면전환을 막고 Ajax 요청을 한다.<br>Ajax방식으로 하면 URL이 하나이기때문에 검색로봇이 검색할 수 없다 -&gt; 구글에서 아무리 찾아도 첫 페이지밖에 안 나온다.<br>이것이 <strong>SEO 이슈</strong>이다. 일반 웹 페이지에서 SEO이슈가 터지는 건 치명적이다. 검색이 안 되면 곤란하다. 근데 내부에서만 쓰는 웹 애플리케이션은 반대로 검색이 되면 곤란하다.<br>그리고 주소창이 안 바뀌면 SEO이슈뿐만 아니라 앞으로가기/뒤로가기가 안 되는 문제가 생긴다. 그래서 히스토리를 관리할 수 있는 HTML5 메소드가 나왔는데, HTML5니까 되는 브라우저도 있고 안 되는 브라우저도 있다.<br>웹 앱도 검색이 됐으면 좋겠다면 서버사이드 렌더링을 해야한다.<br>모든 것을 만족시키는 혁신적인 방법, 은탄환은 지금까지도 앞으로도 없다.  </p><!-- 우선 결론적으로, 우리가 바닐라스크립트로 라우팅을 구현하기는 바람직하지 않고 매우 힘들다. 앵귤러 뷰 리액트 같은 것들로 하는 게 현명하다. 우리가 이보다 잘 만들 수는 없어... --><ul><li>웹 애플리케이션 vs 웹 페이지<br>일반적인 정보를 제공하는 단순한 페이지 = 웹 페이지<br>내가 페이지에서 어떤 일을 한다 = 웹 어플리케이션  </li></ul><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>출발지와 목적지까지의 경로가 여러 개 있을 때, 경로를 결정하는 방식.<br>웹에서는 라우팅을 화면이동으로 이해한다.  </p><ol><li>주소창에 URL을 입력하거나  </li><li>a태그를 클릭하거나  </li><li>뒤로가기/앞으로가기를 클릭할 때  </li></ol><h2 id="SPA와-Routing"><a href="#SPA와-Routing" class="headerlink" title="SPA와 Routing"></a>SPA와 Routing</h2><ul><li><p>전통적 링크방식<br>주소창을 바꾼다. 바뀐 주소를 서버에 요청하고, 그 요청에 대한 응답이 오면 화면을 새롭게 그린다.<br>검색엔진에 의해 검색당하려면 페이지들이 고유의 URL을 가지고 있어야 한다.<br>SEO이슈 없고 히스토리 관리 문제없고 구현도 쉽지만, 불필요한 퍼포먼스가 너무 많다.  </p></li><li><p>Ajax 방식<br>href 속성이 필요없다. 주소창이 바뀌지 않는다(동작을 막았으니까).<br>화면깜빡임이나 불필요한 리소스 요청, 렌더링이 없지만 자바스크립트 코딩을 해야 한다.<br>히스토리 관리가 안 되고, SEO이슈 발생. 게다가 리로딩하면 초기의 index 페이지로 돌아간다.<br>리로딩은 URL을 다시 보내는 것이기 때문이다.  </p></li><li><p>hash 방식<br>요청은 새로 보내지 않으면서 주소는 다르게 관리하는 방법.<br>기존 URL에서 해쉬가 바뀌어도 요청이 새로 발생하지 않는 것을 이용한 방법.<br>히스토리관리가 되지만, 주소창에 해쉬(#)가 들어가야하기때문에 보기에 좋지 않다.<br><code>#!</code>을 사용하기도 하는데 이를 해시뱅(Hash-bang)이라고 부른다.<br>load 이벤트 : 모든 리소스가 다 준비됐을 때<br>contentloaded 이벤트 : 돔이 완성됐을 때 -&gt; 로드 이벤트보다 먼저 발생  </p></li><li><p>Pjax 방식<br>hash 방식의 가장 큰 단점은 SEO 이슈이다. 이를 보완한 방법이 HTML5의 Histroy API인 pushState와 popstate 이벤트를 사용한 PJAX 방식이다. 리로드하면 서버에 REST API처럼 다시 요청이 간다. 서버에서 대응해줘야 할 필요가 있다. 백엔드의 협력이 필요하다.  </p></li></ul><!-- 수퍼extend관계일때 super를 불러줘야한다. 부모가 this를 만들어서 자식에게 주면 그것을 자식이 이어서쓴다부모가 빈 객체를 this에 바인딩하고 name을 세팅한 뒤 this를 리턴하면 super가 this를 리턴하는데 그것이 자식의 this로 들어간다this는 name을 가지고있는 인스턴스이고, 거기에다가 grade를 추가.이때 human과 student가 프로토타입체인이 구성되어서 메소드도 상속받는다Student 는 클래스지만 클래스도 함수니까 프로토타입도 생김.```javascriptclass Human {  constructor(name) {    this.name = name;  }  speak() {    console.log('집에가고싶다');  }}class Student extends Human {  constructor(name, grade) {    super(name);    this.grade = grade;  }}``` -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SPA-Single-Page-Application&quot;&gt;&lt;a href=&quot;#SPA-Single-Page-Application&quot; class=&quot;headerlink&quot; title=&quot;SPA(Single Page Application)&quot;&gt;&lt;/a&gt;SPA(
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>클로저</title>
    <link href="https://dearjsmc4.github.io/2019/06/07/0607/"/>
    <id>https://dearjsmc4.github.io/2019/06/07/0607/</id>
    <published>2019-06-06T15:00:00.000Z</published>
    <updated>2019-06-17T12:00:21.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="시작-전-예제"><a href="#시작-전-예제" class="headerlink" title="시작 전 예제"></a>시작 전 예제</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>-&gt; 스코프체인과 프로토타입체인은 따로따로 일하는게 아니라 식별자를 찾을 때 협력하는 관계이다.</p><h2 id="예제-2"><a href="#예제-2" class="headerlink" title="예제 2"></a>예제 2</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] += x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>foo 함수에 대한 평가가 이루어져서 arr 이 함수의 환경레코드에 등록된다.<br>for문 안의 변수가 var로 초기화 되는 것이었다면 함수의 환경레코드에 들어가겠지만(블록레벨스코프를 지원하지않으니까) let은 for문 안에서만 유효하기때문에 스코프도 for문으로 제한된다. 함수내부를 평가할 때 for문은 일단 지나쳐버리고, 함수내부를 실행할 때 arr에 배열을 할당해준다. (객체가 되어 할당된다)<br>현재 실행중인 실행컨텍스트는 foo 이다. for문을 만나면 for문에 대한 새로운 렉시컬환경을 만든다. 실행컨텍스트를 새로 만드는 게 아니다! 실행컨텍스트를 만드는 건 실행 가능한 코드의 4가지 종류(전역, 함수, eval, 모듈)만 만드는거다.<br>for문은 실행컨텍스트를 만들지 않고 for의 렉시컬환경만 만든다. 그리고 기존의 렉시컬환경(foo)을 새로운 렉시컬환경(for)으로 갈아끼우면서(함수 실행 컨텍스트가 기존에 foo의 렉시컬환경과의 관계를 끊고 블록 렉시컬 환경을 가리키게된다) 부자관계를 맺고(for의 외부환경참조가 foo의 렉시컬환경을 가리킨다) for문을 실행한 후, foo 함수의 렉시컬환경으로 되돌린다. -&gt; tc39 ecma 262 - 13.2.13 참고  </p><h2 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h2><p>클로저를 배워야하는 이유 : 정보은닉보다는 <strong>안전한 상태유지</strong>가 주 목적이다.<br>근데 왜 상태유지를 클로저로 해야할까?<br>-&gt; 전역변수로 상태유지를 할 수도 있지만 그건 안전하지가 않다. 왜냐면 아무나 고칠 수 있기 때문이다.<br><!-- 안전하다고 하려면 상태를 변경할 수 있는 자격이 필요하다.    --><br>안전하게, 라는 말을 빼고 상태유지를 하는 방법은 객체의 프로퍼티가 있음.<br>그러나 프로퍼티 역시 접근해서 상태를 바꿀 수도 있다. 객체의 모든 프로퍼티는 퍼블릭하다.<br>안전한 상태유지를 하고싶다면 클로저를 써야 한다.  </p><!-- 실행컨텍스트의 관점에서 이해하고 설명할 수 있어야한다.요즘은 내부함수가 아니라 중첩함수(nested function) 이라고 하는 추세이다. --><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  innerFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outerFunc(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>전역코드가 평가되어 x와 outerfunc이 등록된다.<br>outerfunc가 실행되면 실행컨텍스트에 함수 실행컨텍스트 스택이 쌓이고 렉시컬환경과 환경레코드가 생기고 x와 innerfunc가 등록된다. 함수 내부가 실행되면 x에 10이 할당되고, innerfunc가 호출된다. inner함수의 실행컨텍스트가 스택에 쌓이고, inner가 현재 실행중인 실행컨텍스트가 된다. x를 바라볼때, 현재 실행중인 실행컨텍스트의 렉시컬환경의 환경레코드에서 찾는다. inner에 없으니 외부환경참조를 타고 outer로 가서(이것이 스코프체인), outer의 렉시컬환경의 환경레코드에서 찾아서 출력한다. </p><h3 id="외부환경참조"><a href="#외부환경참조" class="headerlink" title="외부환경참조"></a>외부환경참조</h3><p>함수가 호출되기전에 평가되고 함수객체가 만들어진다. 평가될 때, 실행 중인 전역실행컨텍스트의 <strong>렉시컬환경</strong>(상위스코프)을 <code>[[environment]]</code> 내부슬롯에 넣는다. -&gt; 자신이 정의된 위치에 의거해서 이미 결정되어진다. 모든 함수객체는 <code>[[environment]]</code>를 가지고 있다. 렉시컬환경도 객체니까 그 참조값을 가지고 있다. 함수 객체가 소멸되지 않는한 상위스코프 참조는 사라지지않는다. 그러니까 상위스코프도 절대 죽지않는다. 왜냐면 살아있는 중첩함수에 의해 상위스코프 참조가 끊어지지 않았기 때문에, 가비지컬렉터가 없애지않는다. 상위함수는 죽어도 그 상위함수의 렉시컬환경은 살아있다.  </p><ul><li>함수 평가 -&gt; 함수객체만들어짐 -&gt; 실행중인 실행컨텍스트의 렉시컬환경을 상위스코프로 결정</li><li>함수 실행 -&gt; 실행컨텍스트가 스택에 쌓이고, 렉시컬환경과 환경레코드의 내용이 실행하면서 채워진다.</li></ul><h3 id="모든-함수는-클로저"><a href="#모든-함수는-클로저" class="headerlink" title="모든 함수는 클로저?"></a>모든 함수는 클로저?</h3><p>모든 함수는 자신이 정의된 위치에 의해 자신의 상위스코프를 <code>[[environment]]</code>내부슬롯에 저장한다.<br>모든 함수는 상위스코프를 다 기억한다.<br>모든 함수는 이론적으로 다 클로저다.<br>클로저의 정의는, <strong>상위스코프를 만든 함수가 없어져도 상위스코프를 참조할 수 있다</strong>면 다 클로저라고 한다.<br>전역실행컨텍스트는 소멸하지않으니까 의미가 없지만, 만약 전역실행컨텍스트도 소멸한다고하면 전역함수도 자신의 상위스코프를 들고다니기때문에 다 클로저이다. 전역함수의 상위스코프는 전역렉시컬환경이다.<br>그러나,<br>만약 상위스코프의 식별자를 참조할일이 없다면 최신브라우저는 굳이 상위스코프를 기억하지않는다. 의미가 없기 때문이다.<br>클로저라고 부르지도 않는다.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 일반적으로 클로저라고 하지 않는다.</span></span><br><span class="line">  <span class="comment">// bar 함수는 클로저였지만 곧바로 소멸한다.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 상위 스코프의 식별자를 참조한다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>위와 같은 경우는 foo 가 죽었을때 bar도 같이 죽기때문에, 클로저였지만 클로저라고 하지않는다.<br>실질적인 클로저의 조건은 즉,  </p><ol><li>상위스코프의 식별자를 하나라도 참조해야하며  </li><li>상위스코프보다 생명주기가 길어야한다.  </li></ol><h2 id="클로저의-활용"><a href="#클로저의-활용" class="headerlink" title="클로저의 활용"></a>클로저의 활용</h2><p>최신 상태를 안전하게 유지하는 것이 본질적 목표이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $counter = <span class="built_in">document</span>.querySelector(<span class="string">'.counter'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increase = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 카운트 상태를 유지하기 위한 자유 변수</span></span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $counter.textContent = ++num; <span class="comment">// 상태 변경</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.increase'</span>).onclick = increase;</span><br></pre></td></tr></table></figure></p><p>이때 increase함수는 caller가 없다.<br>브라우저가 온클릭이벤트 발생시에 호출해준다. 클릭이벤트가 발생하면 이벤트큐에 함수객체가 들어갔다가, 스택이 비면 실행된다.<br>한번 클릭해서 더하기를 했다가 소멸되고, 클릭하면 다시 실행컨텍스트가 생기고 또 실행하고 소멸되고. 생기고 소멸되고의 반복. 상위스코프는 한번 생긴 후로 사라진적이 없으므로 num은 유지된다. 왜냐면, increase라는 변수에 함수를 담아놓았기 때문에.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// num: 0, // 프로퍼티는 public이므로 정보 은닉이 되지 않는다.</span></span><br><span class="line">        increase() &#123;</span><br><span class="line">          $counter.textContent = ++num; <span class="comment">// 상태 변경</span></span><br><span class="line">        &#125;,</span><br><span class="line">        decrease() &#123;</span><br><span class="line">          <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">          $counter.textContent = --num; <span class="comment">// 상태 변경</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><p>리턴은 한번만 할수있기에 자료구조에 다 담아서 한번에 리턴할 수 있다. 이때 리턴되는 자료구조, 즉 객체는 리턴되기 직전에 객체가 된다. 그 안에 리턴될 메소드들은 객체로 만들어질때 같이 만들어진다. 리턴되는 객체는 스코프를 만들지않는다! 스코프가 객체 내에서 만들어지지는 않는다. 메소드들이 자신의 상위스코프를 기억한다. 리턴되는 함수들의 상위스코프는 객체가아니라 <strong>리턴하는 함수의 렉시컬환경</strong>이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $counter = <span class="built_in">document</span>.querySelector(<span class="string">'.counter'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ① 카운트 상태를 유지하기 위한 자유 변수</span></span><br><span class="line">      <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this.num = 0; // ② 프로퍼티는 public이므로 정보 은닉이 되지 않는다.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Counter.prototype.increase = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $counter.textContent = ++num;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      Counter.prototype.decrease = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        $counter.textContent = --num;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Counter;</span><br><span class="line">    &#125;());</span><br></pre></td></tr></table></figure><p>counter를 찾고, prototype은 프로토타입체인에서 찾아서 increase를 추가하는데. 이 increase 함수의 상위스코프도 현재 실행중인 실행컨텍스트, 즉 즉시실행함수의 렉시컬환경이다.  </p><!-- ## 함수형 프로그래밍변수 사용 지양을 통한 상태변화의 최소화.객체는 참조가 공유되기때문에 변경에 영향을 받고 추적이 어렵다-> 객체를 얼려서 이뮤터블하게 쓴다 -> 딥카피해서 넘기고 얼린다 다른애들이 변경못하게이런 것을 추구하는게 함수형 프로그래밍함수는 지역변수가 아닌 외부상태를 절대 변경하지말아야한다 -> 순수함수 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;시작-전-예제&quot;&gt;&lt;a href=&quot;#시작-전-예제&quot; class=&quot;headerlink&quot; title=&quot;시작 전 예제&quot;&gt;&lt;/a&gt;시작 전 예제&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>실행컨텍스트</title>
    <link href="https://dearjsmc4.github.io/2019/06/05/0605/"/>
    <id>https://dearjsmc4.github.io/2019/06/05/0605/</id>
    <published>2019-06-04T15:00:00.000Z</published>
    <updated>2019-06-12T10:09:31.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="실행-컨텍스트"><a href="#실행-컨텍스트" class="headerlink" title="실행 컨텍스트"></a>실행 컨텍스트</h2><p>컨텍스트는 문맥이라는 뜻. 코드에도 맥락이 있다.<br><!-- 식별자하면 선언이라는 키워드를 떠올려야함.(단, 프로퍼티는 식별자라고 잘 불리지않음. 식별자는 스코프체인에서 찾지만,프로퍼티는 프로토타입체인에서 찾기때문) --><br>실행 컨텍스트는 <strong>자바스크립트엔진의 동작원리</strong>와 밀접한 관련이 있다.<br>모든 실행 가능한 코드는 우선 평가 과정을 거치면서 실행을 위한 준비를 해야한다. 실행 컨텍스트는 실행 가능한 코드를 평가하고 실행하기 위한 환경이다. 이 실행 컨텍스트는 코드 평가 과정에서 생성되고, 코드 내 선언문이 평가되어 그 결과가 실행컨텍스트에 등록된다.<br>실행 가능한 코드는 4가지 유형이 있다.  </p><ol><li>전역코드 - 전역에 존재하는 텍스트 코드.  </li><li>함수코드 - 함수 내부에 존재하는 텍스트 코드.  </li><li>eval 코드 - eval 함수에 인수로 전달된 텍스트 코드.  </li><li>모듈코드 - 모듈 내부에 존재하는 텍스트 코드.  <!-- 우리는 전역코드와 함수코드에 집중하자. 코드별로 컨텍스트가 따로다.   --></li></ol><h3 id="전역코드"><a href="#전역코드" class="headerlink" title="전역코드"></a>전역코드</h3><p><strong>전역스코프</strong>를 생성하고 전역객체와 연결되어야 한다.<br>(전역객체는 브라우저를 열자마자 생성되며, 프로퍼티와 메소드, WEB API, 변수들이 들어있다.)<br>var 키워드로 선언된 변수는 전역객체와 전역스코프에 들어가지만 let, const 는 전역스코프에만 들어간다<br>-&gt; 그래서 윈도우에서 참조못한다.<br>-&gt; declarative environment record 에 들어가있다.<br><!-- (전역 스코프와 전역 객체가 어떻게 다르더라...) --><br>전역코드평가를 통해 <strong>전역실행컨텍스트</strong>가 생성된다.  </p><h3 id="함수코드"><a href="#함수코드" class="headerlink" title="함수코드"></a>함수코드</h3><p><strong>지역스코프</strong>를 만든다. 지역스코프는 전역스코프를 가장 최상위로 하는 스코프체인의 일원으로 등록되어야 한다.<br>함수 코드가 평가되면 <strong>함수실행컨텍스트</strong>가 생성된다.</p><p>두 코드는실행컨텍스트의 내용, 즉 하는 일이 다르다. </p><ul><li><p>평가와 실행은 다르다<br>어떤 코드가 실행되기 위해서는 평가단계를 거친다. 평가의 아웃풋이 실행컨텍스트이다. 평가를 하면 실행컨텍스트가 만들어진다. 선언문들만 뽑아서 먼저 실행하는걸 코드평가라고 한다 -&gt; 변수선언때 배웠다!<br>실행컨텍스트를 만들어서 선언문을 실행한 결과로 만들어진 식별자를 등록한다.<br>그리고 런타임이 시작돼서 선언문을 제외한 코드가 실행 된다. -&gt; 값이 할당되고 연산도 가능해진다  </p></li><li><p>변수의 선언과 할당을 실행 컨텍스트로 이해하기<br>전역 코드가 평가될 때 전역 실행컨텍스트가 생성되고 x라는 식별자를 등록한다. 전역실행컨텍스트를 객체라고 생각하자. 실제로 객체이기도 하고. 그 안에 프로퍼티와 값이 있다. 식별자 x만을 등록할 순 없고 값을 줘야하는데, 할당 전에 먼저 undefined를 값으로 넣어둔다. 그게 호이스팅이었다!<br>할당은 식별자와 값을 바인딩하는 것이다. 그럼 먼저 식별자를 찾아야 하는데, 전역실행컨텍스트에서 식별자를 찾는다. 만약 없다면 레퍼런스에러가 난다. 식별자를 찾은 후엔 값을 할당한다. 할당이라는 코드실행결과 역시 실행컨텍스트에서 관리된다. 사실 이보단 더 복잡하지만.. 일단 개요를 말하자면 그렇다.<br>변수를 선언한다는 건, 변수명을 실행컨텍스트에 등록하여 자바스크립트엔진이 관리하도록 하는 것이다.<br>-&gt; (실행컨텍스트야 너가 이 식별자 좀 가지고 있어 관리좀 하게) </p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 변수 선언</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 지역 변수 선언</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 메소드 호출</span></span><br><span class="line">  <span class="built_in">console</span>.log(a + x + y); <span class="comment">// 130</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line">foo(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(x + y); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>전역객체가 일단 존재하고, 전역코드가 평가되면 전역실행컨텍스트가 생성된다. 전역의 const 변수 x, y 선언문을 평가하여 실행컨텍스트에 등록한다. foo 함수 선언문을 평가하여 foo 함수 객체를 등록한다(이때 내부 코드는 아직 평가되지 않았다!).<br>코드가 실행되면 전역 const x, y에 1, 2를 할당하고 foo 함수를 건너뛰어 foo 함수 호출문으로 간다. 함수가 호출되어 함수 내부로 들어간다. 이제 함수코드가 평가되고 함수실행컨텍스트가 만들어진다. x, y, a를 등록한다. <strong>(arguments 객체도 있다!)</strong> 함수코드가 실행이 되면 10, 20, 100 을 할당하고 콘솔로그를 찍으러 간다. 콘솔은 전역객체에서 찾을 수 있다. 함수 실행컨텍스트에서 모든 식별자를 참조할 수 있으므로 130이라는 결과가 출력된다. foo 함수 실행이 끝나면 전역코드로 나와 콘솔을 실행한다. 이때는 전역실행컨텍스트에서 x, y 를 찾아 3이 출력된다.  </p><h2 id="실행컨텍스트-스택"><a href="#실행컨텍스트-스택" class="headerlink" title="실행컨텍스트 스택"></a>실행컨텍스트 스택</h2><p>전역 코드를 실행할 때 함수 호출을 만나면 전역 코드 실행을 멈추고 함수 코드를 실행한다. 함수 코드를 실행하고 나면 다시 전역 코드로 돌아와야 하는데, 어떻게 돌아올까? 멈춘 곳에서부터 다시 코드를 실행하는 매커니즘이 실행 컨텍스트 스택이다.<br><!-- (이거 콜스택이야!) --><br>평가 전에 이미 전역객체는 실행 컨텍스트 스택에 만들어져 있다. 그래야 평가했을때 var 변수를 전역객체의 프로퍼티로 넣을 수 있으니까. 그리고 항상 스택의 맨 밑에 깔려있다. 전역실행컨텍스트은 종료될 수 없고, 브라우저를 끄지않는 한 살아있다. 스택의 맨 위에 있는 실행컨텍스트는 현재 실행중인 실행컨텍스트이다. 이렇게 스택에 쌓이는 매커니즘으로 자기가 어디로 돌아가야 할지를 알게된다. 현재 실행중인 실행컨텍스트, 즉 최상위의 실행컨텍스트가 실행을 마치고 사라지면 그 다음 실행컨텍스트로 컨트롤이 이동하는것이다.  </p><h2 id="렉시컬-환경-중요"><a href="#렉시컬-환경-중요" class="headerlink" title="렉시컬 환경(중요)"></a>렉시컬 환경(중요)</h2><p>이것이 바로 스코프. 실행 컨텍스트가 하나의 심플한 객체로 만들어진 게 아니라 복잡한 구조로 만들어져있다. 식별자가 선언되는 환경. 좀 더 정확히 얘기하면 환경레코드가 스코프이다. 렉시컬환경은 실행컨텍스트 소속이다.  </p><p>실행 컨텍스트는 <strong>LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트</strong>로 구성된다. 실행컨텍스트가 이 두 개의 프로퍼티를 가지고 있다. 처음엔 동일한 렉시컬환경객체를 가리킨 상태에서 시작함. 렉시컬환경은 3개의 프로퍼티를 가진다.  </p><ol><li>환경레코드: 식별자와 값을 관리한다  </li><li>외부렉시컬환경에대한참조: 상위스코프에 대한 참조 -&gt; 클로저와 연결  </li><li>this바인딩: 메소드를 이용한 this 결정  </li></ol><pre><code class="javascript"><span class="keyword">var</span> x = <span class="number">1</span>;<span class="keyword">const</span> y = <span class="number">2</span>;<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>{  <span class="keyword">var</span> x = <span class="number">3</span>;  <span class="keyword">const</span> y = <span class="number">4</span>;  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">b</span>) </span>{    <span class="keyword">const</span> z = <span class="number">5</span>;    <span class="built_in">console</span>.log(a + b + x + y + z);}  bar(<span class="number">10</span>);}foo(<span class="number">20</span>); <span class="comment">// 42</span></code></pre><p>함수는 자기가 정의된 곳에서 평가 된다. 어디에서 정의되었는지에 따라 상위스코프가 결정된다.<br>함수가 상위스코프를 기억하는 방법? -&gt; 함수가 평가될 때 실행중인 실행컨텍스트를 기억한다.<br>-&gt; 이것을 외부렉시컬환경참조에다가 넣는다<br>bar는 foo가 평가될 때 만들어진다. 함수는 객체니까 프로퍼티가 있고, 외부에 공개되지않는 <code>[[environment]]</code>라는 내부슬롯에 자기의 상위스코프를 항상 들고다닌다 -&gt; 이것이 클로저<br>자기의 직속상위스코프만 알고있으면 더 위의 스코프까지 알 수 있다.<br>이론적으로 자바스크립트의 모든 함수는 자신의 상위스코프를 기억하는 클로저이다.  </p><!-- 화살표함수는 this가 없고 렉시컬this를 참조할수있음.흡사 화살표함수.bind(this) 와 같다. 즉 상위의 this를 바인딩.할당을 위해 식별자를 찾을떄, 현재실행중인 실행컨텍스트에서 찾는다.연산을 위해 식별자를 찾을때 현재실행중인 실행컨텍스트에서부터 찾고, 없으면 현재실행컨텍스트의 외부참조를 따라 올라가서 찾는다.  -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;실행-컨텍스트&quot;&gt;&lt;a href=&quot;#실행-컨텍스트&quot; class=&quot;headerlink&quot; title=&quot;실행 컨텍스트&quot;&gt;&lt;/a&gt;실행 컨텍스트&lt;/h2&gt;&lt;p&gt;컨텍스트는 문맥이라는 뜻. 코드에도 맥락이 있다.&lt;br&gt;&lt;!-- 식별자하면 선언이라는 키워
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://dearjsmc4.github.io/2019/05/31/0531/"/>
    <id>https://dearjsmc4.github.io/2019/05/31/0531/</id>
    <published>2019-05-30T15:00:00.000Z</published>
    <updated>2019-07-03T02:21:07.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>프로미스 객체는 <strong>상태</strong>를 가지고 있다. 성공했는지, 실패했는지. 그리고 then 메소드에서는 성공한 데이터로 해야 할 일을 하고, catch 메소드로는 실패한 내용을 가지고 할 일을 한다(에러표시와 같은).  </p><h3 id="프로미스의-생성"><a href="#프로미스의-생성" class="headerlink" title="프로미스의 생성"></a>프로미스의 생성</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseAjax = <span class="function">(<span class="params">method, url, payload</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">      xhr.open(method, url);</span><br><span class="line">      xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">      xhr.send(<span class="built_in">JSON</span>.stringify(payload));</span><br><span class="line"></span><br><span class="line">      xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState !== XMLHttpRequest.DONE) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">400</span>) &#123;</span><br><span class="line">          resolve(<span class="built_in">JSON</span>.parse(xhr.response));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>promiseAjax 는 프로미스 객체를 반환하는 함수이다. 프로미스 생성자 함수가 인자로 전달받은 콜백함수는 <code>resolve</code> 와 <code>reject</code> 함수를 인자로 받는데, 내부에서 처리한 비동기 작업이 성공하면 resolve 함수를, 실패하면 reject 함수를 호출한다.  </p><ul><li><strong>resolve</strong>: 성공한 데이터가 넘어간다  </li><li><strong>reject</strong>: 실패한 이유가 넘어간다  </li></ul><p>프로미스 객체는 상태를 가지고 있다고 하였는데, 만약 비동기 처리가 성공하여 resolve 함수가 호출되면 프로미스 객체는 <code>fulfilled</code> 상태가 된다. 비동기 처리가 실패하여 reject 함수가 호출되면 프로미스 객체는 <code>rejected</code> 상태가 된다.<br>사실 프로미스 객체는 4가지의 상태를 가지고 있는데 우리가 신경써야 할 것은 fulfilled 와 rejected 이다.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promiseAjax(<span class="string">'GET'</span>, <span class="string">'http://localhost:3000/todos'</span>)</span><br><span class="line">  .then(render)</span><br><span class="line">  .catch(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><p>promiseAjax 함수에 GET 메소드와 url 을 인자로 전달하면, 상태를 가지고 있는 프로미스 객체가 반환될 것이다. 반환된 객체는 프로미스 객체이므로 then 메소드와 catch 메소드를 사용할 수 있다.  </p><ul><li><p><strong>then</strong> :<br>두 개의 콜백함수를 인자로 전달받는데, 첫 번째 콜백은 fulfilled 일 때 호출되고, 두 번째 콜백은 rejected 일 때 호출된다. (그러나 가독성 문제로, 보통 then 으로는 에러를 잡지 않는다)<br>then메소드는 프로미스를 리턴하기 때문에 <code>.then().then().then()</code> 이렇게 연결하여 쓸 수 있고 이것을 <strong>프로미스 체이닝</strong>이라고 한다. 이렇게 하면 순서대로(동기적으로) 코드를 실행할 수 있게 된다. 만약 then() 안에 들어간 것이 프로미스가 아니라면 then이 객체를 프로미스로 래핑한다(resolve라는 정적메소드를 then 안에서 호출)  </p></li><li><p><strong>catch</strong> :<br>rejected 상태를 잡아 처리한다. catch 메소드도 프로미스를 리턴한다.<br>보통 catch는 체이닝 마지막에 써준다.</p></li></ul><!-- then 도 싫다그러면 async await를 써야함 --><!-- promise.all전달받은 이터러블에 있는 모든 프로미스를 그냥 쓰여진 순서대로 실행하고 한번에 반환.promise.race전달받은 이터러블에 있는 요소중에 가장 먼저 처리된 것을 반환하고 끝.ajax 로 crud -> post, get(전부, 하나만), put, patch, deletepromise 로 crud --><!-- async는 반드시 어싱크라는 이름을 가진 함수를 만들고 그 안에서 await를 해야한다.그러면 동기처럼 돈다.  ```javascript      (async function () {      const res = await fetch('http://localhost:9000/todos'); // res엔 프로미스가 넘어온다      const todos = await res.json();      render(todos);      }());  ``` -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h2&gt;&lt;p&gt;프로미스 객체는 &lt;strong&gt;상태&lt;/strong&gt;를 가지고 있다. 성공했는지, 실패했는지
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>웹 서버, 애플리케이션 서버</title>
    <link href="https://dearjsmc4.github.io/2019/05/29/0529/"/>
    <id>https://dearjsmc4.github.io/2019/05/29/0529/</id>
    <published>2019-05-28T15:00:00.000Z</published>
    <updated>2019-07-04T01:09:50.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="웹-서버와-애플리케이션-서버"><a href="#웹-서버와-애플리케이션-서버" class="headerlink" title="웹 서버와 애플리케이션 서버"></a>웹 서버와 애플리케이션 서버</h2><h3 id="웹-서버"><a href="#웹-서버" class="headerlink" title="웹 서버"></a>웹 서버</h3><p>클라이언트의 <strong>정적파일 요청에 응답</strong>할 수 있는 서버가 웹 서버이다.<br>-&gt; HTML, CSS, Javascript, JPG, SVG, XML 와 같은 정적파일들을 제공.<br><code>https://www.naver.com</code><br>이것은 naver.com 도메인서버에 찾아가서 index.html 을 달라는 요청이다. 이 요청을 서버가 알아들어야 한다. 알아듣고 index.html 파일을 찾아서 읽어들인 뒤 메모리에 올려서 랜선에 태워서 요청한 컴퓨터로 보내야 한다. 그러면 랜선을 타고 이진수가 전달된다. 클라이언트는 리스폰스를 받고 이진수를 메모리에 저장하다가, 다 도착했다는 것을 인식하면 그때 실행 -&gt; 다운로드한다.  </p><h3 id="애플리케이션-서버"><a href="#애플리케이션-서버" class="headerlink" title="애플리케이션 서버"></a>애플리케이션 서버</h3><p>웹 서버보다 머리가 좋고, 우리는 애플리케이션 서버를 주로 쓸 것이다. <strong>정적파일을 제공</strong>할 수 있는 기능은 물론, <strong>REST API를 처리</strong>할 수 있다. (API는 우리가 함수 쓰듯이 쓸 수 있는 것이다). 인수를 줄 수도 있고 안 줄 수도있지만 리턴은 항상 있고, 이 리턴을 리스폰스라고 한다. 우리는 보낸 요청에 대한 응답(성공이든 실패든)을 백엔드로부터 받는다. 그럼 우리는 어떻게 리퀘스트를 날릴 것인지, 인수가 있을 때는 어떤 형식으로 줄 것인지, 리스폰스는 어떻게 받을 것인지, 받아서 어떻게 해석할 건지 알아야 한다.<br>근데 리스폰스가 언제 올까? 올 수도 있고 안 올 수도 있고, 1초 후에 올지 10초 후에 올지 모른다. 비동기로 동작하기 때문이다. 그래서 <strong>비동기처리</strong>를 해주어야하고, 이때 <strong>프로미스</strong>를 쓴다. 응답이 오면 무엇을 해줄게 라는 약속.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;웹-서버와-애플리케이션-서버&quot;&gt;&lt;a href=&quot;#웹-서버와-애플리케이션-서버&quot; class=&quot;headerlink&quot; title=&quot;웹 서버와 애플리케이션 서버&quot;&gt;&lt;/a&gt;웹 서버와 애플리케이션 서버&lt;/h2&gt;&lt;h3 id=&quot;웹-서버&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
