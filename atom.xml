<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rudy&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dearjsmc4.github.io/"/>
  <updated>2019-09-09T06:33:59.508Z</updated>
  <id>https://dearjsmc4.github.io/</id>
  
  <author>
    <name>Hwang Yu-Soon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Basic</title>
    <link href="https://dearjsmc4.github.io/2019/09/09/0909/"/>
    <id>https://dearjsmc4.github.io/2019/09/09/0909/</id>
    <published>2019-09-08T15:00:00.000Z</published>
    <updated>2019-09-09T06:33:59.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-day-1"><a href="#React-day-1" class="headerlink" title="React day 1"></a>React day 1</h1><h2 id="리액트"><a href="#리액트" class="headerlink" title="리액트?"></a>리액트?</h2><ul><li>페이스북에서 만든 자바스크립트 UI 라이브러리</li></ul><p>웹사이트는 빠른 속도로 복잡해지고, HTML 코드는 정보에 따라 기하급수적으로 늘어난다.<br>이 많은 HTML 코드들을 정리정돈 하고 복잡한 코드 덩어리에 이름을 붙인다 -&gt; <strong>사용자 정의 태그</strong><br>그리고 index.html 에서는 사용자 정의 태그만 갖다 쓰면 끝.<br>-&gt; 앵귤러에서 컴포넌트를 <app-navigation></app-navigation> 이렇게 불러서 쓰는 것과 똑같다!</p><ul><li>장점: 가독성 / 재사용성 / 유지보수성 </li></ul><h2 id="개발환경-셋팅"><a href="#개발환경-셋팅" class="headerlink" title="개발환경 셋팅"></a>개발환경 셋팅</h2><p>툴 체인: 내게 필요한 여러가지 개발환경과 도구를 제공해준다.<br>-&gt; 나는 Create React App 을 사용</p><p>우선 npm 을 다운로드 한 후에 Create React App 설치<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g create-react-app</span><br></pre></td></tr></table></figure></p><p>(버전 확인은 <code>$ npm -v</code>)<br>(버전 업데이트는 <code>$ npm install npm@latest -g</code>)</p><p>앱을 관리할 디렉토리를 만들고 cd 로 이동한 뒤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ create-react-app .</span><br></pre></td></tr></table></figure></p><p>해당 디렉토리 안에 개발 환경이 셋팅된다.</p><p>(+)<br><code>npx create-react-app</code> 은<br>일회용으로 다운받아 실행하고 지워버리므로 항상 최신버전에서 작업할 수 있다.<br>실무에서는 npx 를 쓰기를 권장.</p><h2 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h2><p>해당 디렉토리에서<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run start</span><br></pre></td></tr></table></figure></p><p>하면 브라우저에 리액트의 샘플 웹앱이 나타난다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-day-1&quot;&gt;&lt;a href=&quot;#React-day-1&quot; class=&quot;headerlink&quot; title=&quot;React day 1&quot;&gt;&lt;/a&gt;React day 1&lt;/h1&gt;&lt;h2 id=&quot;리액트&quot;&gt;&lt;a href=&quot;#리액트&quot; class=&quot;he
      
    
    </summary>
    
      <category term="React" scheme="https://dearjsmc4.github.io/categories/react/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="React" scheme="https://dearjsmc4.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Routing</title>
    <link href="https://dearjsmc4.github.io/2019/07/10/0710/"/>
    <id>https://dearjsmc4.github.io/2019/07/10/0710/</id>
    <published>2019-07-09T15:00:00.000Z</published>
    <updated>2019-07-12T08:48:51.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Angular-Routing"><a href="#Angular-Routing" class="headerlink" title="Angular Routing"></a>Angular Routing</h1><h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><p><strong>검색엔진최적화</strong>(Search Engine Optimization, SEO).<br>검색로봇이 24시간을 전세계 사이트를 돌아다닌다.<br>사이트들을 페이지별로 검색하고 다니면서 페이지의 HTML구조까지 들여다본다.<br>여기서 시맨틱구조가 중요한데, 검색엔진이 태그의 이름을 보고 이 페이지가 무엇에 대한 페이지인지 알 수 있기 때문이다.<br>예를 들어 <code>nav</code>태그는 중요한 메인메뉴를 가지고있을텐데, 그럼 그 네비게이션을 유심히 들여다볼 것이다.<br>사실 검색엔진이 무엇을 중요히 여기는지는 기밀이다.<br>검색엔진 동작원리에 맞춰 상위노출을 시도할 수 있기 때문이다.  </p><p>SEO가 적용되도록 만들려면 모든 페이지마다 고유한 URL을 가져야 한다.<br>Ajax의 경우 주소창이 변하지않는데, 그러면 모든 페이지가 주소가 하나이며, 검색엔진이 이게 한 페이지인지 열 페이지인지 알 수가 없다. 그래서 대부분의 SPA 애플리케이션은 라우터기능을 제공하고 있다. 단, SEO를 완전하게 충족시키려면 조금 다른 방법이 필요하다. 서버가 페이지를 제공해 주는 것이다. 앵귤러는 자체적으로 서버사이드 렌더링을 하기위한 모듈이 따로있고, 그것을 앵귤러 유니버설이라고 한다. 서버사이드렌더링으로 SPA를 구축하는 경우도 많고, 리액트도 그렇다. 리액트는 Next.js같은 서버사이드 렌더링을 지원해주는 프레임워크가 따로 있다.  </p><p>애플리케이션은 웹사이트가 아니기때문에 SEO에 그렇게 민감하지 않아도 될 수도 있다.<br>그러나 <strong>정보성</strong>을 띈 웹 앱이라면 SEO가 중요하다.  </p><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>라우팅모듈은 <strong>라우팅에 대한 정보</strong>를 담는 모듈이다. 모든 라우팅을 관리한다.<br>라우팅모듈이 주소창을 계속 주시하고 있다가, 주소창의 path가 바뀌면 그에 해당하는 컴포넌트를 화면에 활성화시켜 화면 전환이 이루어진다. </p><p>라우트를 구성하려면 모듈을 추가해주어야 하는데, <code>ng new</code> 로 앵귤러 프로젝트를 생성할 때 라우팅 옵션에 yes 라고 답하면 app-routing-module.ts 파일이 생성된다.  </p><ul><li>또는 <code>ng g m 모듈이름 --routing</code> 을 하면 모듈과 함께 라우팅 모듈도 함께 생성된다.<br>라우팅모듈은 모듈이 가지고 있는 컴포넌트들의 라우팅을 관리한다.<br>라우팅모듈에는 필요한 컴포넌트들을 임포트 해주어야 하며, 라우트 구성을 작성해준다.<br>라우팅모듈은 라우팅을 사용하는 피쳐모듈이 임포트하고, 그 모듈은 루트모듈이 임포트한다.<br>루트모듈에 임포트할 때에는, 반드시 AppRoutingModule 이전에 등록해준다.  </li></ul><p>루트모듈에 라우팅모듈을 등록해준다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AppRoutingModule &#125; <span class="keyword">from</span> <span class="string">'./app-routing.module'</span>;</span><br><span class="line"></span><br><span class="line">imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    AppRoutingModule </span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><p>라우팅 모듈은 다음과 같이 작성된다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, RouterModule &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; IndexComponent &#125; <span class="keyword">from</span> <span class="string">'./components/index.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ServiceComponent &#125; <span class="keyword">from</span> <span class="string">'./components/service.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AboutComponent &#125; <span class="keyword">from</span> <span class="string">'./components/about.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NotFoundComponent &#125; <span class="keyword">from</span> <span class="string">'./components/not-found.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 라우트 구성</span></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123; path: <span class="string">''</span>, redirectTo: <span class="string">'home'</span>, pathMatch: <span class="string">'full'</span> &#125;,</span><br><span class="line">  &#123; path: <span class="string">'home'</span>, component: IndexComponent &#125;,</span><br><span class="line">  &#123; path: <span class="string">'service'</span>, component: ServiceComponent &#125;,</span><br><span class="line">  &#123; path: <span class="string">'about'</span>, component: AboutComponent &#125;,</span><br><span class="line">  &#123; path: <span class="string">'**'</span>, component: NotFoundComponent &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  imports: [RouterModule.forRoot(routes)],</span><br><span class="line">  exports: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppRoutingModule &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>라우팅 모듈에는 라우트 구성이 등록된다.<br>객체로 이루어진 배열에서 path와 일치하는 컴포넌트를 찾아 화면에 활성화시켜준다.  </p><p><code>imports: [RouterModule.forRoot(routes)]</code><br>모든 라우트 구성을 포함한 라우터 모듈을 생성하고, 루트모듈에 등록한다. forRoot라는 함수를 호출하고, 우리가 사용할 routes를 인수로 던져준다. 만약 자식에서 쓰려면 forChild로 쓰인다. 반드시 export 해주어야한다.  </p><p>라우팅을 위한 템플릿은 다음과 같이 작성한다.  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/"</span>&gt;</span>Logo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/service"</span>&gt;</span>Service<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">routerLink</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>활성화시킬 컴포넌트를 사용하는 컴포넌트에선 컴포넌트의 태그명으로 쓰는게아니라 <code>router-outlet</code>을 이용한다. </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-navigation</span>&gt;</span><span class="tag">&lt;/<span class="name">app-navigation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>404페이지를 만들고싶을때에는, 라우트모듈의 path 를 <code>**</code>로 해준다. ‘배열 안의 그 어떤 path에도 해당하지 않으면,’ 이라는 뜻이다. 항상 맨 마지막에 달아주도록 한다. </p></li><li><p>만약 로고를 눌러도, 다른 메뉴를 눌러도 인덱스 페이지로 돌아가게 해주고 싶으면, <code>redirectTo: &#39;home&#39;</code> 으로 설정해준다. <code>pathMatch</code>와 함께 써야 한다.  </p></li></ul><!-- 그러나 라우팅은 네비게이션에서만 하는게 아니다. 로그인에 따라 라우팅이 달라질수있고 네비게이션도 없을때 어떻게하면될까.movies/:id 이렇게 보낼때에는, 라우터링크에 배열을 할당한다. 이렇게 해서 이동한 페이지에서, 그 컴포넌트에서는 서버에 아이디를 주고 그에 맞는 데이터를 가져와서 보여줘야한다. 여기서 activateroute를 쓰는구나. 왜 굳이 파라미터를 가져와야하나 싶었는데. 이걸 디테일페이지에서 캐치해서 서버와 통신해야하니까...this.route.paramMap.subscribe(  params => params.get('id'))옵저버블이라는 뜻이고, 파라미터가 변하는지를 주시하고있다는 뜻. 여기서 id 를 가져올 수 있음.만약 파라미터가 동적인 변수가 아니라 정적인 값을 보내야한다면path, component, 그리고 data를 준다data: { cart: true } => 이 컴포넌트에서는 카트를 표시해라.그래서 컴포넌트 안에서 data를 받아서 this.data에 할당해주면. data가 트루이면 보여지고 아니면 안보여지고.돔을 그리는 것: 컴포넌트컴포넌트를 활성화할지 결정하는것: 라우터 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Angular-Routing&quot;&gt;&lt;a href=&quot;#Angular-Routing&quot; class=&quot;headerlink&quot; title=&quot;Angular Routing&quot;&gt;&lt;/a&gt;Angular Routing&lt;/h1&gt;&lt;h2 id=&quot;SEO&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>Angular Template Driven Form</title>
    <link href="https://dearjsmc4.github.io/2019/07/08/template-form/"/>
    <id>https://dearjsmc4.github.io/2019/07/08/template-form/</id>
    <published>2019-07-07T15:00:00.000Z</published>
    <updated>2019-07-11T09:42:01.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Angular-Forms"><a href="#Angular-Forms" class="headerlink" title="Angular Forms"></a>Angular Forms</h1><h2 id="Template-driven-forms"><a href="#Template-driven-forms" class="headerlink" title="Template driven forms"></a>Template driven forms</h2><p>컴포넌트 클래스는 거의 쓰지않고 템플릿에서 폼을 관리한다. 리액티브 폼(컴포넌트 클래스에서 폼을 관리)과는 반대되는 방식이다.  </p><p>템플릿 기반 폼은 NgForm, NgModel, NgModelGroup 디렉티브를 중심으로 동작하는데, 이들을 이용할 때에는 먼저 루트 모듈에 <code>FormsModule</code> 을 추가해준다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; FormsModule &#125; <span class="keyword">from</span> <span class="string">'@angular/forms'</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    FormsModule</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><p>이렇게 하면 모든 폼에 <strong>NgForm 디렉티브가 자동 적용</strong>되어 템플릿 기반 폼으로 동작한다. 이제 폼은 HTML 표준 폼으로서가 아니라 앵귤러가 관리하는 폼으로서 동작한다. 콘솔에서 폼을 확인해보면 form 태그 안에 novalidate 가 추가되어 있음을 확인할 수 있다.<br>(novalidate 와 반대로 <code>ngNoForm</code> 은 HTML 표준 폼으로 동작하게 한다.)<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> #<span class="attr">userForm</span>=<span class="string">"ngForm"</span> (<span class="attr">ngSubmit</span>)=<span class="string">"onSubmit(userForm)"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>템플릿 기반 폼에도 참조변수를 사용할 수 있으며, 이때 참조변수가 <code>NgForm</code> 인스턴스를 가리킬 수 있도록 바인딩 해주어야 한다.<br>앞으로 컨트롤 요소값을 확인할 때 이 참조변수명을 이용하여 확인한다. <code>ex) userForm.value</code><br>또한 현재 폼은 NgForm 디렉티브가 적용되어 있으므로 HTML 표준 폼으로서의 submit 이벤트가 실행되지 않는다. 따라서 대신 <code>ngSubmit</code> 이벤트를 사용해야 한다.  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userid"</span> #<span class="attr">userid</span>=<span class="string">"ngModel"</span> <span class="attr">ngModel</span>&gt;</span></span><br></pre></td></tr></table></figure><p>NgForm 디렉티브는 폼 요소의 자식 폼 컨트롤 요소 중에 <code>NgModel</code> 디렉티브가 적용된 요소를 탐색하여 <code>FormGroup</code> 인스턴스에 추가한다. NgModel 디렉티브는 <code>FormControl</code> 인스턴스를 생성하는데, FormControl 은 FormGroup 의 프로퍼티로 추가된다. 따라서 템플릿 기반 폼의 구조는 다음과 같아진다.  </p><ul><li>NgForm  <ul><li>FormGroup  <ul><li>FormControl</li><li>FormControl</li><li>FormControl<br>(…)  </li></ul></li></ul></li></ul><p>템플릿 기반 폼은 input 태그 내에 <code>name</code> 어트리뷰트가 없으면 에러가 난다. 왜냐면<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userForm.value: &#123;</span><br><span class="line">  <span class="string">"userid"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"password"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>userForm.value 로 상태값을 찍어보면 위와 같이 나오는데, 폼 컨트롤 요소의 상태값을 나타낼 때의 키는 name 어트리뷰트의 값이기 때문이다. 따라서 name 어트리뷰트가 반드시 있어야 한다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userid"</span> </span></span><br><span class="line"><span class="tag">  #<span class="attr">userid</span>=<span class="string">"ngModel"</span> [(<span class="attr">ngModel</span>)]=<span class="string">"user.userid"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>NgModel 디렉티브에 <code>[()]</code> 문법을 사용하면 양방향 데이터 바인딩으로 사용가능하다. 양방향 바인딩은 이벤트 바인딩(ngModelChange)과 프로퍼티 바인딩(ngModel)의 축약표현이다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Angular-Forms&quot;&gt;&lt;a href=&quot;#Angular-Forms&quot; class=&quot;headerlink&quot; title=&quot;Angular Forms&quot;&gt;&lt;/a&gt;Angular Forms&lt;/h1&gt;&lt;h2 id=&quot;Template-driven-forms
      
    
    </summary>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/categories/angular/"/>
    
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>Module</title>
    <link href="https://dearjsmc4.github.io/2019/07/08/0708/"/>
    <id>https://dearjsmc4.github.io/2019/07/08/0708/</id>
    <published>2019-07-07T15:00:00.000Z</published>
    <updated>2019-07-11T09:37:51.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Angular-NgModule"><a href="#Angular-NgModule" class="headerlink" title="Angular NgModule"></a>Angular NgModule</h1><p>모듈은 컴포넌트를 가지고 있다.  </p><p>Angular의 큰 덩어리 하나하나가 합쳐져 하나의 모듈이 된다.<br>키워드: <strong>재사용성</strong>. 같은 기능을 하나로 합친다.  </p><ul><li>Angular의 모듈<ol><li><strong>기능모듈</strong>  <ul><li>프론트에게 가장 중요한 건 화면이다.  </li></ul></li><li><strong>공유모듈</strong><ul><li>여러 화면에 쓰이는 공유모듈은 shared라는 이름으로 만들어주는게 통상적이다. 기능모듈이 공유모듈을 import 한다.  </li></ul></li><li><strong>코어모듈</strong>  <ul><li>서비스 위주이다.  </li></ul></li></ol></li></ul><h2 id="About-Module"><a href="#About-Module" class="headerlink" title="About Module"></a>About Module</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  declarations: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  imports: [</span><br><span class="line">    BrowserModule</span><br><span class="line">  ],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123; &#125;</span><br></pre></td></tr></table></figure><p>데코레이터의 인자는 <strong>메타데이터 객체</strong>이다. 메타데이터 객체에는 컴퓨터에게 알려주는 정보들이 담겨있다. 메타데이터 객체 안의 정보를 전달하여 데코레이터가 장식하는 클래스의 인스턴스가 만들어질 때 관여한다. 위의 상황에서는 AppModule 인스턴스가 만들어질 때 메타데이터 객체가 필요한 것이다.  </p><p>가장 중요한 부분은 <strong>선언부(declarations)</strong>이다. 이 부분에는 우리가 만드는 모든 컴포넌트, 모든 파이프, 모든 디렉티브를 나열하여준다. 그러면 루트모듈이 관장하는 전체 애플리케이션에서 루트모듈 선언부에 등록된 것들이 사용가능해진다. </p><p><strong>imports</strong>에서는 루트모듈이 사용하는 <strong>모듈</strong>을 쓴다. 모듈은 모듈을 사용할 수 있다. 루트모듈이 기능모듈과 코어모듈을 임포트하여 쓴다고 했듯이. 루트모듈은 <code>BrowserModule</code> 을 사용하고있는데, BrowserModule 은 루트모듈에 반드시 들어가있어야한다. BrowserModule 은 브라우저에서 동작하는 애플리케이션을 만들 때 필요한 모듈들을 모아놓은 것이다. 코어모듈을 자체적으로 임포트하고 있는데, 그 코어모듈안에는 ngIf, ngFor 같은 디렉티브들이 들어가있다. BrowserModule 은 루트모듈에만 정의해두면된다. 추후에 만들 모듈에는 BrowserModule 이 아닌 <code>CommonModule</code> 만 있다. CommonModule 은 코어모듈의 디렉티브들을 지원하는 것들이 있다. </p><p><strong>providers</strong>는 서비스만 써준다. 요즘에는 역할이 무색해졌는데, Angular6로 넘어오면서 Injectable 데코레이터에 <code>provideIn</code> 이 생기면서 여기에 서비스를 써줄 수 있게 되었기 때문이다. 만약 provideIn 에 쓰지 않으면 providers에 적어주면 된다. </p><p>루트모듈은  <code>bootstrap: [AppComponent]</code> 를 갖고있어야 한다. Angular 애플리케이션을 가동하면 루트모듈이 돌면서 필요한 모듈이나 컴포넌트, 디렉티브를 불러모으는데, 가장 먼저 실행하는 것이 모든 컴포넌트들의 부모인 <strong>App Component 를 발화</strong>하는 것이다. 즉, 진입점인 App Component 가 뜨지 않으면 다른 컴포넌트들도 다 뜨지 않는다. 루트컴포넌트가 발화하면 루트컴포넌트의 템플릿에 쓰여진 내용이 가장 먼저 기동된다. 보통 라우터를 먼저 쓴다. </p><!-- 서비스내의 providedIn 이 있으니까 모듈에 따로 안 넣어도 되고, root 라는 말은 전역에서 사용할 수 있는 서비스라는 뜻이다. root 를 코어모듈로 바꿔주면 된다. exports는 모듈이 아니라 컴포넌트를 가지고 한다.  -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Angular-NgModule&quot;&gt;&lt;a href=&quot;#Angular-NgModule&quot; class=&quot;headerlink&quot; title=&quot;Angular NgModule&quot;&gt;&lt;/a&gt;Angular NgModule&lt;/h1&gt;&lt;p&gt;모듈은 컴포넌트를 가지고 
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>Forms</title>
    <link href="https://dearjsmc4.github.io/2019/07/03/0703/"/>
    <id>https://dearjsmc4.github.io/2019/07/03/0703/</id>
    <published>2019-07-02T15:00:00.000Z</published>
    <updated>2019-07-04T01:13:00.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h2><h3 id="HTML-Forms"><a href="#HTML-Forms" class="headerlink" title="HTML Forms"></a>HTML Forms</h3><p>폼은 직접 사용자와 대면하는 곳이기 때문에 친절해야하고 사용하기 편해야 하며, 깨끗하고 아름다워야 한다. 꼼꼼히 만들어야 한다. 폼이 있으면 폼 상에 submit 이벤트가 발생할 수 있도록 submit 타입의 버튼이 있어야 한다. (요즘은 button tag에 submit 타입을 걸어주는 경우가 많다고 한다)  </p><p>서버에 스트레스를 주지 않기 위해 폼에 대한 <strong>유효성 검사</strong>(validation check)는 클라이언트 측에서 해주어야 한다. 그리고 틀린 곳이 있다면 사용자에게 알려주어서 다시 데이터를 입력할 수 있게 안내해야 한다. 모든 절차가 끝난 후에야 서버로 날리는 것이다. 그리고 데이터를 보낼 때에는 조금씩 여러 번 보내는 것이 아니라, 한번에 보내는 것이 좋다. 서버는 요청이 와야 동작하고, 서버와 클라이언트는 일대다 관계이기 때문에 최소한의 요청을 보내야 서버의 스트레스를 줄여줄 수 있다.  </p><ul><li>폼 요소 : form 태그 전체  </li><li>폼 컨트롤 : form 태그 안의 요소들  </li></ul><p>폼에는 <code>action</code> 과 <code>method</code> 라는 두 어트리뷰트를 쓰는데,<br><code>action=&quot;url&quot;</code><br><code>method=&quot;GET/POST&quot;</code><br>와 같은 형태로 써준다.<br>클라이언트가 서버에게 정보를 주는 방식은 다양한데 그 중 대표적인건 GET과 POST<br>url의 <strong>쿼리</strong>에 담아서 보낸다. 쿼리부분은 ?키=밸류&amp;키=밸류&amp;키=밸류… 형식으로 이루어진 부분이다.  </p><!-- 그러나 ajax에서는 폼요소가 아니라 폼컨트롤들만 써서 그걸로 객체를 만들어서 페이로드를 날렷엇는데, 앵귤러에서는 폼요소를 쓴다.--><p>폼을 왜 쓰냐면, 모든 폼 컨트롤의 유효성검사 결과가 true이면 폼 전체의 유효성검사 결과 역시 true이므로, <strong>폼 컨트롤 전체를 하나로 관리</strong>하기 위해서 쓰는 것이다. 앵귤러에서는 두 가지 방식이 있는데,  </p><ol><li><strong>템플릿 기반 폼</strong> -&gt; 폼 관리의 주체가 템플릿 -&gt; 템플릿이 복잡해지는 단점 -&gt; 간단한 폼일 때 쓴다  </li><li><strong>리액티브 폼</strong> -&gt; 폼 관리의 주체가 컴포넌트 클래스 -&gt; 폼이 클 때 쓴다<br>이 두 가지 방식으로는 특히 에러처리가 편하다. </li></ol><p>ex) <code>action=&quot;/signup&quot;</code> 일 때 -&gt; REST API 라는 뜻이다. 파일명으로 요청하는 게 아니라 path 로 요청하고 있기 때문이다. HTML 파일을 준 서버와 데이터를 요청할 서버가 다를 수 있는데, 이 상황에선 같은 곳에 있다는 뜻이다.  </p><p>input 태그의 어트리뷰트  </p><ul><li><strong>required</strong> : 값이 반드시 입력되어야 함    </li><li><strong>pattern</strong> : 정규표현식  </li></ul><h3 id="Angular-Forms"><a href="#Angular-Forms" class="headerlink" title="Angular Forms"></a>Angular Forms</h3><p><code>FormsModule</code> 을 추가한 순간, <code>novalidate</code> 가 자동으로 form 태그에 추가된다. 이는 HTML 표준 폼으로써의 동작을 막는다. 그로 인해 submit 의 기본동작도 막는다: form action 에 걸려있는 경로로 리퀘스트를 날리고, 화면 전환하는 동작을 막는다. 따라서 앵귤러에서는 대신 <code>ngSubmit</code> 이벤트를 이용한다.  </p><p>폼 요소는 폼 컨트롤 요소의 부모로서 존재하며, 모든 폼 컨트롤 요소들의 유효성검증 상태가 true 이면 폼 자체의 유효성검증상태도 true가 된다.</p><p><code>#form=&quot;ngForm&quot;</code><br>템플릿 참조변수를 선언하고, 앵귤러가 관리하는 폼에 대한 인스턴스를 바인딩한다.<br>폼 컨트롤 요소에 ngModel 을 추가하면 앵귤러가 관리하게 되고, 이때부터는 앵귤러가 관리하는 폼 컨트롤 요소에 name 어트리뷰트가 없으면 에러가 난다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Forms&quot;&gt;&lt;a href=&quot;#Forms&quot; class=&quot;headerlink&quot; title=&quot;Forms&quot;&gt;&lt;/a&gt;Forms&lt;/h2&gt;&lt;h3 id=&quot;HTML-Forms&quot;&gt;&lt;a href=&quot;#HTML-Forms&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>옵저버블, 에러핸들러, 인터셉터</title>
    <link href="https://dearjsmc4.github.io/2019/07/01/0701/"/>
    <id>https://dearjsmc4.github.io/2019/07/01/0701/</id>
    <published>2019-06-30T15:00:00.000Z</published>
    <updated>2019-07-01T10:36:34.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="subscribe-옵저버블-옵저버"><a href="#subscribe-옵저버블-옵저버" class="headerlink" title="subscribe, 옵저버블, 옵저버"></a>subscribe, 옵저버블, 옵저버</h2><p>http 메소드 get 을 날렸을 때, <strong>subscribe</strong>를 안 하면 요청을 받을 수 없다.<br>옵저버블은 관측 대상이므로, 그것을 지켜보고 있는 옵저버가 없으면 아무것도 하지 않는다.<br>옵저버블과 옵저버를 이어주어야 하는데(옵저버가 옵저버블을 바라보게), 그것이 바로 subscribe 이다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.http.get&lt;Todo[]&gt;(<span class="keyword">this</span>.url)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">todos</span> =&gt;</span> <span class="keyword">this</span>.todos = todos);</span><br></pre></td></tr></table></figure><p>옵저버는 subscribe 라는 메소드를 통해서 옵저버블을 지켜보고 있다.<br>데이터를 가져온 결과물을 옵저버에게 notification 해준다.  </p><ul><li>옵저버블: 데이터 스트림을 방출할 수 있는 객체.<br>즉, 데이터 스트림을 가지고 있다. 옵저버가 있으면 옵저버에게 방출하고, 옵저버가 없으면 방출하지 않는다.  </li><li>옵저버: 관측자. 옵저버블을 관측하며 데이터를 받는다.  </li><li>subscribe: 옵저버블과 옵저버를 이어준다.  </li></ul><p>subscribe의 인수로 전달하는 것이 옵저버이다.<br>옵저버블이 객체고, 옵저버는 함수.<br><code>옵저버블.subscribe(옵저버)</code><br>=&gt; 인수로 전달한 옵저버가 옵저버블을 subscribe한다는 뜻이다.<br>뭔가 행위를 통해서 가져온 데이터를 옵저버의 인수로 넘겨준다.<br>따라서 인수의 네이밍을 제대로 하려면 우리가 무엇을 가져올 지를 알아야 한다.  </p><p>위의 예제에서, 옵저버블은 todos를 옵저버에게 전달한다.<br>get 메소드는 자기가 무엇을 가져올 지를 모른다. 그래서 무조건 <strong>객체를 리턴</strong>하도록 되어있고, 타입을 맞춰서 할당해주어야 하므로 <code>&lt;Todo[]&gt;</code> 를 해주는 것이다. -&gt; 제네릭!<br>or,<br><code>todos as Todo[]</code> -&gt; todos는 Todo[]타입으로 보겠다. -&gt; 강제형변환. 타입캐스팅.  </p><p>subscribe 안에는 데이터가 왔을 때 할 일을 적어주는 것이다.<br>-&gt; 옵저버블님, 데이터 가져오시면 todos에 주세요. 그럼 제가 어떠한 일을 하겠습니다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.http.delete&lt;Todo&gt;(<span class="string">`<span class="subst">$&#123;this.url&#125;</span><span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.todos = <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id !== id));</span><br><span class="line">  <span class="comment">// subscribe(_ =&gt; this.todos = this.todos.filter(todo =&gt; todo.id !== id));</span></span><br></pre></td></tr></table></figure><p>위의 예제에서는 빈 객체가 넘어오는 상황이고, 빈 객체는 받아줄 필요가 없으므로 함수의 매개변수는 비워둔다.<br><code>()</code> 대신 <code>_</code> 를 쓰면, 인수가 넘어왔을 때 쓰지 않겠다는 명확한 의사표시이다.  </p><p>subscribe도 then과 마찬가지로, 두 번째 함수를 주면 에러를 캐치하게 된다.  </p><h2 id="에러핸들러"><a href="#에러핸들러" class="headerlink" title="에러핸들러"></a>에러핸들러</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.http.get&lt;Todo[]&gt;(<span class="keyword">this</span>.url)</span><br><span class="line">  .subscribe(</span><br><span class="line">    <span class="comment">// 요청 성공 처리 콜백 함수 (Observer의 next 메소드)</span></span><br><span class="line">    todos =&gt; <span class="keyword">this</span>.todos = todos,</span><br><span class="line">    <span class="comment">// 요청 실패 처리 콜백 함수 (Observer의 error 메소드)</span></span><br><span class="line">    (error: HttpErrorResponse) =&gt; <span class="built_in">console</span>.error(error)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>에러핸들러에 인수로 에러를 전달해서, 에러가 이벤트객체타입이다, 라고 판별되면 클라이언트 에러이고, 아니면 백엔드의 에러로 판별된다.  </p><p><code>todos$</code> 처럼 달러가 뒤에 붙으면 옵저버블이라는 암묵적 표시이다.  </p><p>파이프로 <code>shareReplay</code>를 걸어주면 옵저버블이 <strong>공유옵저버블</strong>이 된다.  </p><h3 id="콜드-옵저버블-핫-옵저버블"><a href="#콜드-옵저버블-핫-옵저버블" class="headerlink" title="콜드 옵저버블, 핫 옵저버블"></a>콜드 옵저버블, 핫 옵저버블</h3><p><strong>콜드 옵저버블</strong>: 옵저버와 옵저버블이 일대일관계. 유니캐스트.<br><strong>핫 옵저버블</strong>: 여러 개의 옵저버가 하나의 옵저버블을 <strong>공유</strong>. 멀티캐스트.  </p><p>shareReplay 라는 오퍼레이터는, 콜드 옵저버블을 핫 옵저버블로 만든다.<br>-&gt; 여러번 subscribe을 해도 동일한 데이터가 간다.  </p><h2 id="인터셉터"><a href="#인터셉터" class="headerlink" title="인터셉터"></a>인터셉터</h2><!-- 좀 어려운데, 프로젝트에 쓰일 수도 있음.  --><ul><li><p>인터셉터가 왜 필요한가<br>만약 로그인을 하지 않은 상태에서 메인페이지로 바로 접근하려고 하면 튕겨낼 필요가 있다.<br>이때 로그인을 했는지 안 했는지 확인하고 튕겨내야 하는데, 보통 서버가 보안을 걸어놓는다.<br>그럼 우리는, 로그인에 성공하면 백엔드가 우리에게 넘겨주는 토큰을(지금은 일단 JWT(JSON Web Token)방법) 받는다. 로그인에 성공했으므로 토큰이라는 객체를 json으로 주고, 그것을 받아서 클라이언트가 가지고 있어야 한다(이 방법은 여러가지인데 심플하게는 로컬스토리지나 쿠키에 담는다. 보안 측면에서는 쿠키가 조금 더 낫지만 둘 다 장단점이 있다). 토큰은 암호화되어서 오기 때문에 우리가 열어봐도 뭔지 모른다. 로그인 페이지 이후에 보안이 필요한 다른 페이지로 갈때는 항상 토큰을 들고 간다. 그럼 토큰을 어떻게 서버에 줄것인가? 결론은 ‘<strong>헤더</strong>에 담는다’. 라우팅을 써서 이동할 때마다 헤더셋팅을 해야한다는 말인데, 귀찮다! 그래서 인터셉터라는 것을 만들어둬서 무조건 토큰을 담아가게 만든다. 인터셉터를 만들어두면, 우리가 요청할 때마다 헤더셋팅을 일일이 해줄 필요가 없어진다.  </p></li><li><p>파이프라인이란?<br>우리가 서버에 요청을 보내려고 코드로 적는 모든 과정들을 파이프라인이라고 한다.<br>인터셉터를 한 번 만들어두면 HTTP 요청을 검사하거나 변환할 수 있다.  </p></li></ul><p>인터셉터를 작성하려면 HttpInterceptor 인터페이스를 implements 해야 한다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AuthInterceptor <span class="keyword">implements</span> HttpInterceptor &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> auth: AuthService</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  intercept(req: HttpRequest&lt;<span class="built_in">any</span>&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;<span class="built_in">any</span>&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> authToken = <span class="keyword">this</span>.auth.getToken();</span><br><span class="line">    <span class="keyword">const</span> clonedRequest = req.clone(&#123;</span><br><span class="line">      headers: req.headers.set(<span class="string">'Authorization'</span>, authToken)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next.handle(clonedRequest);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  ...</span><br><span class="line">  providers: [&#123;</span><br><span class="line">    provide: HTTP_INTERCEPTORS,</span><br><span class="line">    useClass: AuthInterceptor,</span><br><span class="line">    multi: <span class="literal">true</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>리퀘스트 메세지에 있는 헤더에는 키가 있고 값이 있다. 요청할 때 우리가 authorization(백엔드와 합의된 키 이름)이라는 키를 넣고, 값으로는 토큰의 전체문자열을 넣고 서버에 날린다. 서버는 우리와 합의된 그 authorization이라는 키에 토큰이 담겨있겠거니 생각하고 그것을 꺼내서 서버에서 확인한다. 암호화된 토큰을 서버에서는 풀 수 있기 때문에, 확인해서 권한이 있는지 없는지를 확인한다. 따라서 JWT를 쓸 것이라면 서버와 클라이언트는 이 키를 합의해놓아야 한다. 그리고 그 키의 값으로 로컬스토리지에 담아놓은 토큰을 꺼내서 요청할 때 키와 값을 담아서 보내는 것이다.<br>인터셉트는 첫번째 인수로 우리가 날릴 리퀘스트 객체를 준다. (여기에서 백엔드와 합의한 키와 토큰값을 셋팅한다)<br>그리고 루트모듈에 providers 를 추가한다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;subscribe-옵저버블-옵저버&quot;&gt;&lt;a href=&quot;#subscribe-옵저버블-옵저버&quot; class=&quot;headerlink&quot; title=&quot;subscribe, 옵저버블, 옵저버&quot;&gt;&lt;/a&gt;subscribe, 옵저버블, 옵저버&lt;/h2&gt;&lt;p&gt;ht
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>생명주기, 서비스, RxJS</title>
    <link href="https://dearjsmc4.github.io/2019/06/25/0625/"/>
    <id>https://dearjsmc4.github.io/2019/06/25/0625/</id>
    <published>2019-06-24T15:00:00.000Z</published>
    <updated>2019-07-01T10:41:20.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="생명주기"><a href="#생명주기" class="headerlink" title="생명주기"></a>생명주기</h2><p>태어나서 죽을 때까지의 과정. 컴포넌트가 생성되어서 Input프로퍼티에 값이 들어오거나, 변경되거나, 모든 뷰의 초기화가 완료되었을 때(컴포넌트가 사망하면) 그때마다 우리가 무언가 작업을 해야한다면 앵귤러는 그때 필요한 훅 메소드를 제공한다. 어떤 일을 아무 때나 하는게 아니라 타이밍에 맞춰서 해야한다는 것이다. </p><p>(constructor는 생명주기와 큰 상관이 없음.)  </p><p>인터페이스는 하나 이상의 추상메소드를 가질 수 있다. 정의만 되고 실체가 없는데,<br>이것을 implement 했을 때에는 추상 메소드를 구현해야한다. 훅 메소드는 항상 <code>ng</code>가 붙고, 그 뒤의 이름은 인터페이스 이름과 일치한다. <strong>ngOnInit</strong>은 활용빈도가 높아 중요하다. 모든 초기화작업은 <code>ngOnInit</code>에서 하는 것이 좋다. 앵귤러는 자바스크립트와 달리 constructor에서는 많은 일을 하지 말 것을 요구하기 때문이다. (앞으로 웬만하면 constructor 에서는 아무것도 하지말고 대신 <code>ngOnInit</code>에서 하도록 한다)<br>앵귤러가 Input프로퍼티에 값을 넣어주는 것을 보장하는 때는 <code>ngOnInit</code>이 호출될 때이다.  </p><ul><li><p><strong>ngOnChanges</strong><br>Input프로퍼티가 있을 때, 처음으로 값이 들어오거나 변경되었을 때 실행된다.  </p></li><li><p><strong>ngOnInit</strong><br>무조건 한 번만 호출  </p></li><li><p><strong>ngDoCheck</strong><br>혹여나 변화를 감지하지 못하는 경우에 쓴다. 그러나 퍼포먼스상 안 좋으니 쓰지말자.  </p></li></ul><!-- 이제까지는 컴포넌트를 호출할때 컨텐트를 주지 않았지만, 원래 할 수 있다. <app-root>content</app-root> 컨텐트 프로젝션이라고 한다. --><ul><li><p><strong>ngAfterViewInit</strong><br>화면에 DOM요소를 동적으로 추가할 때 이 훅 메소드를 써야 한다.<br>추가된 요소들은 DOM이 완성된 후에야 참조가 가능하니까, 이 메소드로 뷰가 모두 완성되면, 이라는 타이밍에 추가된 요소들을 이 메소드 안에서 참조하도록 한다. </p></li><li><p>ngOnDestroy<br>컴포넌트와 디렉티브가 사망(…)할 때  </p></li></ul><h2 id="서비스"><a href="#서비스" class="headerlink" title="서비스"></a>서비스</h2><p>디자인패턴이 등장한다. 우리 선배들이 개발할 때 고민했던 부분들의 해결방법. 그래서 어렵다.  </p><p>서비스는, 우리 어플에서 중복적으로 사용하는 기능을 따로 떼어내는것. 마치 함수처럼!<br>뷰를 담당하는 것이 아니기 때문에 템플릿이 없다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 루트컴포넌트</span></span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greetingService = <span class="keyword">new</span> GreetingService();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>루트컴포넌트가 인스턴스를 직접 생성한다면 서비스에 의존하고 있는 것이다. 인스턴스가 없으면 일을 못하기 때문이다. 이때 서비스를 <code>의존성</code>이라고 부른다.<br>컴포넌트는 의존성의 메소드를 사용하기 위해서는 인스턴스를 직접 생성해야하며, 생성방법도 알아야하며, 메소드의 사용법도 알아야한다. 컴포넌트가 알아야할것이 너무 많다! -&gt; 긴밀히 결합되어있다.  </p><p>이로인해 문제가 생긴다. 만약 서비스가 메소드의 이름을 바꾸거나, 인수를 안 받았었는데 받기로 바꾸거나 하면 컴포넌트의 코드도 바뀌어야한다. 만약 클래스의 이름이 바뀐다면 new 코드도 바뀌어야한다. 결국 <strong>유지보수성이 나빠진다</strong>. 서비스가 바뀌더라도 컴포넌트는 바뀌지 말아야 한다! -&gt; 결합을 느슨하게 하자. 많은걸 알지않아도 되게.  </p><p>외부환경에게 의존성의 생성을 의뢰한다. 그리고 그 생성된 의존성을 주입받는것을 <strong>의존성 주입</strong>이라고 한다.<br>외부환경에서 어떻게 생성해야하는지 정보가 필요한 건 변함없다. 그러나 컴포넌트는 생성방법을 몰라도 된다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> greetingService: GreetingService</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>이때 GreetingService가 greetingService를 만드는 서비스인지는 알 수 없음. 반드시 만들어 줄 것이라는 보장이 없다. </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  providedIn: <span class="string">'root'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>서비스에 이 내용이 있어야 한다. 특히 <code>providedIn: &#39;root&#39;</code> 는, 애플리케이션 전역에서 사용할 수 있는 서비스가 된다는 뜻이다. 이걸 안 써주면 서비스가 아니며, 주입할 수 없다.  </p><p>아니면 루트모듈이나 루트컴포넌트에 아래와 같이 추가한다.<br><code>providers: [GreetingService]</code><br>그러나 만약 루트컴포넌트에 등록하면, 루트컴포넌트와 루트컴포넌트의 자식들만 서비스를 참조할 수 있다. 스코프가 제한된다.<br>따라서 모든 서비스가 전역서비스라면 서비스에서 등록한다.(만약 서비스에 등록했다면 루트모듈에 providers에 추가하지 않는다)  </p><h2 id="쉐도우-DOM-스타일-셀렉터"><a href="#쉐도우-DOM-스타일-셀렉터" class="headerlink" title="쉐도우 DOM 스타일 셀렉터"></a>쉐도우 DOM 스타일 셀렉터</h2><p>앵귤러가 제공하는 스타일 셀렉터. 웹 컴포넌트에 있는 내용이다. 이것은 앵귤러가 아니라 W3C가 관리한다. 우리가 커스텀한 컴포넌트는 아예 <code>display</code>(block/inline-block/inline 등)속성이 없다. 그러나 브라우저가 기본적인 CSS를 가지고는 있다. 그래서 브라우저마다 외양이 조금씩 다른 것이 문제가 되니까 리셋 CSS를 쓰는 것이다. 컴포넌트는 앵귤러가 제공하는 스타일 셀렉터를 이용할 필요가 있다.  </p><h2 id="RxJS"><a href="#RxJS" class="headerlink" title="RxJS"></a>RxJS</h2><p>‘Rx’ = 리액티브 프로그래밍<br>이것은 자바스크립트에 한정된 기능이 아니고 새로운 패러다임이다. 객체지향 / 절차지향과 유사한 느낌.<br>앵귤러는 기본적으로 리액티브 프로그래밍을 지원한다. 앵귤러에서 템플릿에 쓰는 모든 요소는 리액티브하게 코딩할 수 있으며, 그 기능을 다 제공하고 있다. </p><p>이제껏 내가 했던 모든 프로그래밍은 <em>입력 -&gt; 로직 -&gt; 출력</em> 의 반복이었는데,<br>문제는 입력의 형태가 다를 수 있다는거다. 문자, 숫자, 객체, 함수, 프로미스, 이벤트 등등.<br>입력값의 종류에 따라 코딩하는 방법이 제각각이었고 이런 방식이 혼란을 일으킨다(비동기입력의 경우 특히나).<br>입력이 동기데이터인지 비동기데이터인지 보고 코딩방식을 결정했었다.<br>그런데 RxJS는 <strong>이렇게 하지말고, 정적데이터든 동적데이터든 동기든 비동기든 전부 다 stream으로 만들자!!!</strong><br>데이터소비자는 가만히 있고, 데이터가 알아서 물길타고 흘러내려오는 것이다. 이벤트처리와 비슷하다. 우리가 가만있어도 이벤트는 주입되었었고, 우리는 할 일만 입력해줬었다.<br>입력데이터는 <strong>옵저버블</strong>이라는 하나의 타입으로 맞춰버리자.  </p><p>리액티브 프로그래밍은 <strong>푸시 시나리오</strong>를 기본으로 한다. 데이터 프로바이더가 무조건 데이터를 송출하며, 데이터 소비자가 그걸 알아서 받는다. 우리는 밀려들어오는 데이터에 <strong>‘반응’</strong>을 한다고 해서 리액티브 프로그래밍이다.  </p><p>외부 환경에서 애플리케이션 내부로 연속적으로 흐르는 데이터, 즉 데이터 스트림을 생성하고 방출하는 객체를 <strong>옵저버블</strong>  (Observable)이라 하고 -&gt; 방송국<br>옵저버블이 방출한(emit) <strong>노티피케이션</strong>(Notification: 옵저버블이 방출할 수 있는 푸시 기반 이벤트 또는 값) -&gt; 영상정보<br>… 을 획득하여 사용하는 객체를 <strong>옵저버</strong>(Observer)라 한다. -&gt; 내 티비<br>옵저버는 데이터 생산자(Data producer)인 옵저버블을 <strong>구독</strong>(subscription)한다. -&gt; 지켜보고있다, 관측하고있다<br>그러니까 옵저버블과 옵저버는 구독이라는 관계로 이루어진 것이다.  </p><p>옵저버블과 옵저버가 일대다의 관계일 수 있다. 방송국은 하나지만 티비는 여러 개인 것처럼.<br>RxJS에서 제공하는 메소드들은 다 <strong>오퍼레이터</strong>라고 부른다.  </p><h3 id="옵저버패턴"><a href="#옵저버패턴" class="headerlink" title="옵저버패턴"></a>옵저버패턴</h3><p><strong>Subject:</strong>  </p><ul><li>데이터<br><code>ObserverCollection</code>: 옵저버들의 모음  </li><li>메소드<br><code>register</code>: 옵저버 등록<br><code>unregister</code>: 옵저버 삭제<br><code>nofity</code>: 전달하려는 메세지를 옵저버에게 보내기  </li></ul><p><strong>Observer</strong>  </p><ul><li>메소드<br><code>update</code>: 상태 변화에 대응  </li></ul><p>서브젝트는 데이터가 바뀌면 자신을 구독하는 모든 옵저버들에게 새로운 데이터를 <code>notify</code> 하고, 옵저버들은 데이터가 바뀌면 최신데이터를 무조건 받는다(<code>update</code>).<br>옵저버패턴은 이해가안되면 외워야 한다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;생명주기&quot;&gt;&lt;a href=&quot;#생명주기&quot; class=&quot;headerlink&quot; title=&quot;생명주기&quot;&gt;&lt;/a&gt;생명주기&lt;/h2&gt;&lt;p&gt;태어나서 죽을 때까지의 과정. 컴포넌트가 생성되어서 Input프로퍼티에 값이 들어오거나, 변경되거나, 모든 뷰의
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>Directive</title>
    <link href="https://dearjsmc4.github.io/2019/06/24/0624/"/>
    <id>https://dearjsmc4.github.io/2019/06/24/0624/</id>
    <published>2019-06-23T15:00:00.000Z</published>
    <updated>2019-07-01T10:31:46.316Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>상태는 stateful 컴포넌트에서만 관리한다.<br>다른 컴포넌트들은 상태를 직접적으로 고치지 않고, <code>stateful</code>(or <code>smart</code>) 컴포넌트에게 ‘의뢰’ 한다. stateful 컴포넌트는, 상태를 직접 고칠 자격을 부여한 컴포넌트이다. 마치 사령관처럼! 자격이 없는 컴포넌트는 stateless 컴포넌트, 혹은 dumb 컴포넌트라고 한다. todos-container 는 다른 컴포넌트들을 호출할 뿐, 자신만의 템플릿은 없다. 즉, 다른 컴포넌트들을 관장하는 것이다. stateless 의 주 역할은, view 만 생성하는 것이다. view를 생성하기 위한 상태데이터는 container 가 보내주어야 한다. 만약 stateless 에서 상태가 변하면(인풋에 데이터가 입력되었다거나 하는) 상태 변경에 필요한 데이터를 보내줄 뿐, 직접 변경하진 않는다.  </p></li><li><p>ngModel content<br>양방향 데이터 바인딩. 템플릿에서 변경된 값을 클래스 컴포넌트에 갱신하고, 클래스 컴포넌트에서 변경된 값은 템플릿에 갱신된다. 따라서 인풋에 글자가 한 자 한자 입력될때마다 클래스 컴포넌트의 content에 갱신되고, 인풋 폼의 값은 content와 항상 같다.  </p></li><li><p>앵귤러의 css style<br>컴포넌트의 스코프 단위로 적용된다.  </p></li><li><p>변화감지 매커니즘<br>이 매커니즘을 이해하는 것은 어려운 일이니, 일단 참조를 바꾸는 것에 중점을 두자. 그래서 변화감지를 하기 쉽게 만들어주자.  </p></li></ul><h2 id="디렉티브"><a href="#디렉티브" class="headerlink" title="디렉티브"></a>디렉티브</h2><p>컴포넌트들의 <strong>공통된 기능</strong>이 있다면, 그 기능을 빼내서 디렉티브로 만든다.<br>디렉티브의 셀렉터는, 대괄호 안에 있는 텍스트가 어트리뷰트로써 사용될 것이라는 뜻이다. css의 셀렉터문법에서 어트리뷰트는 대괄호를 이용해 지정했었다.<br><code>input[type=text]</code> =&gt; input 태그이고, type 이라는 어트리뷰트 값이 text인 요소를 선택<br>디렉티브의 셀렉터를 클래스로써 사용하고 싶다면 대괄호대신 <code>.</code>을 붙여주면 된다. 그러나 가급적 어트리뷰트로 사용하기로 한다.<br>디렉티브는, 호스트요소를 서포트한다.  </p><ul><li><code>public el: ElementRef</code><br>‘앵귤러야, ElementRef 타입의 객체를 생성해서 내게 인수로 전달해줘.’ =&gt; 의존성주입<br>el이라는 참조를 디렉티브 전역에서 사용할 수 있게 된다. public 이기때문에.<br>el은 객체이며, 이 객체는 프로퍼티로 호스트요소를 가지고 있다.<br>그래서 <code>el.nativeElement.style.color = &quot;blue&quot;;</code> 으로 할 수 있지만 보안문제로 쓰지않는다.<br>-&gt; <strong>Renderer2</strong> 를 쓰자. DOM을 컨트롤할때 쓰는 API를 제공한다.<br><code>this.renderer.setStyle(this.el.nativeElement, &#39;color&#39;, &#39;blue&#39;);</code><br>-&gt; 위와 동일하게 동작한다.<br><code>@HostListener()</code> : 이벤트를 적용한다.<br><code>window.pageYOffset</code> : 스크롤이 얼마나 되었는지 잡아낸다.  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;상태는 stateful 컴포넌트에서만 관리한다.&lt;br&gt;다른 컴포넌트들은 상태를 직접적으로 고치지 않고, &lt;code&gt;stateful&lt;/code&gt;(or &lt;code&gt;smart&lt;/code&gt;) 컴포넌트에게 ‘의뢰’ 한다. stateful 
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>Generic, Angular</title>
    <link href="https://dearjsmc4.github.io/2019/06/17/0617/"/>
    <id>https://dearjsmc4.github.io/2019/06/17/0617/</id>
    <published>2019-06-16T15:00:00.000Z</published>
    <updated>2019-07-01T10:28:33.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="제네릭"><a href="#제네릭" class="headerlink" title="제네릭"></a>제네릭</h2><p>shift, unshift, pop, push 등은 원본 배열을 변형시키기 때문에 잘 쓰지 않는다.<br>pop과 push 의 대체문법은 concat, […todos, {…}] -&gt; 순서만 바꾸면 shift, unshift를 대체가능하다.<br>위의 네 가지는 쓸 필요도 없고 안 쓰는 것이 좋다.  </p><!-- <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  protected data = []; <span class="comment">// data: any[]</span></span><br><span class="line"></span><br><span class="line">  push(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(item); </span><br><span class="line">    <span class="comment">// 뭘 넣을지 모르기때문에 배열도 any타입.</span></span><br><span class="line">    <span class="comment">// 여기에서 타입을 지정해주는 순간 모든 프로퍼티가 영향받는다</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">0</span>);</span><br><span class="line">queue.push(<span class="string">'1'</span>); <span class="comment">// 의도하지 않은 실수!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed()); <span class="comment">// Runtime error</span></span><br></pre></td></tr></table></figure><p>원래 배열은 똑같은 타입의 요소만을 나열하는 것이 정석이다. 배열을 쓴다는 것은 순회하겠다는 의미이다. 순회하면서 똑같은 처리를 연속적으로 하겠다는 의미. 그런데 타입이 다르면 문제가 생긴다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// number 타입의 요소만을 push한다.</span></span><br><span class="line">  push(item: number) &#123;</span><br><span class="line">    <span class="keyword">super</span>.push(item); <span class="comment">// 부모 클래스의 push 함수를 그대로 쓰겠다.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop(): number &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그래서 숫자만 넣을 수 있는 클래스를 따로 만들었다!<br>근데 이런일 있을때마다 클래스 몽땅 새로 만들 수는 없잖아, 그래서 제네릭이 나왔다.  –&gt;</p><p><strong>제네릭</strong>은 <strong>타입 매개변수</strong>라고 한다. 타입을 외부에서 결정하게 한다. 정의할 때에 타입을 결정할 수 없다면 실행할 때에 타입을 결정할 수 있게.  </p><!-- `const numberQueue = new Queue<number>();`number 는 T로 넘어간다.  ~하나의 클래스로 여러가지 타입에 대응하는 큐를 만들 수 있게 되었다~ --><p>제네릭은 함수에도 쓸 수 있다.  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 어떤 타입의 배열을 매개변수로 받아서 어떤 타입의 배열을 반환하겠다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.reverse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implements 가능 -&gt; 얘가 제일 낫다</span></span><br><span class="line"><span class="keyword">interface</span> User = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 순수하게 타입만 만든다</span></span><br><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 인스턴스를 생성하지 않는 클래스는 이상하다! </span></span><br><span class="line"><span class="keyword">class</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.reverse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arg = [&#123; name: <span class="string">'Lee'</span> &#125;, &#123; name: <span class="string">'Kim'</span> &#125;, &#123; name: <span class="string">'Park'</span>, age: <span class="number">20</span> &#125;];</span><br><span class="line"><span class="comment">// 인수에 의해 타입 매개변수가 결정된다.</span></span><br><span class="line"><span class="keyword">const</span> reversed = reverse(arg);</span><br><span class="line"><span class="built_in">console</span>.log(reversed); <span class="comment">// [ &#123; name: 'Kim' &#125;, &#123; name: 'Lee' &#125; ]</span></span><br></pre></td></tr></table></figure><h2 id="Angular-template"><a href="#Angular-template" class="headerlink" title="Angular - template"></a>Angular - template</h2><h3 id="템플릿"><a href="#템플릿" class="headerlink" title="템플릿"></a>템플릿</h3><p>사실 HTML이 아니고 문자열이다. 그 안에 템플릿 문법이 포함되어 있다. 템플릿은 컴파일되어 뷰를 만든다.  </p><p><strong>데이터바인딩</strong>:<br>템플릿과 컴포넌트 클래스를 연결시키겠다는 의미. 템플릿이 컴포넌트 클래스에서 필요한 데이터를 가져와서 바인딩한다. 프로퍼티는 표현식이므로 템플릿 문법에 포함될 수 있다. 이때 자동적으로 프로퍼티 표현식은 문자열로 변환된다. 데이터가 HTML과 합쳐져서 우리가 원하는 뷰가 만들어진다. 결국 뷰는 HTML 과 CSS 로 만들어져야한다. 컴포넌트는 뷰를 만들기 위한 데이터를 제공한다.  </p><p>앵귤러는 <strong>MVW</strong> 이다. Model, View, Whatever(아무거나)(ㅋㅋㅋㅋ)<br><!-- DOM을 만들기 위해 모델을 가지고 있는데, 모델은 컴포넌트에 가지고 있을수도 있고 서비스나 디렉티브에 가지고 을수도 있다. --><br>템플릿과 연동하여 뷰(DOM)을 만든다. 템플릿이 일방적으로 데이터를 끌어간다. 왜냐면 컴포넌트 클래스는 템플릿을 모르기 때문이다.<br>그러나 이벤트 발생 시에는 다른데, 브라우저에서 이벤트가 발생하면 이벤트 핸들러를 통해 컴포넌트 클래스로 연결된다. 이벤트는 상태변화를 나타낸다. 상태변화는 DOM에서 발생하고, 모델은 할 일을 수행한다. 뷰를 다시 만들 때에는, 바뀐 부분만 다시 만들어야 한다.  </p><h2 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h2><p>자바스크립트가 HTML에 의존하지 않는 방식이 필요하다!<br>데이터바인딩의 핵심은, 템플릿이 주도권을 갖는다는 것.<br>템플릿은 컴포넌트 클래스의 클래스 필드를 참조하며 필요한 데이터를 가져온다.<br>컴포넌트 클래스는 자기 일만 묵묵히 하면 된다.  </p><ul><li>왜 이벤트바인딩은 템플릿 -&gt; 컴포넌트클래스 방향인가?<br>DOM 이벤트는 view에서 발생하기 때문.  <!-- 뷰의 돔이벤트가 발생하면 데이터가 바뀌었겠거니 하고 생각한다.  timer함수나 ajax통신도 마찬가지. 데이터가 바뀔 가능성이 높다.   --></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;제네릭&quot;&gt;&lt;a href=&quot;#제네릭&quot; class=&quot;headerlink&quot; title=&quot;제네릭&quot;&gt;&lt;/a&gt;제네릭&lt;/h2&gt;&lt;p&gt;shift, unshift, pop, push 등은 원본 배열을 변형시키기 때문에 잘 쓰지 않는다.&lt;br&gt;pop과 pu
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Typescript" scheme="https://dearjsmc4.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Angular</title>
    <link href="https://dearjsmc4.github.io/2019/06/14/0614/"/>
    <id>https://dearjsmc4.github.io/2019/06/14/0614/</id>
    <published>2019-06-13T15:00:00.000Z</published>
    <updated>2019-07-01T10:38:21.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Augular"><a href="#Augular" class="headerlink" title="Augular"></a>Augular</h2><h3 id="프레임워크-라이브러리"><a href="#프레임워크-라이브러리" class="headerlink" title="프레임워크 / 라이브러리"></a>프레임워크 / 라이브러리</h3><p>라이브러리는 본래 빌트인 함수가 아닌, 업무에 필요한 함수를 만들어서 파일로 만들어 둔 것이었으나 현대에는 특정 기능을 서폿해주는 것으로 받아들여진다. 프레임워크과 라이브러리의 기본적인 차이는 구조다.<br>프레임워크는 강제성이 크고 규모가 큰 개발에 적합하며, 라이브러리는 자유도가 높아 규모가 작은 개발에 적합하다. 그리고 특정 기능에만 관심이 있기 때문에 크기도 작다.<br>사실 강제성이 높을수록 쓰기 편하다. 자바스크립트의 관대한 문법이 언제 편한 적 있었던가.<br>이런 관점에서 보면 앵귤러는 프레임워크고 리액트는 라이브러리다.<br>앵귤러는 프레임워크고, 강제성이 높고, 크기가 크다.  </p><h3 id="왜-앵귤러를-쓰나"><a href="#왜-앵귤러를-쓰나" class="headerlink" title="왜 앵귤러를 쓰나?"></a>왜 앵귤러를 쓰나?</h3><p>원래 HTML/CSS는 정적이다. 이제까지는 JS가 주도권을 가지고 HTML/CSS 를 마음대로 가져오고, 추가하고, 삭제했다. HTML/CSS 를 파악한 후에 JS에서 일할 수 있었다는 것은 JS가 HTML/CSS에 의존하고 있었다는 뜻이다. 의존하고 있으면 영향을 받게 되어있다. HTML/CSS 구조가 틀어지는 순간 JS가 심각하게 흔들린다.   </p><p>따라서 HTML/CSS 와 JS 간의 의존을 끊는 새로운 개발방법론이 나타났다. 그래야 서로 영향을 주지않으니까. 하지만 관계는 끊으면 안 되므로, 영향을 덜 받는 방식으로 의존도를 갖도록 하였다. 즉, 반대로 HTML/CSS 가 JS를 의존하게 하자는 것이다.  </p><p>어떻게?<br>문자열상태로 넣는 것이다(템플릿). 이건 결국 HTML/CSS가 아니라 그냥 자바스크립트라고 보면 된다. index.html 만 유일한 HTML이다. 옛날엔 화면을 그려줄 함수를 코드 내에서 직접 불렀고, 우리가 신경 써야할 요소들이 많았다(이벤트를 달아준다든지, 타이밍에 맞게 렌더함수를 그려준다든지). 그런 전형적인 일들은 이제 프레임워크가 해줄 것이고, 우리는 로직개발에 집중하면 된다. 이제 HTML/CSS 가 JS의 상태데이터를 보고 있다. <code></code>은 데이터바인딩이라고 하는데, HTML/CSS 가 바라볼 상태데이터와 연결해준다. </p><p>컴포넌트는 크게 3가지 구조로 나뉘어져있다. </p><ol><li>import - 필요한 컴포넌트와 api를 import</li><li>template  - html, CSS</li><li>component - class</li></ol><h3 id="앵귤러"><a href="#앵귤러" class="headerlink" title="앵귤러"></a>앵귤러</h3><p>내용이 방대하기 때문에 한번에 다 배울 수 없고, 당장 필요한 기능을 찾아서 쓰면서 배운다.  </p><ul><li><p>높은 개발생산성: 내가 공부한 것보다 더 많은 효율과 결과를 낼 수 있다.  </p></li><li><p>컴포넌트: 레고 조각과 같다. 화면을 그리는데 필요한 부품과 같으며, 분리하고 조립하여 사용한다.   </p></li><li><p>웹에서 왜 컴포넌트 기반 개발이 어려운가 -&gt; CSS 때문에<br>컴포넌트는 HTML/CSS/JS 가 한몸으로 view를 그려야하는데, 컴포넌트가 조립되었을 때 CSS가 서로 영향을 주면 곤란하다. 어떻게 CSS 를 컴포넌트화하느냐의 문제.  </p></li><li><p>타입스크립트: 반드시 타입스크립트를 써야하는건 아니지만, 일반적으로는 타입스크립트를 쓴다.  </p></li><li><p>게으른 로딩: 현재 사용하는데에 무리가 없는 부분만큼의 리소스만 받자.<br>-&gt; SPA의 단점인 초기로딩속도를 생각해보면, 그보다 훨씬 빠를 것이다.  </p></li><li><p>코드최적화: <code>build</code> - 서버에 올릴 최종 산출물을 만들라는 명령. 이 최종 결과의 용량은 작아야 한다. 따라서 빌드하면 만들어질 코드의 용량을 줄이는데에 노력을 많이 하고 있다.  </p></li></ul><h3 id="실습하며-배운-내용"><a href="#실습하며-배운-내용" class="headerlink" title="실습하며 배운 내용"></a>실습하며 배운 내용</h3><ul><li>루트 컴포넌트: 기본 컴포넌트중에 app.module.ts 를 제외한 app 폴더의 모든 것  </li><li><p>루트 모듈: 컴포넌트를 관리한다. 모듈을 만질 줄 알아야 한다.  </p><ul><li>선언부: 컴포넌트 등록 -&gt; 새로 만들어진 컴포넌트는 이 곳에 넣어줘야한다. </li><li>임포트: 모듈을 넣어주는 곳</li><li>프로바이더스: 서비스<!-- 컴포넌트 html은 순수한 html이다. html과 CSS 컴포넌트를 분리할 수 있으면 다른 사람에게 따로 줄수도 있고... 좋다.  --></li></ul></li><li><p><code>ng serve</code> : 아직 개발 중. 개발용 서버.  </p></li><li><code>ng build</code> : 개발 다했다! 최적화!  <!-- .map : 서버에 올릴 때 map은 다 지우고 올라간다. JS파일과 ts파일을 묶어주는데에 필요한게 map 파일. 디버깅용이니까 배포할땐 필요없다.  --></li></ul><!-- 컴포넌트는 태그로 불려졌을때 태어난다. -> 태어나면 view를 그림커스텀 태그를 만든것과 같다! --><ul><li><code>-t</code> : 인라인 템플릿  </li><li><code>-s</code> : 인라인 스타일  </li><li><code>-S</code> : 스킵 테스트 (spec.ts을 안 만든다)(컴포넌트에서는 축약형이 먹히지 않는다)  </li><li><code>--flat</code> : 폴더를 만들지 않는 컴포넌트  </li></ul><!-- app-home은 app-root의 자식.html은 중첩관계에 의해 부자관계를 맺으니까. root컴포넌트는 필수적이다. 조상중의 조상이다. 아무거나 갖다두면 안된다.  --><!-- path: url의 path. 도메인 이후 슬래시 다음부터 오는 것. 여기에 내가 활성화시킬 컴포넌트를 적어줌.  --><!-- 컴포넌트는 ui를 만드는것이 주목적. --><ul><li><p>서비스: 서버에서 데이터를 가져오거나, 상태가 바뀌면 서버에 데이터를 보내거나, 로딩하거나 하는, 프로젝트 전체적으로 쓰여야하는 필요한 기능들. 화면을 그리는데에 직접적인 연관은 없는 기능을 컴포넌트로부터 분리.  </p></li><li><p><code>main.ts</code> : 앵귤러가 가동되면 가장 먼저 시작 될 파일.  </p><!-- 루트모듈에 부트스트랩에 루트컴포넌트를 적어준다고 했는데, 그 루트컴포넌트를 띄운다.  --></li></ul><!-- 컴포넌트는 하늘에서 뚝 떨진게 아니라 웹컴포넌트라는 기반이 있었다.컴포넌트를 만드는건 태그를 만드는 것과 같다. shadowDom: 나중에 컴포넌트가 합쳐졌을때 다른 컴포넌트의 간섭을 받으면 안된다. 컴포넌트의 연결은, 데이터를 주고받을 수 있어야 한다는 뜻.어 --><ul><li>데코레이터: 메타데이터 객체라고 한다. 함수이므로 사용할 때 호출이 필요하다.   </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Augular&quot;&gt;&lt;a href=&quot;#Augular&quot; class=&quot;headerlink&quot; title=&quot;Augular&quot;&gt;&lt;/a&gt;Augular&lt;/h2&gt;&lt;h3 id=&quot;프레임워크-라이브러리&quot;&gt;&lt;a href=&quot;#프레임워크-라이브러리&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Angular TIL" scheme="https://dearjsmc4.github.io/categories/angular-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Angular" scheme="https://dearjsmc4.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>SPA, Routing</title>
    <link href="https://dearjsmc4.github.io/2019/06/11/0611/"/>
    <id>https://dearjsmc4.github.io/2019/06/11/0611/</id>
    <published>2019-06-10T15:00:00.000Z</published>
    <updated>2019-06-12T10:15:40.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SPA-Single-Page-Application"><a href="#SPA-Single-Page-Application" class="headerlink" title="SPA(Single Page Application)"></a>SPA(Single Page Application)</h2><p>앵귤러, 뷰, 리액트 등을 배우려면 SPA부터 잘 알아야 한다.  </p><p>SPA는 페이지가 여러 개일지라도 <strong>HTML파일은 단 하나</strong>다. 자바스크립트는 하나일수도, 여러개일수도(웹팩으로 쪼갤 수 있다). 게다가 HTML파일에는 빈 태그가 있고, 그것을 루트태그라고 하는데 JS가 돌면서 루트태그 안에 view를 집어넣는다.<br><!-- Ajax를 쓸 때 생기는 여러 제약사항을 커버하기 위한 모던 웹 패러다임이다.??   --><br>HTML을 처음 부르면 리소스를 가져올텐데, 첫 페이지를 로딩하는 순간 모든 리소스를 한번에 다운로드하는 것이 기본이다. 그래서 <strong>첫 페이지 로딩이 느리다</strong>는 단점이 있다. 하지만 뒷 페이지부터는 화면을 갈아끼기만 하면 되므로 퍼포먼스가 좋다. SPA를 사용하는 가장 큰 이유는, <strong>사용자 경험</strong>이 일반 네이티브 앱과 비교할 때 손색이 없기 때문이다. <strong>부드러운 화면전환</strong>이 가능하다. 화면전환이라는 건 HTML을 완전히 새로 그린다는건데 쓸데없는 통신, 쓸데없는 렌더링이 발생한다. 화면이 깜빡하면 네이티브 앱처럼 동작하는 게 아니다.(엑셀이 화면깜빡거리지 않잖아) AJAX에서의 화면전환은 전부 다 그리는 게 아니라 필요한 부분만 그린다.<br><!-- 웹은 원래 문서 공유/문서 간 이동을 위해 만들어졌다. --></p><p>a태그는 기본적으로 화면전환을 일으키는데, 이때 <code>e.preventDefault</code>를 써서 화면전환을 막고 Ajax 요청을 한다.<br>Ajax방식으로 하면 URL이 하나이기때문에 검색로봇이 검색할 수 없다 -&gt; 구글에서 아무리 찾아도 첫 페이지밖에 안 나온다.<br>이것이 <strong>SEO 이슈</strong>이다. 일반 웹 페이지에서 SEO이슈가 터지는 건 치명적이다. 검색이 안 되면 곤란하다. 근데 내부에서만 쓰는 웹 애플리케이션은 반대로 검색이 되면 곤란하다.<br>그리고 주소창이 안 바뀌면 SEO이슈뿐만 아니라 앞으로가기/뒤로가기가 안 되는 문제가 생긴다. 그래서 히스토리를 관리할 수 있는 HTML5 메소드가 나왔는데, HTML5니까 되는 브라우저도 있고 안 되는 브라우저도 있다.<br>웹 앱도 검색이 됐으면 좋겠다면 서버사이드 렌더링을 해야한다.<br>모든 것을 만족시키는 혁신적인 방법, 은탄환은 지금까지도 앞으로도 없다.  </p><!-- 우선 결론적으로, 우리가 바닐라스크립트로 라우팅을 구현하기는 바람직하지 않고 매우 힘들다. 앵귤러 뷰 리액트 같은 것들로 하는 게 현명하다. 우리가 이보다 잘 만들 수는 없어... --><ul><li>웹 애플리케이션 vs 웹 페이지<br>일반적인 정보를 제공하는 단순한 페이지 = 웹 페이지<br>내가 페이지에서 어떤 일을 한다 = 웹 어플리케이션  </li></ul><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>출발지와 목적지까지의 경로가 여러 개 있을 때, 경로를 결정하는 방식.<br>웹에서는 라우팅을 화면이동으로 이해한다.  </p><ol><li>주소창에 URL을 입력하거나  </li><li>a태그를 클릭하거나  </li><li>뒤로가기/앞으로가기를 클릭할 때  </li></ol><h2 id="SPA와-Routing"><a href="#SPA와-Routing" class="headerlink" title="SPA와 Routing"></a>SPA와 Routing</h2><ul><li><p>전통적 링크방식<br>주소창을 바꾼다. 바뀐 주소를 서버에 요청하고, 그 요청에 대한 응답이 오면 화면을 새롭게 그린다.<br>검색엔진에 의해 검색당하려면 페이지들이 고유의 URL을 가지고 있어야 한다.<br>SEO이슈 없고 히스토리 관리 문제없고 구현도 쉽지만, 불필요한 퍼포먼스가 너무 많다.  </p></li><li><p>Ajax 방식<br>href 속성이 필요없다. 주소창이 바뀌지 않는다(동작을 막았으니까).<br>화면깜빡임이나 불필요한 리소스 요청, 렌더링이 없지만 자바스크립트 코딩을 해야 한다.<br>히스토리 관리가 안 되고, SEO이슈 발생. 게다가 리로딩하면 초기의 index 페이지로 돌아간다.<br>리로딩은 URL을 다시 보내는 것이기 때문이다.  </p></li><li><p>hash 방식<br>요청은 새로 보내지 않으면서 주소는 다르게 관리하는 방법.<br>기존 URL에서 해쉬가 바뀌어도 요청이 새로 발생하지 않는 것을 이용한 방법.<br>히스토리관리가 되지만, 주소창에 해쉬(#)가 들어가야하기때문에 보기에 좋지 않다.<br><code>#!</code>을 사용하기도 하는데 이를 해시뱅(Hash-bang)이라고 부른다.<br>load 이벤트 : 모든 리소스가 다 준비됐을 때<br>contentloaded 이벤트 : 돔이 완성됐을 때 -&gt; 로드 이벤트보다 먼저 발생  </p></li><li><p>Pjax 방식<br>hash 방식의 가장 큰 단점은 SEO 이슈이다. 이를 보완한 방법이 HTML5의 Histroy API인 pushState와 popstate 이벤트를 사용한 PJAX 방식이다. 리로드하면 서버에 REST API처럼 다시 요청이 간다. 서버에서 대응해줘야 할 필요가 있다. 백엔드의 협력이 필요하다.  </p></li></ul><!-- 수퍼extend관계일때 super를 불러줘야한다. 부모가 this를 만들어서 자식에게 주면 그것을 자식이 이어서쓴다부모가 빈 객체를 this에 바인딩하고 name을 세팅한 뒤 this를 리턴하면 super가 this를 리턴하는데 그것이 자식의 this로 들어간다this는 name을 가지고있는 인스턴스이고, 거기에다가 grade를 추가.이때 human과 student가 프로토타입체인이 구성되어서 메소드도 상속받는다Student 는 클래스지만 클래스도 함수니까 프로토타입도 생김.```javascriptclass Human {  constructor(name) {    this.name = name;  }  speak() {    console.log('집에가고싶다');  }}class Student extends Human {  constructor(name, grade) {    super(name);    this.grade = grade;  }}``` -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SPA-Single-Page-Application&quot;&gt;&lt;a href=&quot;#SPA-Single-Page-Application&quot; class=&quot;headerlink&quot; title=&quot;SPA(Single Page Application)&quot;&gt;&lt;/a&gt;SPA(
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>클로저</title>
    <link href="https://dearjsmc4.github.io/2019/06/07/0607/"/>
    <id>https://dearjsmc4.github.io/2019/06/07/0607/</id>
    <published>2019-06-06T15:00:00.000Z</published>
    <updated>2019-06-17T12:00:21.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="시작-전-예제"><a href="#시작-전-예제" class="headerlink" title="시작 전 예제"></a>시작 전 예제</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>-&gt; 스코프체인과 프로토타입체인은 따로따로 일하는게 아니라 식별자를 찾을 때 협력하는 관계이다.</p><h2 id="예제-2"><a href="#예제-2" class="headerlink" title="예제 2"></a>예제 2</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] += x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>foo 함수에 대한 평가가 이루어져서 arr 이 함수의 환경레코드에 등록된다.<br>for문 안의 변수가 var로 초기화 되는 것이었다면 함수의 환경레코드에 들어가겠지만(블록레벨스코프를 지원하지않으니까) let은 for문 안에서만 유효하기때문에 스코프도 for문으로 제한된다. 함수내부를 평가할 때 for문은 일단 지나쳐버리고, 함수내부를 실행할 때 arr에 배열을 할당해준다. (객체가 되어 할당된다)<br>현재 실행중인 실행컨텍스트는 foo 이다. for문을 만나면 for문에 대한 새로운 렉시컬환경을 만든다. 실행컨텍스트를 새로 만드는 게 아니다! 실행컨텍스트를 만드는 건 실행 가능한 코드의 4가지 종류(전역, 함수, eval, 모듈)만 만드는거다.<br>for문은 실행컨텍스트를 만들지 않고 for의 렉시컬환경만 만든다. 그리고 기존의 렉시컬환경(foo)을 새로운 렉시컬환경(for)으로 갈아끼우면서(함수 실행 컨텍스트가 기존에 foo의 렉시컬환경과의 관계를 끊고 블록 렉시컬 환경을 가리키게된다) 부자관계를 맺고(for의 외부환경참조가 foo의 렉시컬환경을 가리킨다) for문을 실행한 후, foo 함수의 렉시컬환경으로 되돌린다. -&gt; tc39 ecma 262 - 13.2.13 참고  </p><h2 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h2><p>클로저를 배워야하는 이유 : 정보은닉보다는 <strong>안전한 상태유지</strong>가 주 목적이다.<br>근데 왜 상태유지를 클로저로 해야할까?<br>-&gt; 전역변수로 상태유지를 할 수도 있지만 그건 안전하지가 않다. 왜냐면 아무나 고칠 수 있기 때문이다.<br><!-- 안전하다고 하려면 상태를 변경할 수 있는 자격이 필요하다.    --><br>안전하게, 라는 말을 빼고 상태유지를 하는 방법은 객체의 프로퍼티가 있음.<br>그러나 프로퍼티 역시 접근해서 상태를 바꿀 수도 있다. 객체의 모든 프로퍼티는 퍼블릭하다.<br>안전한 상태유지를 하고싶다면 클로저를 써야 한다.  </p><!-- 실행컨텍스트의 관점에서 이해하고 설명할 수 있어야한다.요즘은 내부함수가 아니라 중첩함수(nested function) 이라고 하는 추세이다. --><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  innerFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outerFunc(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>전역코드가 평가되어 x와 outerfunc이 등록된다.<br>outerfunc가 실행되면 실행컨텍스트에 함수 실행컨텍스트 스택이 쌓이고 렉시컬환경과 환경레코드가 생기고 x와 innerfunc가 등록된다. 함수 내부가 실행되면 x에 10이 할당되고, innerfunc가 호출된다. inner함수의 실행컨텍스트가 스택에 쌓이고, inner가 현재 실행중인 실행컨텍스트가 된다. x를 바라볼때, 현재 실행중인 실행컨텍스트의 렉시컬환경의 환경레코드에서 찾는다. inner에 없으니 외부환경참조를 타고 outer로 가서(이것이 스코프체인), outer의 렉시컬환경의 환경레코드에서 찾아서 출력한다. </p><h3 id="외부환경참조"><a href="#외부환경참조" class="headerlink" title="외부환경참조"></a>외부환경참조</h3><p>함수가 호출되기전에 평가되고 함수객체가 만들어진다. 평가될 때, 실행 중인 전역실행컨텍스트의 <strong>렉시컬환경</strong>(상위스코프)을 <code>[[environment]]</code> 내부슬롯에 넣는다. -&gt; 자신이 정의된 위치에 의거해서 이미 결정되어진다. 모든 함수객체는 <code>[[environment]]</code>를 가지고 있다. 렉시컬환경도 객체니까 그 참조값을 가지고 있다. 함수 객체가 소멸되지 않는한 상위스코프 참조는 사라지지않는다. 그러니까 상위스코프도 절대 죽지않는다. 왜냐면 살아있는 중첩함수에 의해 상위스코프 참조가 끊어지지 않았기 때문에, 가비지컬렉터가 없애지않는다. 상위함수는 죽어도 그 상위함수의 렉시컬환경은 살아있다.  </p><ul><li>함수 평가 -&gt; 함수객체만들어짐 -&gt; 실행중인 실행컨텍스트의 렉시컬환경을 상위스코프로 결정</li><li>함수 실행 -&gt; 실행컨텍스트가 스택에 쌓이고, 렉시컬환경과 환경레코드의 내용이 실행하면서 채워진다.</li></ul><h3 id="모든-함수는-클로저"><a href="#모든-함수는-클로저" class="headerlink" title="모든 함수는 클로저?"></a>모든 함수는 클로저?</h3><p>모든 함수는 자신이 정의된 위치에 의해 자신의 상위스코프를 <code>[[environment]]</code>내부슬롯에 저장한다.<br>모든 함수는 상위스코프를 다 기억한다.<br>모든 함수는 이론적으로 다 클로저다.<br>클로저의 정의는, <strong>상위스코프를 만든 함수가 없어져도 상위스코프를 참조할 수 있다</strong>면 다 클로저라고 한다.<br>전역실행컨텍스트는 소멸하지않으니까 의미가 없지만, 만약 전역실행컨텍스트도 소멸한다고하면 전역함수도 자신의 상위스코프를 들고다니기때문에 다 클로저이다. 전역함수의 상위스코프는 전역렉시컬환경이다.<br>그러나,<br>만약 상위스코프의 식별자를 참조할일이 없다면 최신브라우저는 굳이 상위스코프를 기억하지않는다. 의미가 없기 때문이다.<br>클로저라고 부르지도 않는다.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 일반적으로 클로저라고 하지 않는다.</span></span><br><span class="line">  <span class="comment">// bar 함수는 클로저였지만 곧바로 소멸한다.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 상위 스코프의 식별자를 참조한다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>위와 같은 경우는 foo 가 죽었을때 bar도 같이 죽기때문에, 클로저였지만 클로저라고 하지않는다.<br>실질적인 클로저의 조건은 즉,  </p><ol><li>상위스코프의 식별자를 하나라도 참조해야하며  </li><li>상위스코프보다 생명주기가 길어야한다.  </li></ol><h2 id="클로저의-활용"><a href="#클로저의-활용" class="headerlink" title="클로저의 활용"></a>클로저의 활용</h2><p>최신 상태를 안전하게 유지하는 것이 본질적 목표이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $counter = <span class="built_in">document</span>.querySelector(<span class="string">'.counter'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increase = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 카운트 상태를 유지하기 위한 자유 변수</span></span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $counter.textContent = ++num; <span class="comment">// 상태 변경</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.increase'</span>).onclick = increase;</span><br></pre></td></tr></table></figure></p><p>이때 increase함수는 caller가 없다.<br>브라우저가 온클릭이벤트 발생시에 호출해준다. 클릭이벤트가 발생하면 이벤트큐에 함수객체가 들어갔다가, 스택이 비면 실행된다.<br>한번 클릭해서 더하기를 했다가 소멸되고, 클릭하면 다시 실행컨텍스트가 생기고 또 실행하고 소멸되고. 생기고 소멸되고의 반복. 상위스코프는 한번 생긴 후로 사라진적이 없으므로 num은 유지된다. 왜냐면, increase라는 변수에 함수를 담아놓았기 때문에.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// num: 0, // 프로퍼티는 public이므로 정보 은닉이 되지 않는다.</span></span><br><span class="line">        increase() &#123;</span><br><span class="line">          $counter.textContent = ++num; <span class="comment">// 상태 변경</span></span><br><span class="line">        &#125;,</span><br><span class="line">        decrease() &#123;</span><br><span class="line">          <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">          $counter.textContent = --num; <span class="comment">// 상태 변경</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><p>리턴은 한번만 할수있기에 자료구조에 다 담아서 한번에 리턴할 수 있다. 이때 리턴되는 자료구조, 즉 객체는 리턴되기 직전에 객체가 된다. 그 안에 리턴될 메소드들은 객체로 만들어질때 같이 만들어진다. 리턴되는 객체는 스코프를 만들지않는다! 스코프가 객체 내에서 만들어지지는 않는다. 메소드들이 자신의 상위스코프를 기억한다. 리턴되는 함수들의 상위스코프는 객체가아니라 <strong>리턴하는 함수의 렉시컬환경</strong>이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $counter = <span class="built_in">document</span>.querySelector(<span class="string">'.counter'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ① 카운트 상태를 유지하기 위한 자유 변수</span></span><br><span class="line">      <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this.num = 0; // ② 프로퍼티는 public이므로 정보 은닉이 되지 않는다.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Counter.prototype.increase = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $counter.textContent = ++num;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      Counter.prototype.decrease = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        $counter.textContent = --num;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Counter;</span><br><span class="line">    &#125;());</span><br></pre></td></tr></table></figure><p>counter를 찾고, prototype은 프로토타입체인에서 찾아서 increase를 추가하는데. 이 increase 함수의 상위스코프도 현재 실행중인 실행컨텍스트, 즉 즉시실행함수의 렉시컬환경이다.  </p><!-- ## 함수형 프로그래밍변수 사용 지양을 통한 상태변화의 최소화.객체는 참조가 공유되기때문에 변경에 영향을 받고 추적이 어렵다-> 객체를 얼려서 이뮤터블하게 쓴다 -> 딥카피해서 넘기고 얼린다 다른애들이 변경못하게이런 것을 추구하는게 함수형 프로그래밍함수는 지역변수가 아닌 외부상태를 절대 변경하지말아야한다 -> 순수함수 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;시작-전-예제&quot;&gt;&lt;a href=&quot;#시작-전-예제&quot; class=&quot;headerlink&quot; title=&quot;시작 전 예제&quot;&gt;&lt;/a&gt;시작 전 예제&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>실행컨텍스트</title>
    <link href="https://dearjsmc4.github.io/2019/06/05/0605/"/>
    <id>https://dearjsmc4.github.io/2019/06/05/0605/</id>
    <published>2019-06-04T15:00:00.000Z</published>
    <updated>2019-06-12T10:09:31.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="실행-컨텍스트"><a href="#실행-컨텍스트" class="headerlink" title="실행 컨텍스트"></a>실행 컨텍스트</h2><p>컨텍스트는 문맥이라는 뜻. 코드에도 맥락이 있다.<br><!-- 식별자하면 선언이라는 키워드를 떠올려야함.(단, 프로퍼티는 식별자라고 잘 불리지않음. 식별자는 스코프체인에서 찾지만,프로퍼티는 프로토타입체인에서 찾기때문) --><br>실행 컨텍스트는 <strong>자바스크립트엔진의 동작원리</strong>와 밀접한 관련이 있다.<br>모든 실행 가능한 코드는 우선 평가 과정을 거치면서 실행을 위한 준비를 해야한다. 실행 컨텍스트는 실행 가능한 코드를 평가하고 실행하기 위한 환경이다. 이 실행 컨텍스트는 코드 평가 과정에서 생성되고, 코드 내 선언문이 평가되어 그 결과가 실행컨텍스트에 등록된다.<br>실행 가능한 코드는 4가지 유형이 있다.  </p><ol><li>전역코드 - 전역에 존재하는 텍스트 코드.  </li><li>함수코드 - 함수 내부에 존재하는 텍스트 코드.  </li><li>eval 코드 - eval 함수에 인수로 전달된 텍스트 코드.  </li><li>모듈코드 - 모듈 내부에 존재하는 텍스트 코드.  <!-- 우리는 전역코드와 함수코드에 집중하자. 코드별로 컨텍스트가 따로다.   --></li></ol><h3 id="전역코드"><a href="#전역코드" class="headerlink" title="전역코드"></a>전역코드</h3><p><strong>전역스코프</strong>를 생성하고 전역객체와 연결되어야 한다.<br>(전역객체는 브라우저를 열자마자 생성되며, 프로퍼티와 메소드, WEB API, 변수들이 들어있다.)<br>var 키워드로 선언된 변수는 전역객체와 전역스코프에 들어가지만 let, const 는 전역스코프에만 들어간다<br>-&gt; 그래서 윈도우에서 참조못한다.<br>-&gt; declarative environment record 에 들어가있다.<br><!-- (전역 스코프와 전역 객체가 어떻게 다르더라...) --><br>전역코드평가를 통해 <strong>전역실행컨텍스트</strong>가 생성된다.  </p><h3 id="함수코드"><a href="#함수코드" class="headerlink" title="함수코드"></a>함수코드</h3><p><strong>지역스코프</strong>를 만든다. 지역스코프는 전역스코프를 가장 최상위로 하는 스코프체인의 일원으로 등록되어야 한다.<br>함수 코드가 평가되면 <strong>함수실행컨텍스트</strong>가 생성된다.</p><p>두 코드는실행컨텍스트의 내용, 즉 하는 일이 다르다. </p><ul><li><p>평가와 실행은 다르다<br>어떤 코드가 실행되기 위해서는 평가단계를 거친다. 평가의 아웃풋이 실행컨텍스트이다. 평가를 하면 실행컨텍스트가 만들어진다. 선언문들만 뽑아서 먼저 실행하는걸 코드평가라고 한다 -&gt; 변수선언때 배웠다!<br>실행컨텍스트를 만들어서 선언문을 실행한 결과로 만들어진 식별자를 등록한다.<br>그리고 런타임이 시작돼서 선언문을 제외한 코드가 실행 된다. -&gt; 값이 할당되고 연산도 가능해진다  </p></li><li><p>변수의 선언과 할당을 실행 컨텍스트로 이해하기<br>전역 코드가 평가될 때 전역 실행컨텍스트가 생성되고 x라는 식별자를 등록한다. 전역실행컨텍스트를 객체라고 생각하자. 실제로 객체이기도 하고. 그 안에 프로퍼티와 값이 있다. 식별자 x만을 등록할 순 없고 값을 줘야하는데, 할당 전에 먼저 undefined를 값으로 넣어둔다. 그게 호이스팅이었다!<br>할당은 식별자와 값을 바인딩하는 것이다. 그럼 먼저 식별자를 찾아야 하는데, 전역실행컨텍스트에서 식별자를 찾는다. 만약 없다면 레퍼런스에러가 난다. 식별자를 찾은 후엔 값을 할당한다. 할당이라는 코드실행결과 역시 실행컨텍스트에서 관리된다. 사실 이보단 더 복잡하지만.. 일단 개요를 말하자면 그렇다.<br>변수를 선언한다는 건, 변수명을 실행컨텍스트에 등록하여 자바스크립트엔진이 관리하도록 하는 것이다.<br>-&gt; (실행컨텍스트야 너가 이 식별자 좀 가지고 있어 관리좀 하게) </p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 변수 선언</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 지역 변수 선언</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 메소드 호출</span></span><br><span class="line">  <span class="built_in">console</span>.log(a + x + y); <span class="comment">// 130</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line">foo(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(x + y); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>전역객체가 일단 존재하고, 전역코드가 평가되면 전역실행컨텍스트가 생성된다. 전역의 const 변수 x, y 선언문을 평가하여 실행컨텍스트에 등록한다. foo 함수 선언문을 평가하여 foo 함수 객체를 등록한다(이때 내부 코드는 아직 평가되지 않았다!).<br>코드가 실행되면 전역 const x, y에 1, 2를 할당하고 foo 함수를 건너뛰어 foo 함수 호출문으로 간다. 함수가 호출되어 함수 내부로 들어간다. 이제 함수코드가 평가되고 함수실행컨텍스트가 만들어진다. x, y, a를 등록한다. <strong>(arguments 객체도 있다!)</strong> 함수코드가 실행이 되면 10, 20, 100 을 할당하고 콘솔로그를 찍으러 간다. 콘솔은 전역객체에서 찾을 수 있다. 함수 실행컨텍스트에서 모든 식별자를 참조할 수 있으므로 130이라는 결과가 출력된다. foo 함수 실행이 끝나면 전역코드로 나와 콘솔을 실행한다. 이때는 전역실행컨텍스트에서 x, y 를 찾아 3이 출력된다.  </p><h2 id="실행컨텍스트-스택"><a href="#실행컨텍스트-스택" class="headerlink" title="실행컨텍스트 스택"></a>실행컨텍스트 스택</h2><p>전역 코드를 실행할 때 함수 호출을 만나면 전역 코드 실행을 멈추고 함수 코드를 실행한다. 함수 코드를 실행하고 나면 다시 전역 코드로 돌아와야 하는데, 어떻게 돌아올까? 멈춘 곳에서부터 다시 코드를 실행하는 매커니즘이 실행 컨텍스트 스택이다.<br><!-- (이거 콜스택이야!) --><br>평가 전에 이미 전역객체는 실행 컨텍스트 스택에 만들어져 있다. 그래야 평가했을때 var 변수를 전역객체의 프로퍼티로 넣을 수 있으니까. 그리고 항상 스택의 맨 밑에 깔려있다. 전역실행컨텍스트은 종료될 수 없고, 브라우저를 끄지않는 한 살아있다. 스택의 맨 위에 있는 실행컨텍스트는 현재 실행중인 실행컨텍스트이다. 이렇게 스택에 쌓이는 매커니즘으로 자기가 어디로 돌아가야 할지를 알게된다. 현재 실행중인 실행컨텍스트, 즉 최상위의 실행컨텍스트가 실행을 마치고 사라지면 그 다음 실행컨텍스트로 컨트롤이 이동하는것이다.  </p><h2 id="렉시컬-환경-중요"><a href="#렉시컬-환경-중요" class="headerlink" title="렉시컬 환경(중요)"></a>렉시컬 환경(중요)</h2><p>이것이 바로 스코프. 실행 컨텍스트가 하나의 심플한 객체로 만들어진 게 아니라 복잡한 구조로 만들어져있다. 식별자가 선언되는 환경. 좀 더 정확히 얘기하면 환경레코드가 스코프이다. 렉시컬환경은 실행컨텍스트 소속이다.  </p><p>실행 컨텍스트는 <strong>LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트</strong>로 구성된다. 실행컨텍스트가 이 두 개의 프로퍼티를 가지고 있다. 처음엔 동일한 렉시컬환경객체를 가리킨 상태에서 시작함. 렉시컬환경은 3개의 프로퍼티를 가진다.  </p><ol><li>환경레코드: 식별자와 값을 관리한다  </li><li>외부렉시컬환경에대한참조: 상위스코프에 대한 참조 -&gt; 클로저와 연결  </li><li>this바인딩: 메소드를 이용한 this 결정  </li></ol><pre><code class="javascript"><span class="keyword">var</span> x = <span class="number">1</span>;<span class="keyword">const</span> y = <span class="number">2</span>;<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>{  <span class="keyword">var</span> x = <span class="number">3</span>;  <span class="keyword">const</span> y = <span class="number">4</span>;  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">b</span>) </span>{    <span class="keyword">const</span> z = <span class="number">5</span>;    <span class="built_in">console</span>.log(a + b + x + y + z);}  bar(<span class="number">10</span>);}foo(<span class="number">20</span>); <span class="comment">// 42</span></code></pre><p>함수는 자기가 정의된 곳에서 평가 된다. 어디에서 정의되었는지에 따라 상위스코프가 결정된다.<br>함수가 상위스코프를 기억하는 방법? -&gt; 함수가 평가될 때 실행중인 실행컨텍스트를 기억한다.<br>-&gt; 이것을 외부렉시컬환경참조에다가 넣는다<br>bar는 foo가 평가될 때 만들어진다. 함수는 객체니까 프로퍼티가 있고, 외부에 공개되지않는 <code>[[environment]]</code>라는 내부슬롯에 자기의 상위스코프를 항상 들고다닌다 -&gt; 이것이 클로저<br>자기의 직속상위스코프만 알고있으면 더 위의 스코프까지 알 수 있다.<br>이론적으로 자바스크립트의 모든 함수는 자신의 상위스코프를 기억하는 클로저이다.  </p><!-- 화살표함수는 this가 없고 렉시컬this를 참조할수있음.흡사 화살표함수.bind(this) 와 같다. 즉 상위의 this를 바인딩.할당을 위해 식별자를 찾을떄, 현재실행중인 실행컨텍스트에서 찾는다.연산을 위해 식별자를 찾을때 현재실행중인 실행컨텍스트에서부터 찾고, 없으면 현재실행컨텍스트의 외부참조를 따라 올라가서 찾는다.  -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;실행-컨텍스트&quot;&gt;&lt;a href=&quot;#실행-컨텍스트&quot; class=&quot;headerlink&quot; title=&quot;실행 컨텍스트&quot;&gt;&lt;/a&gt;실행 컨텍스트&lt;/h2&gt;&lt;p&gt;컨텍스트는 문맥이라는 뜻. 코드에도 맥락이 있다.&lt;br&gt;&lt;!-- 식별자하면 선언이라는 키워
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://dearjsmc4.github.io/2019/05/31/0531/"/>
    <id>https://dearjsmc4.github.io/2019/05/31/0531/</id>
    <published>2019-05-30T15:00:00.000Z</published>
    <updated>2019-07-03T02:21:07.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>프로미스 객체는 <strong>상태</strong>를 가지고 있다. 성공했는지, 실패했는지. 그리고 then 메소드에서는 성공한 데이터로 해야 할 일을 하고, catch 메소드로는 실패한 내용을 가지고 할 일을 한다(에러표시와 같은).  </p><h3 id="프로미스의-생성"><a href="#프로미스의-생성" class="headerlink" title="프로미스의 생성"></a>프로미스의 생성</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseAjax = <span class="function">(<span class="params">method, url, payload</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">      xhr.open(method, url);</span><br><span class="line">      xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">      xhr.send(<span class="built_in">JSON</span>.stringify(payload));</span><br><span class="line"></span><br><span class="line">      xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState !== XMLHttpRequest.DONE) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">400</span>) &#123;</span><br><span class="line">          resolve(<span class="built_in">JSON</span>.parse(xhr.response));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>promiseAjax 는 프로미스 객체를 반환하는 함수이다. 프로미스 생성자 함수가 인자로 전달받은 콜백함수는 <code>resolve</code> 와 <code>reject</code> 함수를 인자로 받는데, 내부에서 처리한 비동기 작업이 성공하면 resolve 함수를, 실패하면 reject 함수를 호출한다.  </p><ul><li><strong>resolve</strong>: 성공한 데이터가 넘어간다  </li><li><strong>reject</strong>: 실패한 이유가 넘어간다  </li></ul><p>프로미스 객체는 상태를 가지고 있다고 하였는데, 만약 비동기 처리가 성공하여 resolve 함수가 호출되면 프로미스 객체는 <code>fulfilled</code> 상태가 된다. 비동기 처리가 실패하여 reject 함수가 호출되면 프로미스 객체는 <code>rejected</code> 상태가 된다.<br>사실 프로미스 객체는 4가지의 상태를 가지고 있는데 우리가 신경써야 할 것은 fulfilled 와 rejected 이다.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promiseAjax(<span class="string">'GET'</span>, <span class="string">'http://localhost:3000/todos'</span>)</span><br><span class="line">  .then(render)</span><br><span class="line">  .catch(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><p>promiseAjax 함수에 GET 메소드와 url 을 인자로 전달하면, 상태를 가지고 있는 프로미스 객체가 반환될 것이다. 반환된 객체는 프로미스 객체이므로 then 메소드와 catch 메소드를 사용할 수 있다.  </p><ul><li><p><strong>then</strong> :<br>두 개의 콜백함수를 인자로 전달받는데, 첫 번째 콜백은 fulfilled 일 때 호출되고, 두 번째 콜백은 rejected 일 때 호출된다. (그러나 가독성 문제로, 보통 then 으로는 에러를 잡지 않는다)<br>then메소드는 프로미스를 리턴하기 때문에 <code>.then().then().then()</code> 이렇게 연결하여 쓸 수 있고 이것을 <strong>프로미스 체이닝</strong>이라고 한다. 이렇게 하면 순서대로(동기적으로) 코드를 실행할 수 있게 된다. 만약 then() 안에 들어간 것이 프로미스가 아니라면 then이 객체를 프로미스로 래핑한다(resolve라는 정적메소드를 then 안에서 호출)  </p></li><li><p><strong>catch</strong> :<br>rejected 상태를 잡아 처리한다. catch 메소드도 프로미스를 리턴한다.<br>보통 catch는 체이닝 마지막에 써준다.</p></li></ul><!-- then 도 싫다그러면 async await를 써야함 --><!-- promise.all전달받은 이터러블에 있는 모든 프로미스를 그냥 쓰여진 순서대로 실행하고 한번에 반환.promise.race전달받은 이터러블에 있는 요소중에 가장 먼저 처리된 것을 반환하고 끝.ajax 로 crud -> post, get(전부, 하나만), put, patch, deletepromise 로 crud --><!-- async는 반드시 어싱크라는 이름을 가진 함수를 만들고 그 안에서 await를 해야한다.그러면 동기처럼 돈다.  ```javascript      (async function () {      const res = await fetch('http://localhost:9000/todos'); // res엔 프로미스가 넘어온다      const todos = await res.json();      render(todos);      }());  ``` -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h2&gt;&lt;p&gt;프로미스 객체는 &lt;strong&gt;상태&lt;/strong&gt;를 가지고 있다. 성공했는지, 실패했는지
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>웹 서버, 애플리케이션 서버</title>
    <link href="https://dearjsmc4.github.io/2019/05/29/0529/"/>
    <id>https://dearjsmc4.github.io/2019/05/29/0529/</id>
    <published>2019-05-28T15:00:00.000Z</published>
    <updated>2019-07-04T01:09:50.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="웹-서버와-애플리케이션-서버"><a href="#웹-서버와-애플리케이션-서버" class="headerlink" title="웹 서버와 애플리케이션 서버"></a>웹 서버와 애플리케이션 서버</h2><h3 id="웹-서버"><a href="#웹-서버" class="headerlink" title="웹 서버"></a>웹 서버</h3><p>클라이언트의 <strong>정적파일 요청에 응답</strong>할 수 있는 서버가 웹 서버이다.<br>-&gt; HTML, CSS, Javascript, JPG, SVG, XML 와 같은 정적파일들을 제공.<br><code>https://www.naver.com</code><br>이것은 naver.com 도메인서버에 찾아가서 index.html 을 달라는 요청이다. 이 요청을 서버가 알아들어야 한다. 알아듣고 index.html 파일을 찾아서 읽어들인 뒤 메모리에 올려서 랜선에 태워서 요청한 컴퓨터로 보내야 한다. 그러면 랜선을 타고 이진수가 전달된다. 클라이언트는 리스폰스를 받고 이진수를 메모리에 저장하다가, 다 도착했다는 것을 인식하면 그때 실행 -&gt; 다운로드한다.  </p><h3 id="애플리케이션-서버"><a href="#애플리케이션-서버" class="headerlink" title="애플리케이션 서버"></a>애플리케이션 서버</h3><p>웹 서버보다 머리가 좋고, 우리는 애플리케이션 서버를 주로 쓸 것이다. <strong>정적파일을 제공</strong>할 수 있는 기능은 물론, <strong>REST API를 처리</strong>할 수 있다. (API는 우리가 함수 쓰듯이 쓸 수 있는 것이다). 인수를 줄 수도 있고 안 줄 수도있지만 리턴은 항상 있고, 이 리턴을 리스폰스라고 한다. 우리는 보낸 요청에 대한 응답(성공이든 실패든)을 백엔드로부터 받는다. 그럼 우리는 어떻게 리퀘스트를 날릴 것인지, 인수가 있을 때는 어떤 형식으로 줄 것인지, 리스폰스는 어떻게 받을 것인지, 받아서 어떻게 해석할 건지 알아야 한다.<br>근데 리스폰스가 언제 올까? 올 수도 있고 안 올 수도 있고, 1초 후에 올지 10초 후에 올지 모른다. 비동기로 동작하기 때문이다. 그래서 <strong>비동기처리</strong>를 해주어야하고, 이때 <strong>프로미스</strong>를 쓴다. 응답이 오면 무엇을 해줄게 라는 약속.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;웹-서버와-애플리케이션-서버&quot;&gt;&lt;a href=&quot;#웹-서버와-애플리케이션-서버&quot; class=&quot;headerlink&quot; title=&quot;웹 서버와 애플리케이션 서버&quot;&gt;&lt;/a&gt;웹 서버와 애플리케이션 서버&lt;/h2&gt;&lt;h3 id=&quot;웹-서버&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>DOM, 동기식 &amp; 비동기식, 이벤트</title>
    <link href="https://dearjsmc4.github.io/2019/05/23/0523/"/>
    <id>https://dearjsmc4.github.io/2019/05/23/0523/</id>
    <published>2019-05-22T15:00:00.000Z</published>
    <updated>2019-06-09T12:57:17.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>트리를 만든다 -&gt; 부자관계가 있다.<br><strong>DOM 트리</strong> : html 텍스트문서를 파싱한 결과로, 메모리에 들어가있는 트리모양의 자료구조.<br>우리가 작성한 구조 안에 돔트리를 컨트롤 할 수있는 DOM API가 있다면 자바스크립트파일을 실행할 때 그것들을 조작할 수 있다. 직접 메모리에 접근하여 돔트리구조 자체를 바꿔버린다 -&gt; 화면을 다시 그려야함 -&gt; 비용이 든다!<br>우리는 SPA(single page application) 로 개발을 할 것이다. html을 딱 하나만 만든다는 것. html 코드의 조각들은 자바스크립트 내부에 들어가있다. -&gt; 앵귤러 리액트 (뷰) 가 이런 일들을 위한 것. 페이지를 리페인팅하는 비용은 적게 들고 퍼포먼스 올리고…<br>모던웹개발에서는 SPA를 만들때 프레임워크를 쓰는 것이 좋다.  </p><ul><li><p>html 태그안에 들어있는 <strong>어트리뷰트</strong>는 왜 어트리뷰트인가?<br>어트리뷰트는 초기값. 변하지 않는다. -&gt; 인풋의 타입이나 밸류는 태그 안에서 지정한 그대로다.<br>프로퍼티는 변한다 -&gt; 브라우저에서 인풋에 내용을 넣으면 프로퍼티 밸류가 바뀐다 -&gt; 상태<br>이 상태는 돔요소가 가지고 있다.  </p></li><li><p><strong>노드</strong>: 돔트리상의 하나하나의 가지 -&gt; 엘리먼트라고도 한다.<br>문서노드(진입점), 요소 노드, 텍스트노드, 어트리뷰트 노드 등이 있다.  </p></li><li><p>HTMLCollection &amp; NodeList<br><code>document.querySelector()</code>로 불러올 때는 NodeList라는 자료구조에 담아서 가져온다 -&gt; Non live<br>get 종류의 메소드로 불러오면 <code>HTMLCollection</code> 에 담겨서 온다 -&gt; live (실시간으로 바뀐다)<br>HTMLCollection은 유사배열객체이다. NodeList도 유사배열객체.<br>가져온 유사배열 객체를 elem 이라는 변수에 담았다고 했을 때,  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...elems].forEach(<span class="function"><span class="params">elem</span> =&gt;</span> elem.className = <span class="string">'blue'</span>);</span><br></pre></td></tr></table></figure></li></ul><p>유사배열객체를 배열로 반환하면 배열고차함수를 사용할 수 있다.  </p><!-- id는 전역에 변수로 남아버린다. id를 많이 줄수록 변수도 많아지는것! --><h2 id="동기식-amp-비동기식"><a href="#동기식-amp-비동기식" class="headerlink" title="동기식 &amp; 비동기식"></a>동기식 &amp; 비동기식</h2><p>동기라는건 순서가 보장된다는 뜻이다.<br>반대로 비동기는 실행 순서가 보장되지 않는다.<br><!-- 비동기함수인 셋타임함수를 누가 호출하는가? 0초 경과 후에 콜백함수를 누가 호출? --></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'func1'</span>);</span><br><span class="line">  func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'func2'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  func3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'func3'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1();</span><br></pre></td></tr></table></figure><p>함수가 종료된다는 건 콜스택에서 빠진다는 말이다.<br>setTimeout 함수는 0초가 경과했는지를 검사해야하고, 0초가 경과하면 tick 이라는 이벤트가 발생하는데<br>그때 셋타임은 이벤트큐로 들어간다(큐는 선입선출이고 콜스택은 후입선출이다). 그리고 콜스택이 비었는지를 이벤트루프가 돌면서 체크하다가 콜스택이 비면 이벤트큐에서 이벤트를 갖다가 콜스택에 넣는다. 즉 동기함수들이 모두 끝난 후에 가장 마지막에 실행된다.</p><p>자바스크립트는 콜스택이 1개이고, 단일스레드이고, 병렬처리가 안 된다.<br>그러나 워낙 고속이다보니 한번에 여러 일을 하는것처럼 보일뿐이다.<br>함수를 잘게잘게 나누라는것도 이런 이유때문이다. 빨리 실행하고 버리게.  </p><h2 id="이벤트"><a href="#이벤트" class="headerlink" title="이벤트"></a>이벤트</h2><ul><li>이벤트를 등록하는 세 가지 방법  </li></ul><ol><li>html 태그 안에 직접 함수를 호출 -&gt; html과 js는 분리하도록 하자…  </li><li><strong>on 프로퍼티</strong>를 이용한다. 원래 값이 null 인 상태인데 여기다 이벤트를 우리가 달아주면 된다.<br><code>btn.onclick = function foo() {}</code> -&gt; 이벤트 핸들러 프로퍼티 방식<br>여기서 foo 는 메소드이다. 프로퍼티의 값이 함수면 메소드니까.<br>이벤트 핸들러를 하나밖에 달 수 없다. 두 개를 달면 덮어쓴다. html요소에만 쓸 수 있다.  </li><li><strong>addEventListener 메소드</strong> 방식. 요소 선택 후에 <code>btn.addEventListener(&#39;click&#39;, function () {})</code> 이런 식으로 호출. 이때 인수로 함수를 주는거니까 콜백으로 주는 것이다. 클릭 이벤트가 발생하면 함수호출해달라는 뜻. html요소뿐 아니라 모든 돔요소에서 동작한다. 돔요소를 지정해주지 않으면 전역 어디에서든 이벤트가 동작한다.  </li></ol><p>이벤트가 시작되면 window에서부터 시작해서 지정된 요소까지 타고 내려간다 -&gt; 캡처링<br>요소를 찍고 다시 window로 거슬러 올라간다 -&gt; 기본값은 버블링  </p><p>이벤트객체: (e)  </p><p><strong>이벤트타겟!!!</strong><br>실제로 이벤트를 발생시킨 요소에 대한 참조.<br>버튼이 여러개일때 내가 누른 ‘그’ 버튼을 참조한다.<br><!-- e.target 는 애드이벤트리스너 안에서 this와 같다. 애드이벤트리스너 앞에 있는 요소. --></p><p><strong>이벤트 위임</strong><br>div에 이벤트를 걸고, div 안에서 어떤 버튼이 이벤트를 발생시켰는지를 e.target과 버블링을 이용하여 잡아낸다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DOM&quot;&gt;&lt;a href=&quot;#DOM&quot; class=&quot;headerlink&quot; title=&quot;DOM&quot;&gt;&lt;/a&gt;DOM&lt;/h2&gt;&lt;p&gt;트리를 만든다 -&amp;gt; 부자관계가 있다.&lt;br&gt;&lt;strong&gt;DOM 트리&lt;/strong&gt; : html 텍스트문서를 파
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>클래스, 디스트럭처링, 모듈</title>
    <link href="https://dearjsmc4.github.io/2019/05/22/0522/"/>
    <id>https://dearjsmc4.github.io/2019/05/22/0522/</id>
    <published>2019-05-21T15:00:00.000Z</published>
    <updated>2019-05-23T04:58:06.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h2><p>자바스크립트는 클래스가 필요없이 프로토타입과 클로저 등으로 객체 지향 프로그래밍이 가능하다. 하지만 클래스 기반 언어에 익숙하다면 자바스크립트의 프로그래밍 방식이 혼란스러울 수 있다. 그래서 자바스크립트에도 클래스처럼 동작하는 클래스가 생겼다. 생성자 함수보다 더 엄격하다.  </p><p>클래스 <strong>선언은 런타임 전에</strong> 이루어진다. 선언 이전에 참조하면 참조에러가 난다. let과 const처럼 일시적 사각지대에 빠진다. 호이스팅이 되지만 안 그런 것처럼 보인다.<br><!-- 클래스는 왜 함수와 비슷하게 동작할까? 클래스는 함수이기때문에... --></p><p>클래스 내부에 생성자함수와 유사한 역할을 하는 <strong>constructor</strong>가 있다. 만약 생략하면 자바스크립트엔진은 constructor가 있는 것처럼 생각하고 호출하며 빈 객체를 만든다. <strong>new 연산자로 호출</strong>하면 constructor 가 호출된다(가장 먼저, 단 한 번). 그리고 프로퍼티 정의를 해준다.  </p><p>클래스에서 메소드는 프로토타입을 써주지 않아도 <strong>기본적으로 프로토타입 메소드</strong>이다. 객체 리터럴에서 메소드를 선언하면 그 메소드는 객체리터럴의 것이지만 클래스에서는 인스턴스의 프로토타입의 것이다. 문법이 더 함축적이다.  </p><p>클래스에서는 우리가 프로퍼티라고 부르던 this <strong>.name</strong> 을 <strong>클래스필드</strong>라고 부른다. 멤버, 필드, 클래스필드, 인스턴스변수 등등으로 불리기도 한다. constructor는 객체를 직접 생산하고 프로퍼티를 초기화한다. 마치 생성자함수처럼 동작한다. constructor는 인수를 꼭 받을 필요는 없다. 인스턴스마다 다른 값을 가져야하는 프로퍼티가 있다면 그때 전달해주면 된다. 함수도 파라미터 정의할 때 무조건 지정해두진 않으니까.  클래스필드는 constructor 안에서 정의해야한다. constructor의 매개변수를 name = ‘’ 으로 초기화해두면 undefined 가 아니라 빈 문자열이 나온다.  </p><!-- ecmascript는 누가 관리하고 누가 버전업하는가? 세계 각국에 있는 사람들이 표준화를 요청하면 tc39라는 위원회의 위원들이 관리. 심의하여 올라온 안건들을 검토하여 4단계까지 올라오면 다음 ecmascript의 표준으로 들어간다. 3까지만 올라와도 거의 통과이긴 함. 클래스필드도 생성자 안에 써야하는데 밖에 쓰는게 거의 4단계로 올라왔기때문에 곧 표준될듯.  --><h3 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter / setter"></a>getter / setter</h3><ul><li><p><strong>getter</strong> : 데이터프로퍼티에 <strong>접근</strong><br>함수 호출처럼 쓰는 게 아니다. 반드시 무언가를 반환한다. 데이터를 가지고 있지않다. 다른 프로퍼티의 데이터를 가지고 무언가를 해서 반환한다.  </p></li><li><p><strong>setter</strong> : 데이터프로퍼티에 값을 <strong>셋팅</strong><br>셋팅을 하기위해 인수를 받는다. 반환하지 않는다.  </p></li></ul><h3 id="정적메소드"><a href="#정적메소드" class="headerlink" title="정적메소드"></a>정적메소드</h3><p><strong>this를 쓰지않는</strong> 메소드. hasOwnProperty 같은 프로토타입 메소드는 내부에서 꼭 this를 쓴다.<br>static은 클래스에서만 쓸 수 있는 키워드이며 정적메소드를 뜻한다. 정적메소드는 생성자함수에 존재한다. 생성자함수에 놓은 의도는? 인스턴스 없이 호출할 수 있도록 만들어놓은 것. Math 객체를 떠올려보자. 비슷한 일들을 하는 메소드들을 모아놓은 객체였고, 인스턴스로 호출하지 않고 Math 객체에 직접 접근하여 사용할 수 있었다.  </p><h3 id="클래스-상속"><a href="#클래스-상속" class="headerlink" title="클래스 상속"></a>클래스 상속</h3><p><strong>extends 키워드</strong>는 부모클래스를 상속받는 자식클래스를 정의할 때 사용한다.<br>-&gt; <code>class 자식클래스 extends 부모클래스</code><br>프로토타입 기반일 때에는 상속 관계를 동적으로 결정할 수 있지만 클래스에서는 상속관계를 미리 결정해놓아야 한다. 자식클래스는 constructor 내에 부모를 나타내는 <strong>super 키워드</strong>가 있다. 부모클래스를 참조하거나 부모클래스의 생성자를 호출한다. super()는 부모의 생성자를 호출하며, new 연산자로 자식클래스의 인스턴스를 생성하면 호출된다. super 호출을 안하면 this를 쓰지 못한다.</p><!-- 실린더는 서클을 상속받는다 -> 프로토타입체인을 구성한다부모클래스가 정의가 되었다자식클래스는 반지름과 높이를 매개변수로 받는다부모클래스의 생성자함수를 호출하며 반지름을 인수로 준다 -> 반지름은 부모클래스꺼를 갖다씀나(자식)만의 높이 클래스필드를 갖는다. 부모클래스의 생성자함수로 인해 물려받은 getArea 메소드를 오버라이딩한다클래스 안의 메소드는 인스턴스의 것이 아니라 프로토타입의 메소드다.아 실린더 생성자함수의 프로토타입은 실린더.프로토타입일테고 이것은 인스턴스의 프로토타입이니...인스턴스는 높이만 가지고있고 실린더.프로토타입에 메소드가 들어간다.  super.getPerimeter() -> 무조건 내 부모의 메소드를 참조하겠다는 명시적 의미 실린더는 빈객체를 만들지않는다this 는 수퍼가 만든다수퍼를 호출한다 - 부모가 만든 인스턴스를 실린더가 만들 this에 바인딩 -> 참조를 준다?만약 자식클래스만의 this.height 같은 것이 없으면 super의 this를 쓰기때문에 수퍼를 안 쓰면 this참조가 안된다?  --><!-- super(radius) 수퍼의 생성자가 호출되며 상속관계를 맺게된다서클생성자함수가 평가될때 서클프로토타입은 만들어지겠지만 실린더 프로토타입과의 관계는 없을수있다그것을 명시적으로 맺어준다? --><h2 id="디스트럭처링"><a href="#디스트럭처링" class="headerlink" title="디스트럭처링"></a>디스트럭처링</h2><h3 id="배열-디스트럭처링"><a href="#배열-디스트럭처링" class="headerlink" title="배열 디스트럭처링"></a>배열 디스트럭처링</h3><p><code>const [one, two, three] = arr;</code><br>이것은 배열이 아니라 const로 세 개의 변수를 선언하여 arr를 순차적으로 부숴서 할당. 반드시 뒤에 할당을 해주어야한다. 대괄호를 쓴 것은 = 뒤에 배열이 온다는 것이고 중괄호면 객체가 온다는 것.  </p><h3 id="객체-디스트럭처링"><a href="#객체-디스트럭처링" class="headerlink" title="객체 디스트럭처링"></a>객체 디스트럭처링</h3><p><code>const { lastName, firstName } = obj;</code><br>두 개의 변수를 선언하고 이름이 같은 프로퍼티를 할당. 순서가 무의미하다.  </p><p><code>const { prop1: p1, prop2: p2 } = { prop1: &#39;a&#39;, prop2: &#39;b&#39; };</code><br>p1은 변수. a를 p1에 넣는다(키를 비교해서).  </p><h2 id="모듈"><a href="#모듈" class="headerlink" title="모듈"></a>모듈</h2><p>a.js, b.js, c.js 이렇게 세 개의 자바스크립트 파일을 하나의 html 파일에서 쓰면 세 파일이 하나의 전역을 쓴다. 한 파일에 있는거나 마찬가지다. 파일을 나눠야 역할분담이 되는데.. 나눠봤자인 것이다. 모듈은 파일단위로 분리되기 때문에 코드의 단위가 명확히 분리되고, 재사용성이 좋아서 개발 효율성과 유지보수성을 높인다. ES6 에서는 script 태그에 <code>type=&quot;module&quot;</code> 어트리뷰트를 추가하여 모듈로서 동작하는 자바스크립트 파일 사용이 가능하다. 이때 모듈로 만드는 js파일과 일반js파일이 헷갈릴 수 있으니 모듈확장자는 mjs로 쓰는게 권장사항이다.<br>그러나 아직 ES6를 지원하지않는 브라우저도 많으니 바벨과 웹팩을 써주는 것이 좋다고 한다.<br><!-- 바벨은 우리의 소스코드를 es5로 다운그레이드해서 구형브라우저에서 돌아갈수있게 도와준다.웹팩은 바벨이 컴파일한걸 하나로 묶으면서 압축해준다? -> 스크립트태그가 한개만 있어도된다!그리고 웹팩 내부에서 모듈지원된다.  --></p><ul><li><p><strong>export</strong><br>자신의 파일 스코프 바깥으로 공개한다. 다른 모듈들이 사용할 수 있도록. 변수, 함수, 클래스 등 전부 export 할 수 있다. 그냥 식별자 앞에 export 를 붙여주면 된다. export 를 안 쓴다는건 공개하지 않겠다는 뜻이다. 반대 개념으로는 import. export 해봐야 import 하지 않으면 소용이 없다.<br>예를 들어 <code>export { pi, square, Person };</code> 라고 맨 밑에 적어주면 pi, square, Person 식별자를 하나의 객체로 구성해서 한 번에 export 가능하다.  </p></li><li><p><strong>import</strong><br>바깥으로 공개된 모듈을 로드한다. import할때에는 경로를 써줘야하는데, <code>import { export 한 이름 } from &#39;./lib.js&#39;</code> 와 같이 써준다. 브라우저 모듈에서는 파일확장자 생략이 불가하다. </p></li></ul><p><code>import * as lib from &#39;./lib&#39;;</code><br>lib라는 객체 안에 담아서 가져온다. 사용할 때 <code>lib.pi</code> 와 같은 형태로 사용한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;클래스&quot;&gt;&lt;a href=&quot;#클래스&quot; class=&quot;headerlink&quot; title=&quot;클래스&quot;&gt;&lt;/a&gt;클래스&lt;/h2&gt;&lt;p&gt;자바스크립트는 클래스가 필요없이 프로토타입과 클로저 등으로 객체 지향 프로그래밍이 가능하다. 하지만 클래스 기반 언어에
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>정규표현식, 배열고차함수, 화살표함수, Rest/Spread</title>
    <link href="https://dearjsmc4.github.io/2019/05/20/0520/"/>
    <id>https://dearjsmc4.github.io/2019/05/20/0520/</id>
    <published>2019-05-19T15:00:00.000Z</published>
    <updated>2019-05-22T10:37:59.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="정규표현식"><a href="#정규표현식" class="headerlink" title="정규표현식"></a>정규표현식</h2><p>Regular Expression, 줄여서 RegExp 라고 한다. 문자열에서 특정 내용을 찾거나 대체, 또는 발췌하는데에 사용한다. 반복문이나 조건문 대신 정규표현식을 쓰면 더 간단할 수 있지만 가독성이 좋지 않다.  </p><h3 id="플래그"><a href="#플래그" class="headerlink" title="플래그"></a>플래그</h3><p>플래그는 옵션이다.  </p><ul><li>i (Ignore Case) : 대소문자를 구별하지 않고 검색  </li><li>g (Global) : 문자열 내에서 모든 패턴 검색  </li><li>m (Multi Line) : 문자열의 행이 바뀌어도 계속 검색  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'Friday I am in love.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 대소문자를 구별하여 한 번만 검색 </span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/i/</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)); </span><br><span class="line"><span class="comment">// ["i", index: 2, input: "Friday I am in love.", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 대소문자를 구별하지 않고 전체 검색  </span></span><br><span class="line">reg = <span class="regexp">/we/ig</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)); </span><br><span class="line"><span class="comment">// (3) ["i", "I", "i"]</span></span><br></pre></td></tr></table></figure><h3 id="패턴"><a href="#패턴" class="headerlink" title="패턴"></a>패턴</h3><p>패턴에는 검색하고 싶은 문자열을 지정하며, 따옴표는 생략한다. 특별한 의미를 가지는 메타문자 또는 기호로 표현할 수도 있다.  </p><ul><li><code>.</code> : 문자 한 개를 검색  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'Friday I am in love.'</span>;</span><br><span class="line"><span class="comment">// . 은 문자 한 개를 의미한다.  </span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/.../</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br><span class="line"><span class="comment">// ... 패턴이므로 3자리 문자가 추출된다.  </span></span><br><span class="line"><span class="comment">// ["Fri", index: 0, input: "Friday I am in love.", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3자리 문자를 반복 검색  </span></span><br><span class="line">reg = <span class="regexp">/.../g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br><span class="line">(<span class="number">6</span>) [<span class="string">"Fri"</span>, <span class="string">"day"</span>, <span class="string">" I "</span>, <span class="string">"am "</span>, <span class="string">"in "</span>, <span class="string">"lov"</span>]</span><br></pre></td></tr></table></figure><ul><li><code>+</code> : 지정 문자가 한 번 이상 반복되는 문자열을 검색  </li><li><code>|</code> : or 과 같은 기능을 한다.  </li><li><code>[]</code> : <code>[]</code> 내의 문자는 or 로 동작한다. 범위를 지정하려면 <code>-</code> 를 사용한다.  </li></ul><p>자주 쓰는 정규표현식은 스크랩해두는 것이 좋다.  </p><ul><li>match 메소드를 썼을 때 일치하는 결과가 없으면 결과가 null 이다.  </li></ul><h2 id="배열-고차-함수"><a href="#배열-고차-함수" class="headerlink" title="배열 고차 함수"></a>배열 고차 함수</h2><p>함수는 객체이며, 함수를 값처럼 쓸 수 있다고 했다. 그래서 함수는 일급객체이다. 함수형 프로그래밍에서는 클로저가 매우 중요하다. 클로저 적극사용!  </p><p>콜백함수는 그 함수를 인수로받은 함수가 자기가 원할때 호출한다.<br>함수는 자기가 정의될 때 상위스코프가 결정된다. 호출될 때가 아니다! 그리고 함수는 자기의 상위스코프를 언제나 기억하고 들고 다닌다. 상위스코프를 계속 참조하고 있으므로 가비지컬렉터가 지우지 않는다.  </p><p>고차함수는 1. 함수를 인수로 전달받거나, 2. 함수를 리턴하거나, 3. 둘 다 하는 함수를 말한다.<br>함수를 밖에서 만들어서 안으로 던져주는 건 함수를 합성하는 일이다. 전달된 함수의 도움을 받아 본 함수의 내용을 바꾼다. 즉, 바깥에서 주는 함수에 따라 함수의 동작이 달라진다. 본 함수는 그대로 있고 밖에서 일부함수만 던져주면 바뀌는 부분도 줄고 유지보수 하기 좋아진다.<br>고차함수는 가변 데이터를 피하고 불변성을 지향. 외부상태가 안 바뀌었으면 좋겠다는 것이다. 외부상태에 의존하지않고 외부상태를 변경하지않는 순수함수를 추구하는 것이 함수형 프로그래밍이고, 그런 매커니즘이 녹아있는 것이 고차함수.  </p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>정렬할 때 배열의 요소들을 내부적으로 문자열로 바꿔서 비교하기 때문에 숫자 정렬 시에 원하는대로 나오지 않을 수 있음. 유니코드 순서에 따라 정렬하기 때문에. 그래서 숫자정렬할때는 함수를 준다.  </p><p><code>function (a, b) { return a - b; }</code> 이 함수를 인수로 주면 오름차순이 되는데,<br>어떻게 이렇게 되는지 까볼 필요까지는 없고 그냥 받아들이라고(…)<br><code>function (a, b) { return b - a; }</code> 는 내림차순.  </p><p><code>a[key] &gt; b[key] ? 1 : (a[key] &lt; b[key] ? -1 : 0</code><br>-&gt; 숫자일때 문자일때 모두 적용할 수 있는 삼항연산  </p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>for문 대신 쓸 것.  </p><!-- 앞으로 forEach map reduce some find filter 등을 쓰고, for문은 금지.(근데 만번돌아야된다 그러면 성능상 for문 쓰겟지...)`map`, `filter`, `reduce` 를 잘 이해해야 한다.  --><p>forEach에 함수를 주고, forEach가 함수를 호출할 때 forEach는 자기가 호출한 함수에 인수를 줄 수 있다. <strong>배열 요소의 값, 그 요소값의 인덱스, this.</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  pows.push(item ** <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>각 요소(item) 에 대해 함수를 실행. 내부적으로 for문은 돌고있다. 함수는 요소(this)의 갯수만큼 실행되고, 함수를 호출한 객체가 인수를 넣어주는 것이다. 이때 this는 함수를 호출한 배열 자체이다. forEach는 반환값이 undefined. 즉, 리턴문이 없다. 리턴을 쓰면 무시한다. forEach는 모든 요소를 순회하면서 함수를 실행한다. for문처럼 거꾸로 돌리거나 한 칸 건너뛰고 돌거나 break 거는 것은 할 수 없다.<br>for문에서도 증감식에 i++ 나 i–는 되지만 2를 더하거나 곱하거나 하는 건 좋은 코딩이 아니다. 만약 1씩 증가한다고 생각하고 코드를 짜면 에러가 날 수도 있으니까. for문은 사람이 인식하기에 좋지 않은 문법이고 가독성이 안 좋다.<br>forEach안에서 브레이크를 쓰면 에러다. 브레이크는 어떤 조건에 충족 시에 순회를 중단하겠다는건데 그건 filter 로 해결이 가능하다.<br>this를 고칠 수 있는 능력은 forEach에게는 없고 콜백에게는 있다. 왜냐면 콜백은 세번째 인자로 this를 받을 수 있으니까.<br>forEach는 for문처럼 변수선언이나 조건식 증감식이 따로 필요가 없다.<br>forEach는 콜백함수를 일반함수로 호출한다. 그 때 콜백안에서의 this는 윈도우. forEach는 첫번째 인수로 함수를 주고, 두번째 인수로 this를 전달할 수 있다. 그럼 forEach를 호출한 객체가 this가 되어서 전달된다.  </p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>this와 똑같은 갯수의 리턴을 만들어내고 싶을 때 쓴다. 어떤 배열이 있고, 그것을 map 한다고 하면 반환한 배열의 요소들은 원본 배열과 매핑된다. 원본배열의 갯수를 초과하거나 적어지지 않는다. 매 요소마다 콜백함수를 실행하여, 그 결과값으로 이루어진 새로운 배열을 반환한다. 결과값을 새로운 배열에 담아서 리턴하는 것이다. 리턴은 새로운 배열에다가 결과값을 푸쉬하는 것과 같은 동작을 한다. 그 요소의 수는 원본과 반드시 일치한다. map의 활용도는 무지하게 높다! 얘는 반드시 함수를 실행한 뒤 리턴을 해줘야 한다. 만약 리턴하지않으면 빈 배열이 나온다. 그리고 새로운 배열을 반환하기 때문에 변수로 받아주어야 한다. 원본 배열을 수정하지 않는다. forEach처럼 순회하며 콜백을 실행하는 것은 똑같다. 인수로 받는 것들도 똑같다.  </p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>this배열에서 어떤 조건에 부합하는 요소들만으로 구성된 배열을 리턴한다. 따라서 이론상 this배열보다 리턴되는 배열의 요소의 수는 같거나 적을 수 있다. 원본배열을 수정하지 않는다. forEach가 for문을 대체할 수 있듯, filter는 if문을 대체할 수 있다. 리턴문에는 불리언으로 평가되는 표현식을 넣는다. if문이라고 생각하면 된다. 그 조건에 부합하는 요소들이 리턴된다.  </p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>값을 두 개를 가지고 함수를 실행하며, 이전 콜백에서 실행한 결과를 다음 콜백의 첫 인수로 넘겨준다.  </p><h3 id="그-외"><a href="#그-외" class="headerlink" title="그 외"></a>그 외</h3><ul><li>some : 배열 내의 일부 요소가 조건에 맞는지 확인하여 불리언 반환  </li><li>every : 배열 내의 모든 요소가 조건에 맞는지 확인  </li><li>find : 조건에 맞는 첫 요소를 반환<br>여기서 콜백의 매개변수로는 객체가 들어온다. 배열이 아니라 요소를 반환함  </li><li>findIndex : 조건에 맞는 첫 요소의 인덱스를 반환. 만약 find를 못 쓰면 filter를 쓰면 된다.  </li><li>Object.assign : 뒤에서 앞으로 머지.</li></ul><h2 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h2><p>인수를 함수 몸체 안으로 넘겨준다고 이해하면 된다. 호출할 때에는 함수 표현식을 사용한다. 화살표함수는 this가 없고, 함수가 <strong>정의될 때</strong> 자신이 정의된 상위스코프의 this를 승계받는다. 자기가 this를 가지고 있는 것이 아니다. 왜냐면 얘는 콜백함수로 쓰려고 만들었기 때문에. 그러면 콜백을 쓸 때 따로 this를 바인딩해주지 않아도 되니까.  </p><ul><li>this를 바인딩하는 방법 4가지.<br>that에 담거나<br>map의 두번째 인자에 주거나<br>bind를 주거나<br>화살표 함수를 쓴다.  </li></ul><p>화살표함수는 <code>[[constructor]]</code> 가 없다. 생성자함수로 만들 수 없다.<br>this도 없고 arguments도 없다.  </p><h2 id="Rest-파라미터-Spread-연산자"><a href="#Rest-파라미터-Spread-연산자" class="headerlink" title="Rest 파라미터, Spread 연산자"></a>Rest 파라미터, Spread 연산자</h2><ul><li><p>Rest 파라미터(…rest)<br>이걸 쓰면 arguments를 안 써도 된다. arguments는 유사배열객체이기 때문에 배열화 해서 써야했지만 rest를 쓰면 그럴 필요가 없다. rest파라미터는 단독으로 쓰이거나 맨뒤에 쓰여야한다.</p></li><li><p>spread 연산자<br>rest파라미터하고 헷갈리면 안 된다! -&gt; 얘는 풀린 걸 배열로 묶는다.<br>배열 앞에 … 를 찍으면 spread 연산자로서 동작하고 배열을 다 풀어버린다. 피연산자는 문자, 배열, map, set 등의 순회가능한 자료구조여야한다.<br>sperad연산자를 사용한 배열을 인수로 전달할 수 있다. apply대신 썼던 것을 기억하자.<br>배열을 배열 안에서 풀어서 concat처럼 쓸 수 있다.<br>[…array, 4,5,6] 처럼.</p></li><li><p>Rest/Spread 프로퍼티  </p></li></ul><p>Object.assign 을 대체할 수 있는 문법.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...&#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">// &#123; x: 1, y: 2, a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure></p><p>객체 리터럴 안에서 푸는 건 가능하다. 풀려 나와서 머지가 될 것이다.<br>객체를 병합하거나 특정 프로퍼티를 변경할 때 쓴다.<br>정식 표현이 아니므로 구형 브라우저에서 돌지 않는다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;정규표현식&quot;&gt;&lt;a href=&quot;#정규표현식&quot; class=&quot;headerlink&quot; title=&quot;정규표현식&quot;&gt;&lt;/a&gt;정규표현식&lt;/h2&gt;&lt;p&gt;Regular Expression, 줄여서 RegExp 라고 한다. 문자열에서 특정 내용을 찾거나 대체,
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Object.prototype 접근, 배열</title>
    <link href="https://dearjsmc4.github.io/2019/05/17/0517/"/>
    <id>https://dearjsmc4.github.io/2019/05/17/0517/</id>
    <published>2019-05-16T15:00:00.000Z</published>
    <updated>2019-05-20T10:45:40.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Disallow-use-of-Object-prototypes-builtins-directly-no-prototype-builtins"><a href="#Disallow-use-of-Object-prototypes-builtins-directly-no-prototype-builtins" class="headerlink" title="Disallow use of Object.prototypes builtins directly (no-prototype-builtins)"></a>Disallow use of Object.prototypes builtins directly (no-prototype-builtins)</h2><p><a href="https://eslint.org/docs/rules/no-prototype-builtins" target="_blank" rel="noopener">수업시간에 본 ESLint 원문</a>  </p><p>왜 직접 접근을 불허하는가?<br>Object 의 정체는 함수다. 타입오브 찍어보면 함수라고 나온다. 이 함수는 일반적으로 new 와 함께 호출하여 빈 객체를 만드는 역할을 한다. 그런데 <code>Object.</code> 해서 메소드를 쓸 수도 있다. 함수 자체가 가지고 있는 메소드가 있다는 것이다.<br>만약 인스턴스로 메소드를 호출하려고 했다면 Object.prototype 에 있는 메소드라고 생각했으니까 그렇게 했을텐데 나오지 않았다. 그럼 Object 함수에 있는 메소드라는 뜻이고, 이건 내가 Object 에 직접 접근해서 써야 한다. 인스턴스로 호출할 수 있느냐, 직접 접근해야 하느냐에 따라 프로토타입메소드, 정적메소드로 갈린다. 프로토타입메소드는 인스턴스가 반드시 있어야(인스턴스를 생성한 후) 호출이 가능하다. 정적메소드는 인스턴스가 없어도 호출이 가능하다.<br>인스턴스로 호출한 메소드는 this가 그 인스턴스이고, 프로토타입메소드는 코드내부에 this를 반드시 쓰게 되어있다.<br><!-- 아 만약 this를 안 써도 되는 메소드면 정적메소드로 쓰기를 추천한다는 말인가? --></p><ul><li><strong>Object.create() 정적메소드</strong> </li></ul><p>인수로 객체 또는 null 을 쓰게 되어있는, 객체를 만드는 방법 중 하나. 프로토타입을 지정하면서 객체를 만들 수 있다는 것이 특징이다. 인수로 넘겨준 객체를 인스턴스의 프로토타입으로 설정해준다.<br><strong>Object.create(null)</strong> 을 하면 아무것도 상속받지 못하는 객체가 되고 스스로가 프로토타입의 종점이 된다. 이 객체는 Object.prototype 으로부터 상속받았어야 하는 메소드를 사용할 수 없다. 그래서  </p><p><code>var hasBarProperty = Object.prototype.hasOwnProperty.call(foo, &quot;bar&quot;);</code>  </p><ol><li>hasOwnProperty 를 호출하고  </li><li>this를 foo 로 갈아끼우자   </li></ol><!-- foo를 object.prototype 으로 바꾸도록 하는것임! 그럼 결국 foo.hasOwnProperty 랑 똑같아짐.왜냐면 object.prototype은 항상있고, foo가 Object.prototype 의 메소드를 상속받지못했을 가능성때문에 이렇게 쓴다고?만약 그런 가능성이라면... foo.hasOwnProperty('bar') 를 했을 때 에러가 날테니까. 아예 메소드가 없으니까. 메소드자체를 불러올수가없는것이지. --><p>Object.prototype으로 호출하면 일단 call메소드가 그 앞에까진 실행을 해줄 것이고, foo를 this로 갈아끼워주면 hasOwnProperty 함수 내부에서 쓰는 this 가 foo로 바뀐다. 호출하는 주체가 foo 로 바뀐게 아니라, 호출은 Object.prototype이 하고, 메소드가 사용하는 this가 foo로 바뀐다.  </p><p>정적메소드에서 this가 필요없으니 null 을 주는건 그냥 의미없다는 뜻으로 준 것이다… 뭘 넣어도 되지만 그렇다고 100을 넣으면 뭔가 의미가 있어보이니까.  </p><h2 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h2><p>배열은 0개 이상의 요소를 콤마(,)로 구분한 자료구조. 배열 객체에는 length 프로퍼티가 있고, 즉 순회가능하다는 뜻이다. length는 요소의 개수를 반환해준다. 유일한 Array 프로퍼티이며 마지막 요소를 기준으로 반환한다. 배열은 타입오브를 찍으면 객체라고 나온다.<br>빈 배열의 0번째 요소는 undefined 를 가지고 있는 게 아니라 그냥 비어있는 empty이며 메모리도 안 잡는다.<br>객체의 프로퍼티는 굳이 삭제하지 않고 안 쓰고 놔두면 된다(지우는게 오히려 일이다).<br>배열은 지워야 할 때가 있을 수 있다. 그런데 delete 로 지우면 길이는 변함없고 그 자리를 empty로 비워둔다. 그래서 splice를 써야 한다. 그 자리까지 잘라낼 수 있도록.<br>순회할 때에는 for문이 가장 빠르지만, 모던프로그래밍은 빠른것 보단 가독성이 먼저이다.  </p><!-- for...in문은 객체의 프로퍼티를 순회할때 쓰는거라고함. 지금은 활용도 별로라고함그런데 단점이있어서 for...of 를 쓴다고.자바스크립트의 배열은 진짜 배열이 아니라 배열을 흉내낸 객체. --><ul><li><p>indexOf<br>인수로 준 요소의 인덱스값을 반환. 없으면 -1<br>같은 것이 두 개 있으면 처음 찾은 인덱스를 반환  </p></li><li><p>concat<br>원본을 바꾸지 않고 요소를 추가한 새로운 배열을 반환.<br>(push 대신 쓰면 되겠다)  </p></li><li><p>join<br>배열의 요소를 합쳐서 문자로 반환. 인수를 주면 인수를 사이사이에 넣어준다.  </p></li><li><p>slice<br>인수를 아무것도 안 주면 복사본을 생성한다.<br>유사배열객체인 arguments를 call을 통해서 slice 함수에 this로 할당하면<br>arguments가 유사배열일지라도 배열메소드인 slice를 사용할 수 있게 된다.<br>arguments를 slice로 복사하여 배열이 되어서 반환된 걸 변수에 넣어서 쓰면 된다.  </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Disallow-use-of-Object-prototypes-builtins-directly-no-prototype-builtins&quot;&gt;&lt;a href=&quot;#Disallow-use-of-Object-prototypes-builtins-dire
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>전역객체, this</title>
    <link href="https://dearjsmc4.github.io/2019/05/15/0515/"/>
    <id>https://dearjsmc4.github.io/2019/05/15/0515/</id>
    <published>2019-05-14T15:00:00.000Z</published>
    <updated>2019-05-15T11:08:43.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="전역객체"><a href="#전역객체" class="headerlink" title="전역객체"></a>전역객체</h2><p>우리가 만드는 게 아니라 브라우저 열자마자 전역객체가 만들어진다. 그 안에는 전역객체가 가지고있는 프로퍼티와 메소드, var 로 만든 전역 변수, 암묵적 전역변수, WEB API가 들어있다. window의 프로퍼티는 window.을 생략해도 된다.  </p><h3 id="eval-함수"><a href="#eval-함수" class="headerlink" title="eval 함수"></a>eval 함수</h3><p>안 배워도 되고 가르치지도 않으려고 하는 함수…<br>얘를 왜 안 쓰냐면, 자기자신만의 스코프를 만들고 상위 스코프도 변형시키기 때문이다. 비용이 많이 드는 일들이다. 비용이 많이 드는 일은 대체로 최적화가 되는데 eval 은 그 최적화를 깨뜨린다. 보안문제도 있다. 사용자가 입력한 데이터는 untrusted data 라고 하는데, 이것은 한번 검사를 해야한다고 한다. eval이 받은 문자열을 바로 실행시켜버리니까 문제인듯하다. 그 안에 무슨 코드가 있을지 모르니까.  </p><p>(함수이름 짓는 팁: 빌트인메소드들 이름 따라하기)  </p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>객체에는 상태 데이터와 동작(메소드)이 있다고 했고, 동작인 메소드는 상태 데이터를 참조하고 변경할 수 있어야 한다. 메소드가 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.<br><strong>this</strong>는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 <strong>자기참조변수</strong>이다. <strong>this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정된다.</strong> 아무것도 신경쓰지말고 함수가 어떻게 호출되었느냐만 보면됨. 함수가 호출되어야 this 가 결정된다.<br><!-- (렉시컬 스코프는 함수정의가 평가될때 결정된다)  --></p><h3 id="다양한-함수호출방식"><a href="#다양한-함수호출방식" class="headerlink" title="다양한 함수호출방식"></a>다양한 함수호출방식</h3><ol><li>일반함수 호출 -&gt; this 는 기본적으로 window 를 가리키도록 세팅된 채로 시작한다.  </li><li>메소드 호출 -&gt; this 는 메소드를 호출한 객체를 가리킨다.  </li><li>생성자함수 호출 -&gt; this 는 생성될 인스턴스를 가리킨다.  </li><li>Function.prototype.apply/call/bind 메소드에 의한 간접 호출 -&gt; this를 명시적으로 바인딩  </li></ol><p>this는 객체의 참조를 얻기 위해 필요한 것이니까 전역이나 일반함수에서 this를 쓸 일은 없다. 그래서 엄격모드에서는 undefined를 내보낸다.  </p><p>메소드로 호출된 함수는 메소드를 <strong>호출한</strong> 객체를 가리킨다고 했다. 메소드를 <strong>가지고 있는</strong> 객체가 아니다! this 가 무엇인지 확인할 때에는 무조건 함수가 <strong>어떻게</strong> 호출되었는지만 확인하면 된다. 즉시실행함수도 this 가 window 이다. 메소드 안의 중첩함수도 일반함수로 호출되었다면 this 는 window 이다.<br>그런데 중첩함수는 외부함수를 도와주는 함수이다. 외부함수 안에서만 딱 쓰겠다는 의지가 나타났다는 말이다. 그럼 외부함수가 메소드로 호출돼서 this 가 객체를 가리키는 상태라면, 중첩함수에서 this가 window로 바뀌는 것은 기대에 어긋난다. 그래서 필요하다면 this를 갈아끼워줄 수 있다. 외부함수에서의 this를 변수에 회피시켜놓고 쓸 수도 있지만, bind/apply/call 빌트인 메소드를 사용할 수도 있다. 위 목록 중 4번 항목을 말하는 것이다. </p><!-- 호출이라는 것은 외부의 인수를 함수내부로 밀어넣는 행위이기도 하다. bind(this) 는 바깥의 this를 bind에 넣어주는거고 그럼 this 가 foo 안에 있는거고, foo는 obj가 호출했으니까... this가 obj 가 된다. --><h3 id="apply-와-call"><a href="#apply-와-call" class="headerlink" title="apply 와 call"></a>apply 와 call</h3><p>함수를 호출하는 것이 주 역할인 것은 똑같고 인수를 전달하는 방식만 다른 메소드들이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">뫄뫄.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure></p><p>뫄뫄.apply(thisArg) 일 때, 뫄뫄함수를 호출하면서 인자로 준 thisArg를 this로 바인딩해준다(간접호출도 해준다). 인수가 있을 때 인수도 전달할 수 있다. <code>[argsArray]</code> 는 함수에 전달할 인수 리스트 배열이다. 옵션이므로 생략 가능하다.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">뫄뫄.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>call 메소드도 첫 번째 인자를 this 로 바인딩해주고 간접호출까지 해주는 것은 같다. 하지만 인자를 전달하는 방식이 apply 와는 다르다. 배열의 형태가 아니라 하나씩 전달해야 한다.  </p><ul><li><em>apply 를 쓰는 팁</em><br>내가 자주 접하는 가변인자함수중에는 Math.max() 가 있다. 인수를 한 개, 두 개, 세 개 내 맘대로 전달할 수 있다.<br>Math.max() 의 문법은 <code>Math.max([값1[, 값2[, ...]]])</code> 이고 예제는 다음과 같다.  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">10</span>, <span class="number">20</span>);   <span class="comment">//  20</span></span><br></pre></td></tr></table></figure></li></ul><p>그런데 만약 내 숫자들이 배열 안에 들어있다면<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(arr); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p><p>배열을 통째로 넣어버리면 NaN이 나온다.  </p><p>Math는 this가 필요없는 정적메소드이다. 따라서<br><code>Math.max.apply(null, arr)</code> 이렇게 하면 arr라는 배열이 그대로 Math.max에 들어갈 수 있다.<br><code>Math.max(...arr)</code> ES6에서는 이 문법도 가능하다.  </p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>호출을 자동으로 해주진 않고, 사용할 객체를 this로 전달하는 것까지만 해준다.<br>코드 이해가 잘 안되니까 내일 다시 알아보고 업데이트 해야겠다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;전역객체&quot;&gt;&lt;a href=&quot;#전역객체&quot; class=&quot;headerlink&quot; title=&quot;전역객체&quot;&gt;&lt;/a&gt;전역객체&lt;/h2&gt;&lt;p&gt;우리가 만드는 게 아니라 브라우저 열자마자 전역객체가 만들어진다. 그 안에는 전역객체가 가지고있는 프로퍼티와 메
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
