<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rudy&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dearjsmc4.github.io/"/>
  <updated>2019-06-12T10:09:31.816Z</updated>
  <id>https://dearjsmc4.github.io/</id>
  
  <author>
    <name>Hwang Yu-Soon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>클로저</title>
    <link href="https://dearjsmc4.github.io/2019/06/07/0607/"/>
    <id>https://dearjsmc4.github.io/2019/06/07/0607/</id>
    <published>2019-06-06T15:00:00.000Z</published>
    <updated>2019-06-12T10:09:31.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="시작-전-예제"><a href="#시작-전-예제" class="headerlink" title="시작 전 예제"></a>시작 전 예제</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>-&gt; 스코프체인과 프로토타입체인은 따로따로 일하는게 아니라 식별자를 찾을 때 협력하는 관계이다.</p><h2 id="예제-2"><a href="#예제-2" class="headerlink" title="예제 2"></a>예제 2</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] += x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>foo 함수에 대한 평가가 이루어져서 arr 이 함수의 환경레코드에 등록된다.<br>for문 안의 변수가 var로 초기화 되는 것이었다면 함수의 환경레코드에 들어가겠지만(블록레벨스코프를 지원하지않으니까) let은 for문 안에서만 유효하기때문에 스코프도 for문으로 제한된다. 함수내부를 평가할 때 for문은 일단 지나쳐버리고, 함수내부를 실행할 때 arr에 배열을 할당해준다. (객체가 되어 할당된다)<br>현재 실행중인 실행컨텍스트는 foo 이다. for문을 만나면 for문에 대한 새로운 렉시컬환경을 만든다. 실행컨텍스트를 새로 만드는 게 아니다! 실행컨텍스트를 만드는 건 실행 가능한 코드의 4가지 종류(전역, 함수, eval, 모듈)만 만드는거다.<br>for문은 실행컨텍스트를 만들지 않고 for의 렉시컬환경만 만든다. 그리고 기존의 렉시컬환경(foo)을 새로운 렉시컬환경(for)으로 갈아끼우면서(함수 실행 컨텍스트가 기존에 foo의 렉시컬환경과의 관계를 끊고 블록 렉시컬 환경을 가리키게된다) 부자관계를 맺고(for의 외부환경참조가 foo의 렉시컬환경을 가리킨다) for문을 실행한 후, foo 함수의 렉시컬환경으로 되돌린다. -&gt; tc39 ecma 262 - 13.2.13 참고  </p><h2 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h2><p>클로저를 배워야하는 이유 : 정보은닉보다는 <strong>안전한 상태유지</strong>가 주 목적이다.<br>근데 왜 상태유지를 클로저로 해야할까?<br>-&gt; 전역변수로 상태유지를 할 수도 있지만 그건 안전하지가 않다. 왜냐면 아무나 고칠 수 있기 때문이다.<br><!-- 안전하다고 하려면 상태를 변경할 수 있는 자격이 필요하다.    --><br>안전하게, 라는 말을 빼고 상태유지를 하는 방법은 객체의 프로퍼티가 있음.<br>그러나 프로퍼티 역시 접근해서 상태를 바꿀 수도 있다. 객체의 모든 프로퍼티는 퍼블릭하다.<br>안전한 상태유지를 하고싶다면 클로저를 써야 한다.<br>&lt;!–<br>실행컨텍스트의 관점에서 이해하고 설명할 수 있어야한다.</p><p>요즘은 내부함수가 아니라 중첩함수(nested function) 이라고 하는 추세이다. –&gt;</p><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  innerFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outerFunc(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>전역코드가 평가되어 x와 outerfunc이 등록된다.<br>outerfunc가 실행되면 실행컨텍스트에 함수 실행컨텍스트 스택이 쌓이고 렉시컬환경과 환경레코드가 생기고 x와 innerfunc가 등록된다. 함수 내부가 실행되면 x에 10이 할당되고, innerfunc가 호출된다. inner함수의 실행컨텍스트가 스택에 쌓이고, inner가 현재 실행중인 실행컨텍스트가 된다. x를 바라볼때, 현재 실행중인 실행컨텍스트의 렉시컬환경의 환경레코드에서 찾는다. inner에 없으니 외부환경참조를 타고 outer로 가서(이것이 스코프체인), outer의 렉시컬환경의 환경레코드에서 찾아서 출력한다. </p><h3 id="외부환경참조"><a href="#외부환경참조" class="headerlink" title="외부환경참조"></a>외부환경참조</h3><p>함수가 호출되기전에 평가되고 함수객체가 만들어진다. 평가될 때, 실행 중인 전역실행컨텍스트의 <strong>렉시컬환경</strong>(상위스코프)을 <code>[[environment]]</code> 내부슬롯에 넣는다. -&gt; 자신이 정의된 위치에 의거해서 이미 결정되어진다. 모든 함수객체는 <code>[[environment]]</code>를 가지고 있다. 렉시컬환경도 객체니까 그 참조값을 가지고 있다. 함수 객체가 소멸되지 않는한 상위스코프 참조는 사라지지않는다. 그러니까 상위스코프도 절대 죽지않는다. 왜냐면 살아있는 중첩함수에 의해 상위스코프 참조가 끊어지지 않았기 때문에, 가비지컬렉터가 없애지않는다. 상위함수는 죽어도 그 상위함수의 렉시컬환경은 살아있다.  </p><ul><li>함수 평가 -&gt; 함수객체만들어짐 -&gt; 실행중인 실행컨텍스트의 렉시컬환경을 상위스코프로 결정</li><li>함수 실행 -&gt; 실행컨텍스트가 스택에 쌓이고, 렉시컬환경과 환경레코드의 내용이 실행하면서 채워진다.</li></ul><h3 id="모든-함수는-클로저"><a href="#모든-함수는-클로저" class="headerlink" title="모든 함수는 클로저?"></a>모든 함수는 클로저?</h3><p>모든 함수는 자신이 정의된 위치에 의해 자신의 상위스코프를 <code>[[environment]]</code>내부슬롯에 저장한다.<br>모든 함수는 상위스코프를 다 기억한다.<br>모든 함수는 이론적으로 다 클로저다.<br>클로저의 정의는, <strong>상위스코프를 만든 함수가 없어져도 상위스코프를 참조할 수 있다</strong>면 다 클로저라고 한다.<br>전역실행컨텍스트는 소멸하지않으니까 의미가 없지만, 만약 전역실행컨텍스트도 소멸한다고하면 전역함수도 자신의 상위스코프를 들고다니기때문에 다 클로저이다. 전역함수의 상위스코프는 전역렉시컬환경이다.<br>그러나,<br>만약 상위스코프의 식별자를 참조할일이 없다면 최신브라우저는 굳이 상위스코프를 기억하지않는다. 의미가 없기 때문이다.<br>클로저라고 부르지도 않는다.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 일반적으로 클로저라고 하지 않는다.</span></span><br><span class="line">  <span class="comment">// bar 함수는 클로저였지만 곧바로 소멸한다.</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 상위 스코프의 식별자를 참조한다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>위와 같은 경우는 foo 가 죽었을때 bar도 같이 죽기때문에, 클로저였지만 클로저라고 하지않는다.<br>실질적인 클로저의 조건은 즉,  </p><ol><li>상위스코프의 식별자를 하나라도 참조해야하며  </li><li>상위스코프보다 생명주기가 길어야한다.  </li></ol><h2 id="클로저의-활용"><a href="#클로저의-활용" class="headerlink" title="클로저의 활용"></a>클로저의 활용</h2><p>최신 상태를 안전하게 유지하는 것이 본질적 목표이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $counter = <span class="built_in">document</span>.querySelector(<span class="string">'.counter'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increase = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 카운트 상태를 유지하기 위한 자유 변수</span></span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $counter.textContent = ++num; <span class="comment">// 상태 변경</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.increase'</span>).onclick = increase;</span><br></pre></td></tr></table></figure></p><p>이때 increase함수는 caller가 없다.<br>브라우저가 온클릭이벤트 발생시에 호출해준다. 클릭이벤트가 발생하면 이벤트큐에 함수객체가 들어갔다가, 스택이 비면 실행된다.<br>한번 클릭해서 더하기를 했다가 소멸되고, 클릭하면 다시 실행컨텍스트가 생기고 또 실행하고 소멸되고. 생기고 소멸되고의 반복. 상위스코프는 한번 생긴 후로 사라진적이 없으므로 num은 유지된다. 왜냐면, increase라는 변수에 함수를 담아놓았기 때문에.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// num: 0, // 프로퍼티는 public이므로 정보 은닉이 되지 않는다.</span></span><br><span class="line">        increase() &#123;</span><br><span class="line">          $counter.textContent = ++num; <span class="comment">// 상태 변경</span></span><br><span class="line">        &#125;,</span><br><span class="line">        decrease() &#123;</span><br><span class="line">          <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">          $counter.textContent = --num; <span class="comment">// 상태 변경</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><p>리턴은 한번만 할수있기에 자료구조에 다 담아서 한번에 리턴할 수 있다. 이때 리턴되는 자료구조, 즉 객체는 리턴되기 직전에 객체가 된다. 그 안에 리턴될 메소드들은 객체로 만들어질때 같이 만들어진다. 리턴되는 객체는 스코프를 만들지않는다! 스코프가 객체 내에서 만들어지지는 않는다. 메소드들이 자신의 상위스코프를 기억한다. 리턴되는 함수들의 상위스코프는 객체가아니라 <strong>리턴하는 함수의 렉시컬환경</strong>이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $counter = <span class="built_in">document</span>.querySelector(<span class="string">'.counter'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ① 카운트 상태를 유지하기 위한 자유 변수</span></span><br><span class="line">      <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this.num = 0; // ② 프로퍼티는 public이므로 정보 은닉이 되지 않는다.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Counter.prototype.increase = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $counter.textContent = ++num;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      Counter.prototype.decrease = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        $counter.textContent = --num;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Counter;</span><br><span class="line">    &#125;());</span><br></pre></td></tr></table></figure><p>counter를 찾고, prototype은 프로토타입체인에서 찾아서 increase를 추가하는데. 이 increase 함수의 상위스코프도 현재 실행중인 실행컨텍스트, 즉 즉시실행함수의 렉시컬환경이다.  </p><!-- ## 함수형 프로그래밍변수 사용 지양을 통한 상태변화의 최소화.객체는 참조가 공유되기때문에 변경에 영향을 받고 추적이 어렵다-> 객체를 얼려서 이뮤터블하게 쓴다 -> 딥카피해서 넘기고 얼린다 다른애들이 변경못하게이런 것을 추구하는게 함수형 프로그래밍함수는 지역변수가 아닌 외부상태를 절대 변경하지말아야한다 -> 순수함수 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;시작-전-예제&quot;&gt;&lt;a href=&quot;#시작-전-예제&quot; class=&quot;headerlink&quot; title=&quot;시작 전 예제&quot;&gt;&lt;/a&gt;시작 전 예제&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>실행컨텍스트</title>
    <link href="https://dearjsmc4.github.io/2019/06/05/0605/"/>
    <id>https://dearjsmc4.github.io/2019/06/05/0605/</id>
    <published>2019-06-04T15:00:00.000Z</published>
    <updated>2019-06-12T10:09:31.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="실행-컨텍스트"><a href="#실행-컨텍스트" class="headerlink" title="실행 컨텍스트"></a>실행 컨텍스트</h2><p>컨텍스트는 문맥이라는 뜻. 코드에도 맥락이 있다.<br><!-- 식별자하면 선언이라는 키워드를 떠올려야함.(단, 프로퍼티는 식별자라고 잘 불리지않음. 식별자는 스코프체인에서 찾지만,프로퍼티는 프로토타입체인에서 찾기때문) --><br>실행 컨텍스트는 <strong>자바스크립트엔진의 동작원리</strong>와 밀접한 관련이 있다.<br>모든 실행 가능한 코드는 우선 평가 과정을 거치면서 실행을 위한 준비를 해야한다. 실행 컨텍스트는 실행 가능한 코드를 평가하고 실행하기 위한 환경이다. 이 실행 컨텍스트는 코드 평가 과정에서 생성되고, 코드 내 선언문이 평가되어 그 결과가 실행컨텍스트에 등록된다.<br>실행 가능한 코드는 4가지 유형이 있다.  </p><ol><li>전역코드 - 전역에 존재하는 텍스트 코드.  </li><li>함수코드 - 함수 내부에 존재하는 텍스트 코드.  </li><li>eval 코드 - eval 함수에 인수로 전달된 텍스트 코드.  </li><li>모듈코드 - 모듈 내부에 존재하는 텍스트 코드.  <!-- 우리는 전역코드와 함수코드에 집중하자. 코드별로 컨텍스트가 따로다.   --></li></ol><h3 id="전역코드"><a href="#전역코드" class="headerlink" title="전역코드"></a>전역코드</h3><p><strong>전역스코프</strong>를 생성하고 전역객체와 연결되어야 한다.<br>(전역객체는 브라우저를 열자마자 생성되며, 프로퍼티와 메소드, WEB API, 변수들이 들어있다.)<br>var 키워드로 선언된 변수는 전역객체와 전역스코프에 들어가지만 let, const 는 전역스코프에만 들어간다<br>-&gt; 그래서 윈도우에서 참조못한다.<br>-&gt; declarative environment record 에 들어가있다.<br><!-- (전역 스코프와 전역 객체가 어떻게 다르더라...) --><br>전역코드평가를 통해 <strong>전역실행컨텍스트</strong>가 생성된다.  </p><h3 id="함수코드"><a href="#함수코드" class="headerlink" title="함수코드"></a>함수코드</h3><p><strong>지역스코프</strong>를 만든다. 지역스코프는 전역스코프를 가장 최상위로 하는 스코프체인의 일원으로 등록되어야 한다.<br>함수 코드가 평가되면 <strong>함수실행컨텍스트</strong>가 생성된다.</p><p>두 코드는실행컨텍스트의 내용, 즉 하는 일이 다르다. </p><ul><li><p>평가와 실행은 다르다<br>어떤 코드가 실행되기 위해서는 평가단계를 거친다. 평가의 아웃풋이 실행컨텍스트이다. 평가를 하면 실행컨텍스트가 만들어진다. 선언문들만 뽑아서 먼저 실행하는걸 코드평가라고 한다 -&gt; 변수선언때 배웠다!<br>실행컨텍스트를 만들어서 선언문을 실행한 결과로 만들어진 식별자를 등록한다.<br>그리고 런타임이 시작돼서 선언문을 제외한 코드가 실행 된다. -&gt; 값이 할당되고 연산도 가능해진다  </p></li><li><p>변수의 선언과 할당을 실행 컨텍스트로 이해하기<br>전역 코드가 평가될 때 전역 실행컨텍스트가 생성되고 x라는 식별자를 등록한다. 전역실행컨텍스트를 객체라고 생각하자. 실제로 객체이기도 하고. 그 안에 프로퍼티와 값이 있다. 식별자 x만을 등록할 순 없고 값을 줘야하는데, 할당 전에 먼저 undefined를 값으로 넣어둔다. 그게 호이스팅이었다!<br>할당은 식별자와 값을 바인딩하는 것이다. 그럼 먼저 식별자를 찾아야 하는데, 전역실행컨텍스트에서 식별자를 찾는다. 만약 없다면 레퍼런스에러가 난다. 식별자를 찾은 후엔 값을 할당한다. 할당이라는 코드실행결과 역시 실행컨텍스트에서 관리된다. 사실 이보단 더 복잡하지만.. 일단 개요를 말하자면 그렇다.<br>변수를 선언한다는 건, 변수명을 실행컨텍스트에 등록하여 자바스크립트엔진이 관리하도록 하는 것이다.<br>-&gt; (실행컨텍스트야 너가 이 식별자 좀 가지고 있어 관리좀 하게) </p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전역 변수 선언</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 지역 변수 선언</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 메소드 호출</span></span><br><span class="line">  <span class="built_in">console</span>.log(a + x + y); <span class="comment">// 130</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line">foo(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(x + y); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>전역객체가 일단 존재하고, 전역코드가 평가되면 전역실행컨텍스트가 생성된다. 전역의 const 변수 x, y 선언문을 평가하여 실행컨텍스트에 등록한다. foo 함수 선언문을 평가하여 foo 함수 객체를 등록한다(이때 내부 코드는 아직 평가되지 않았다!).<br>코드가 실행되면 전역 const x, y에 1, 2를 할당하고 foo 함수를 건너뛰어 foo 함수 호출문으로 간다. 함수가 호출되어 함수 내부로 들어간다. 이제 함수코드가 평가되고 함수실행컨텍스트가 만들어진다. x, y, a를 등록한다. <strong>(arguments 객체도 있다!)</strong> 함수코드가 실행이 되면 10, 20, 100 을 할당하고 콘솔로그를 찍으러 간다. 콘솔은 전역객체에서 찾을 수 있다. 함수 실행컨텍스트에서 모든 식별자를 참조할 수 있으므로 130이라는 결과가 출력된다. foo 함수 실행이 끝나면 전역코드로 나와 콘솔을 실행한다. 이때는 전역실행컨텍스트에서 x, y 를 찾아 3이 출력된다.  </p><h2 id="실행컨텍스트-스택"><a href="#실행컨텍스트-스택" class="headerlink" title="실행컨텍스트 스택"></a>실행컨텍스트 스택</h2><p>전역 코드를 실행할 때 함수 호출을 만나면 전역 코드 실행을 멈추고 함수 코드를 실행한다. 함수 코드를 실행하고 나면 다시 전역 코드로 돌아와야 하는데, 어떻게 돌아올까? 멈춘 곳에서부터 다시 코드를 실행하는 매커니즘이 실행 컨텍스트 스택이다.<br><!-- (이거 콜스택이야!) --><br>평가 전에 이미 전역객체는 실행 컨텍스트 스택에 만들어져 있다. 그래야 평가했을때 var 변수를 전역객체의 프로퍼티로 넣을 수 있으니까. 그리고 항상 스택의 맨 밑에 깔려있다. 전역실행컨텍스트은 종료될 수 없고, 브라우저를 끄지않는 한 살아있다. 스택의 맨 위에 있는 실행컨텍스트는 현재 실행중인 실행컨텍스트이다. 이렇게 스택에 쌓이는 매커니즘으로 자기가 어디로 돌아가야 할지를 알게된다. 현재 실행중인 실행컨텍스트, 즉 최상위의 실행컨텍스트가 실행을 마치고 사라지면 그 다음 실행컨텍스트로 컨트롤이 이동하는것이다.  </p><h2 id="렉시컬-환경-중요"><a href="#렉시컬-환경-중요" class="headerlink" title="렉시컬 환경(중요)"></a>렉시컬 환경(중요)</h2><p>이것이 바로 스코프. 실행 컨텍스트가 하나의 심플한 객체로 만들어진 게 아니라 복잡한 구조로 만들어져있다. 식별자가 선언되는 환경. 좀 더 정확히 얘기하면 환경레코드가 스코프이다. 렉시컬환경은 실행컨텍스트 소속이다.  </p><p>실행 컨텍스트는 <strong>LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트</strong>로 구성된다. 실행컨텍스트가 이 두 개의 프로퍼티를 가지고 있다. 처음엔 동일한 렉시컬환경객체를 가리킨 상태에서 시작함. 렉시컬환경은 3개의 프로퍼티를 가진다.  </p><ol><li>환경레코드: 식별자와 값을 관리한다  </li><li>외부렉시컬환경에대한참조: 상위스코프에 대한 참조 -&gt; 클로저와 연결  </li><li>this바인딩: 메소드를 이용한 this 결정  </li></ol><pre><code class="javascript"><span class="keyword">var</span> x = <span class="number">1</span>;<span class="keyword">const</span> y = <span class="number">2</span>;<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>{  <span class="keyword">var</span> x = <span class="number">3</span>;  <span class="keyword">const</span> y = <span class="number">4</span>;  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">b</span>) </span>{    <span class="keyword">const</span> z = <span class="number">5</span>;    <span class="built_in">console</span>.log(a + b + x + y + z);}  bar(<span class="number">10</span>);}foo(<span class="number">20</span>); <span class="comment">// 42</span></code></pre><p>함수는 자기가 정의된 곳에서 평가 된다. 어디에서 정의되었는지에 따라 상위스코프가 결정된다.<br>함수가 상위스코프를 기억하는 방법? -&gt; 함수가 평가될 때 실행중인 실행컨텍스트를 기억한다.<br>-&gt; 이것을 외부렉시컬환경참조에다가 넣는다<br>bar는 foo가 평가될 때 만들어진다. 함수는 객체니까 프로퍼티가 있고, 외부에 공개되지않는 <code>[[environment]]</code>라는 내부슬롯에 자기의 상위스코프를 항상 들고다닌다 -&gt; 이것이 클로저<br>자기의 직속상위스코프만 알고있으면 더 위의 스코프까지 알 수 있다.<br>이론적으로 자바스크립트의 모든 함수는 자신의 상위스코프를 기억하는 클로저이다.  </p><!-- 화살표함수는 this가 없고 렉시컬this를 참조할수있음.흡사 화살표함수.bind(this) 와 같다. 즉 상위의 this를 바인딩.할당을 위해 식별자를 찾을떄, 현재실행중인 실행컨텍스트에서 찾는다.연산을 위해 식별자를 찾을때 현재실행중인 실행컨텍스트에서부터 찾고, 없으면 현재실행컨텍스트의 외부참조를 따라 올라가서 찾는다.  -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;실행-컨텍스트&quot;&gt;&lt;a href=&quot;#실행-컨텍스트&quot; class=&quot;headerlink&quot; title=&quot;실행 컨텍스트&quot;&gt;&lt;/a&gt;실행 컨텍스트&lt;/h2&gt;&lt;p&gt;컨텍스트는 문맥이라는 뜻. 코드에도 맥락이 있다.&lt;br&gt;&lt;!-- 식별자하면 선언이라는 키워
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>DOM, 동기식 &amp; 비동기식, 이벤트</title>
    <link href="https://dearjsmc4.github.io/2019/05/23/0523/"/>
    <id>https://dearjsmc4.github.io/2019/05/23/0523/</id>
    <published>2019-05-22T15:00:00.000Z</published>
    <updated>2019-06-09T12:57:17.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>트리를 만든다 -&gt; 부자관계가 있다.<br><strong>DOM 트리</strong> : html 텍스트문서를 파싱한 결과로, 메모리에 들어가있는 트리모양의 자료구조.<br>우리가 작성한 구조 안에 돔트리를 컨트롤 할 수있는 DOM API가 있다면 자바스크립트파일을 실행할 때 그것들을 조작할 수 있다. 직접 메모리에 접근하여 돔트리구조 자체를 바꿔버린다 -&gt; 화면을 다시 그려야함 -&gt; 비용이 든다!<br>우리는 SPA(single page application) 로 개발을 할 것이다. html을 딱 하나만 만든다는 것. html 코드의 조각들은 자바스크립트 내부에 들어가있다. -&gt; 앵귤러 리액트 (뷰) 가 이런 일들을 위한 것. 페이지를 리페인팅하는 비용은 적게 들고 퍼포먼스 올리고…<br>모던웹개발에서는 SPA를 만들때 프레임워크를 쓰는 것이 좋다.  </p><ul><li><p>html 태그안에 들어있는 <strong>어트리뷰트</strong>는 왜 어트리뷰트인가?<br>어트리뷰트는 초기값. 변하지 않는다. -&gt; 인풋의 타입이나 밸류는 태그 안에서 지정한 그대로다.<br>프로퍼티는 변한다 -&gt; 브라우저에서 인풋에 내용을 넣으면 프로퍼티 밸류가 바뀐다 -&gt; 상태<br>이 상태는 돔요소가 가지고 있다.  </p></li><li><p><strong>노드</strong>: 돔트리상의 하나하나의 가지 -&gt; 엘리먼트라고도 한다.<br>문서노드(진입점), 요소 노드, 텍스트노드, 어트리뷰트 노드 등이 있다.  </p></li><li><p>HTMLCollection &amp; NodeList<br><code>document.querySelector()</code>로 불러올 때는 NodeList라는 자료구조에 담아서 가져온다 -&gt; Non live<br>get 종류의 메소드로 불러오면 <code>HTMLCollection</code> 에 담겨서 온다 -&gt; live (실시간으로 바뀐다)<br>HTMLCollection은 유사배열객체이다. NodeList도 유사배열객체.<br>가져온 유사배열 객체를 elem 이라는 변수에 담았다고 했을 때,  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...elems].forEach(<span class="function"><span class="params">elem</span> =&gt;</span> elem.className = <span class="string">'blue'</span>);</span><br></pre></td></tr></table></figure></li></ul><p>유사배열객체를 배열로 반환하면 배열고차함수를 사용할 수 있다.  </p><!-- id는 전역에 변수로 남아버린다. id를 많이 줄수록 변수도 많아지는것! --><h2 id="동기식-amp-비동기식"><a href="#동기식-amp-비동기식" class="headerlink" title="동기식 &amp; 비동기식"></a>동기식 &amp; 비동기식</h2><p>동기라는건 순서가 보장된다는 뜻이다.<br>반대로 비동기는 실행 순서가 보장되지 않는다.<br><!-- 비동기함수인 셋타임함수를 누가 호출하는가? 0초 경과 후에 콜백함수를 누가 호출? --></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'func1'</span>);</span><br><span class="line">  func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'func2'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  func3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'func3'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1();</span><br></pre></td></tr></table></figure><p>함수가 종료된다는 건 콜스택에서 빠진다는 말이다.<br>setTimeout 함수는 0초가 경과했는지를 검사해야하고, 0초가 경과하면 tick 이라는 이벤트가 발생하는데<br>그때 셋타임은 이벤트큐로 들어간다(큐는 선입선출이고 콜스택은 후입선출이다). 그리고 콜스택이 비었는지를 이벤트루프가 돌면서 체크하다가 콜스택이 비면 이벤트큐에서 이벤트를 갖다가 콜스택에 넣는다. 즉 동기함수들이 모두 끝난 후에 가장 마지막에 실행된다.</p><p>자바스크립트는 콜스택이 1개이고, 단일스레드이고, 병렬처리가 안 된다.<br>그러나 워낙 고속이다보니 한번에 여러 일을 하는것처럼 보일뿐이다.<br>함수를 잘게잘게 나누라는것도 이런 이유때문이다. 빨리 실행하고 버리게.  </p><h2 id="이벤트"><a href="#이벤트" class="headerlink" title="이벤트"></a>이벤트</h2><ul><li>이벤트를 등록하는 세 가지 방법  </li></ul><ol><li>html 태그 안에 직접 함수를 호출 -&gt; html과 js는 분리하도록 하자…  </li><li><strong>on 프로퍼티</strong>를 이용한다. 원래 값이 null 인 상태인데 여기다 이벤트를 우리가 달아주면 된다.<br><code>btn.onclick = function foo() {}</code> -&gt; 이벤트 핸들러 프로퍼티 방식<br>여기서 foo 는 메소드이다. 프로퍼티의 값이 함수면 메소드니까.<br>이벤트 핸들러를 하나밖에 달 수 없다. 두 개를 달면 덮어쓴다. html요소에만 쓸 수 있다.  </li><li><strong>addEventListener 메소드</strong> 방식. 요소 선택 후에 <code>btn.addEventListener(&#39;click&#39;, function () {})</code> 이런 식으로 호출. 이때 인수로 함수를 주는거니까 콜백으로 주는 것이다. 클릭 이벤트가 발생하면 함수호출해달라는 뜻. html요소뿐 아니라 모든 돔요소에서 동작한다. 돔요소를 지정해주지 않으면 전역 어디에서든 이벤트가 동작한다.  </li></ol><p>이벤트가 시작되면 window에서부터 시작해서 지정된 요소까지 타고 내려간다 -&gt; 캡처링<br>요소를 찍고 다시 window로 거슬러 올라간다 -&gt; 기본값은 버블링  </p><p>이벤트객체: (e)  </p><p><strong>이벤트타겟!!!</strong><br>실제로 이벤트를 발생시킨 요소에 대한 참조.<br>버튼이 여러개일때 내가 누른 ‘그’ 버튼을 참조한다.<br><!-- e.target 는 애드이벤트리스너 안에서 this와 같다. 애드이벤트리스너 앞에 있는 요소. --></p><p><strong>이벤트 위임</strong><br>div에 이벤트를 걸고, div 안에서 어떤 버튼이 이벤트를 발생시켰는지를 e.target과 버블링을 이용하여 잡아낸다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DOM&quot;&gt;&lt;a href=&quot;#DOM&quot; class=&quot;headerlink&quot; title=&quot;DOM&quot;&gt;&lt;/a&gt;DOM&lt;/h2&gt;&lt;p&gt;트리를 만든다 -&amp;gt; 부자관계가 있다.&lt;br&gt;&lt;strong&gt;DOM 트리&lt;/strong&gt; : html 텍스트문서를 파
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>클래스, 디스트럭처링, 모듈</title>
    <link href="https://dearjsmc4.github.io/2019/05/22/0522/"/>
    <id>https://dearjsmc4.github.io/2019/05/22/0522/</id>
    <published>2019-05-21T15:00:00.000Z</published>
    <updated>2019-05-23T04:58:06.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h2><p>자바스크립트는 클래스가 필요없이 프로토타입과 클로저 등으로 객체 지향 프로그래밍이 가능하다. 하지만 클래스 기반 언어에 익숙하다면 자바스크립트의 프로그래밍 방식이 혼란스러울 수 있다. 그래서 자바스크립트에도 클래스처럼 동작하는 클래스가 생겼다. 생성자 함수보다 더 엄격하다.  </p><p>클래스 <strong>선언은 런타임 전에</strong> 이루어진다. 선언 이전에 참조하면 참조에러가 난다. let과 const처럼 일시적 사각지대에 빠진다. 호이스팅이 되지만 안 그런 것처럼 보인다.<br><!-- 클래스는 왜 함수와 비슷하게 동작할까? 클래스는 함수이기때문에... --></p><p>클래스 내부에 생성자함수와 유사한 역할을 하는 <strong>constructor</strong>가 있다. 만약 생략하면 자바스크립트엔진은 constructor가 있는 것처럼 생각하고 호출하며 빈 객체를 만든다. <strong>new 연산자로 호출</strong>하면 constructor 가 호출된다(가장 먼저, 단 한 번). 그리고 프로퍼티 정의를 해준다.  </p><p>클래스에서 메소드는 프로토타입을 써주지 않아도 <strong>기본적으로 프로토타입 메소드</strong>이다. 객체 리터럴에서 메소드를 선언하면 그 메소드는 객체리터럴의 것이지만 클래스에서는 인스턴스의 프로토타입의 것이다. 문법이 더 함축적이다.  </p><p>클래스에서는 우리가 프로퍼티라고 부르던 this <strong>.name</strong> 을 <strong>클래스필드</strong>라고 부른다. 멤버, 필드, 클래스필드, 인스턴스변수 등등으로 불리기도 한다. constructor는 객체를 직접 생산하고 프로퍼티를 초기화한다. 마치 생성자함수처럼 동작한다. constructor는 인수를 꼭 받을 필요는 없다. 인스턴스마다 다른 값을 가져야하는 프로퍼티가 있다면 그때 전달해주면 된다. 함수도 파라미터 정의할 때 무조건 지정해두진 않으니까.  클래스필드는 constructor 안에서 정의해야한다. constructor의 매개변수를 name = ‘’ 으로 초기화해두면 undefined 가 아니라 빈 문자열이 나온다.  </p><!-- ecmascript는 누가 관리하고 누가 버전업하는가? 세계 각국에 있는 사람들이 표준화를 요청하면 tc39라는 위원회의 위원들이 관리. 심의하여 올라온 안건들을 검토하여 4단계까지 올라오면 다음 ecmascript의 표준으로 들어간다. 3까지만 올라와도 거의 통과이긴 함. 클래스필드도 생성자 안에 써야하는데 밖에 쓰는게 거의 4단계로 올라왔기때문에 곧 표준될듯.  --><h3 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter / setter"></a>getter / setter</h3><ul><li><p><strong>getter</strong> : 데이터프로퍼티에 <strong>접근</strong><br>함수 호출처럼 쓰는 게 아니다. 반드시 무언가를 반환한다. 데이터를 가지고 있지않다. 다른 프로퍼티의 데이터를 가지고 무언가를 해서 반환한다.  </p></li><li><p><strong>setter</strong> : 데이터프로퍼티에 값을 <strong>셋팅</strong><br>셋팅을 하기위해 인수를 받는다. 반환하지 않는다.  </p></li></ul><h3 id="정적메소드"><a href="#정적메소드" class="headerlink" title="정적메소드"></a>정적메소드</h3><p><strong>this를 쓰지않는</strong> 메소드. hasOwnProperty 같은 프로토타입 메소드는 내부에서 꼭 this를 쓴다.<br>static은 클래스에서만 쓸 수 있는 키워드이며 정적메소드를 뜻한다. 정적메소드는 생성자함수에 존재한다. 생성자함수에 놓은 의도는? 인스턴스 없이 호출할 수 있도록 만들어놓은 것. Math 객체를 떠올려보자. 비슷한 일들을 하는 메소드들을 모아놓은 객체였고, 인스턴스로 호출하지 않고 Math 객체에 직접 접근하여 사용할 수 있었다.  </p><h3 id="클래스-상속"><a href="#클래스-상속" class="headerlink" title="클래스 상속"></a>클래스 상속</h3><p><strong>extends 키워드</strong>는 부모클래스를 상속받는 자식클래스를 정의할 때 사용한다.<br>-&gt; <code>class 자식클래스 extends 부모클래스</code><br>프로토타입 기반일 때에는 상속 관계를 동적으로 결정할 수 있지만 클래스에서는 상속관계를 미리 결정해놓아야 한다. 자식클래스는 constructor 내에 부모를 나타내는 <strong>super 키워드</strong>가 있다. 부모클래스를 참조하거나 부모클래스의 생성자를 호출한다. super()는 부모의 생성자를 호출하며, new 연산자로 자식클래스의 인스턴스를 생성하면 호출된다. super 호출을 안하면 this를 쓰지 못한다.</p><!-- 실린더는 서클을 상속받는다 -> 프로토타입체인을 구성한다부모클래스가 정의가 되었다자식클래스는 반지름과 높이를 매개변수로 받는다부모클래스의 생성자함수를 호출하며 반지름을 인수로 준다 -> 반지름은 부모클래스꺼를 갖다씀나(자식)만의 높이 클래스필드를 갖는다. 부모클래스의 생성자함수로 인해 물려받은 getArea 메소드를 오버라이딩한다클래스 안의 메소드는 인스턴스의 것이 아니라 프로토타입의 메소드다.아 실린더 생성자함수의 프로토타입은 실린더.프로토타입일테고 이것은 인스턴스의 프로토타입이니...인스턴스는 높이만 가지고있고 실린더.프로토타입에 메소드가 들어간다.  super.getPerimeter() -> 무조건 내 부모의 메소드를 참조하겠다는 명시적 의미 실린더는 빈객체를 만들지않는다this 는 수퍼가 만든다수퍼를 호출한다 - 부모가 만든 인스턴스를 실린더가 만들 this에 바인딩 -> 참조를 준다?만약 자식클래스만의 this.height 같은 것이 없으면 super의 this를 쓰기때문에 수퍼를 안 쓰면 this참조가 안된다?  --><!-- super(radius) 수퍼의 생성자가 호출되며 상속관계를 맺게된다서클생성자함수가 평가될때 서클프로토타입은 만들어지겠지만 실린더 프로토타입과의 관계는 없을수있다그것을 명시적으로 맺어준다? --><h2 id="디스트럭처링"><a href="#디스트럭처링" class="headerlink" title="디스트럭처링"></a>디스트럭처링</h2><h3 id="배열-디스트럭처링"><a href="#배열-디스트럭처링" class="headerlink" title="배열 디스트럭처링"></a>배열 디스트럭처링</h3><p><code>const [one, two, three] = arr;</code><br>이것은 배열이 아니라 const로 세 개의 변수를 선언하여 arr를 순차적으로 부숴서 할당. 반드시 뒤에 할당을 해주어야한다. 대괄호를 쓴 것은 = 뒤에 배열이 온다는 것이고 중괄호면 객체가 온다는 것.  </p><h3 id="객체-디스트럭처링"><a href="#객체-디스트럭처링" class="headerlink" title="객체 디스트럭처링"></a>객체 디스트럭처링</h3><p><code>const { lastName, firstName } = obj;</code><br>두 개의 변수를 선언하고 이름이 같은 프로퍼티를 할당. 순서가 무의미하다.  </p><p><code>const { prop1: p1, prop2: p2 } = { prop1: &#39;a&#39;, prop2: &#39;b&#39; };</code><br>p1은 변수. a를 p1에 넣는다(키를 비교해서).  </p><h2 id="모듈"><a href="#모듈" class="headerlink" title="모듈"></a>모듈</h2><p>a.js, b.js, c.js 이렇게 세 개의 자바스크립트 파일을 하나의 html 파일에서 쓰면 세 파일이 하나의 전역을 쓴다. 한 파일에 있는거나 마찬가지다. 파일을 나눠야 역할분담이 되는데.. 나눠봤자인 것이다. 모듈은 파일단위로 분리되기 때문에 코드의 단위가 명확히 분리되고, 재사용성이 좋아서 개발 효율성과 유지보수성을 높인다. ES6 에서는 script 태그에 <code>type=&quot;module&quot;</code> 어트리뷰트를 추가하여 모듈로서 동작하는 자바스크립트 파일 사용이 가능하다. 이때 모듈로 만드는 js파일과 일반js파일이 헷갈릴 수 있으니 모듈확장자는 mjs로 쓰는게 권장사항이다.<br>그러나 아직 ES6를 지원하지않는 브라우저도 많으니 바벨과 웹팩을 써주는 것이 좋다고 한다.<br><!-- 바벨은 우리의 소스코드를 es5로 다운그레이드해서 구형브라우저에서 돌아갈수있게 도와준다.웹팩은 바벨이 컴파일한걸 하나로 묶으면서 압축해준다? -> 스크립트태그가 한개만 있어도된다!그리고 웹팩 내부에서 모듈지원된다.  --></p><ul><li><p><strong>export</strong><br>자신의 파일 스코프 바깥으로 공개한다. 다른 모듈들이 사용할 수 있도록. 변수, 함수, 클래스 등 전부 export 할 수 있다. 그냥 식별자 앞에 export 를 붙여주면 된다. export 를 안 쓴다는건 공개하지 않겠다는 뜻이다. 반대 개념으로는 import. export 해봐야 import 하지 않으면 소용이 없다.<br>예를 들어 <code>export { pi, square, Person };</code> 라고 맨 밑에 적어주면 pi, square, Person 식별자를 하나의 객체로 구성해서 한 번에 export 가능하다.  </p></li><li><p><strong>import</strong><br>바깥으로 공개된 모듈을 로드한다. import할때에는 경로를 써줘야하는데, <code>import { export 한 이름 } from &#39;./lib.js&#39;</code> 와 같이 써준다. 브라우저 모듈에서는 파일확장자 생략이 불가하다. </p></li></ul><p><code>import * as lib from &#39;./lib&#39;;</code><br>lib라는 객체 안에 담아서 가져온다. 사용할 때 <code>lib.pi</code> 와 같은 형태로 사용한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;클래스&quot;&gt;&lt;a href=&quot;#클래스&quot; class=&quot;headerlink&quot; title=&quot;클래스&quot;&gt;&lt;/a&gt;클래스&lt;/h2&gt;&lt;p&gt;자바스크립트는 클래스가 필요없이 프로토타입과 클로저 등으로 객체 지향 프로그래밍이 가능하다. 하지만 클래스 기반 언어에
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>정규표현식, 배열고차함수, 화살표함수, Rest/Spread</title>
    <link href="https://dearjsmc4.github.io/2019/05/20/0520/"/>
    <id>https://dearjsmc4.github.io/2019/05/20/0520/</id>
    <published>2019-05-19T15:00:00.000Z</published>
    <updated>2019-05-22T10:37:59.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="정규표현식"><a href="#정규표현식" class="headerlink" title="정규표현식"></a>정규표현식</h2><p>Regular Expression, 줄여서 RegExp 라고 한다. 문자열에서 특정 내용을 찾거나 대체, 또는 발췌하는데에 사용한다. 반복문이나 조건문 대신 정규표현식을 쓰면 더 간단할 수 있지만 가독성이 좋지 않다.  </p><h3 id="플래그"><a href="#플래그" class="headerlink" title="플래그"></a>플래그</h3><p>플래그는 옵션이다.  </p><ul><li>i (Ignore Case) : 대소문자를 구별하지 않고 검색  </li><li>g (Global) : 문자열 내에서 모든 패턴 검색  </li><li>m (Multi Line) : 문자열의 행이 바뀌어도 계속 검색  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'Friday I am in love.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 대소문자를 구별하여 한 번만 검색 </span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/i/</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)); </span><br><span class="line"><span class="comment">// ["i", index: 2, input: "Friday I am in love.", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 대소문자를 구별하지 않고 전체 검색  </span></span><br><span class="line">reg = <span class="regexp">/we/ig</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)); </span><br><span class="line"><span class="comment">// (3) ["i", "I", "i"]</span></span><br></pre></td></tr></table></figure><h3 id="패턴"><a href="#패턴" class="headerlink" title="패턴"></a>패턴</h3><p>패턴에는 검색하고 싶은 문자열을 지정하며, 따옴표는 생략한다. 특별한 의미를 가지는 메타문자 또는 기호로 표현할 수도 있다.  </p><ul><li><code>.</code> : 문자 한 개를 검색  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'Friday I am in love.'</span>;</span><br><span class="line"><span class="comment">// . 은 문자 한 개를 의미한다.  </span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/.../</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br><span class="line"><span class="comment">// ... 패턴이므로 3자리 문자가 추출된다.  </span></span><br><span class="line"><span class="comment">// ["Fri", index: 0, input: "Friday I am in love.", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3자리 문자를 반복 검색  </span></span><br><span class="line">reg = <span class="regexp">/.../g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg));</span><br><span class="line">(<span class="number">6</span>) [<span class="string">"Fri"</span>, <span class="string">"day"</span>, <span class="string">" I "</span>, <span class="string">"am "</span>, <span class="string">"in "</span>, <span class="string">"lov"</span>]</span><br></pre></td></tr></table></figure><ul><li><code>+</code> : 지정 문자가 한 번 이상 반복되는 문자열을 검색  </li><li><code>|</code> : or 과 같은 기능을 한다.  </li><li><code>[]</code> : <code>[]</code> 내의 문자는 or 로 동작한다. 범위를 지정하려면 <code>-</code> 를 사용한다.  </li></ul><p>자주 쓰는 정규표현식은 스크랩해두는 것이 좋다.  </p><ul><li>match 메소드를 썼을 때 일치하는 결과가 없으면 결과가 null 이다.  </li></ul><h2 id="배열-고차-함수"><a href="#배열-고차-함수" class="headerlink" title="배열 고차 함수"></a>배열 고차 함수</h2><p>함수는 객체이며, 함수를 값처럼 쓸 수 있다고 했다. 그래서 함수는 일급객체이다. 함수형 프로그래밍에서는 클로저가 매우 중요하다. 클로저 적극사용!  </p><p>콜백함수는 그 함수를 인수로받은 함수가 자기가 원할때 호출한다.<br>함수는 자기가 정의될 때 상위스코프가 결정된다. 호출될 때가 아니다! 그리고 함수는 자기의 상위스코프를 언제나 기억하고 들고 다닌다. 상위스코프를 계속 참조하고 있으므로 가비지컬렉터가 지우지 않는다.  </p><p>고차함수는 1. 함수를 인수로 전달받거나, 2. 함수를 리턴하거나, 3. 둘 다 하는 함수를 말한다.<br>함수를 밖에서 만들어서 안으로 던져주는 건 함수를 합성하는 일이다. 전달된 함수의 도움을 받아 본 함수의 내용을 바꾼다. 즉, 바깥에서 주는 함수에 따라 함수의 동작이 달라진다. 본 함수는 그대로 있고 밖에서 일부함수만 던져주면 바뀌는 부분도 줄고 유지보수 하기 좋아진다.<br>고차함수는 가변 데이터를 피하고 불변성을 지향. 외부상태가 안 바뀌었으면 좋겠다는 것이다. 외부상태에 의존하지않고 외부상태를 변경하지않는 순수함수를 추구하는 것이 함수형 프로그래밍이고, 그런 매커니즘이 녹아있는 것이 고차함수.  </p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>정렬할 때 배열의 요소들을 내부적으로 문자열로 바꿔서 비교하기 때문에 숫자 정렬 시에 원하는대로 나오지 않을 수 있음. 유니코드 순서에 따라 정렬하기 때문에. 그래서 숫자정렬할때는 함수를 준다.  </p><p><code>function (a, b) { return a - b; }</code> 이 함수를 인수로 주면 오름차순이 되는데,<br>어떻게 이렇게 되는지 까볼 필요까지는 없고 그냥 받아들이라고(…)<br><code>function (a, b) { return b - a; }</code> 는 내림차순.  </p><p><code>a[key] &gt; b[key] ? 1 : (a[key] &lt; b[key] ? -1 : 0</code><br>-&gt; 숫자일때 문자일때 모두 적용할 수 있는 삼항연산  </p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>for문 대신 쓸 것.  </p><!-- 앞으로 forEach map reduce some find filter 등을 쓰고, for문은 금지.(근데 만번돌아야된다 그러면 성능상 for문 쓰겟지...)`map`, `filter`, `reduce` 를 잘 이해해야 한다.  --><p>forEach에 함수를 주고, forEach가 함수를 호출할 때 forEach는 자기가 호출한 함수에 인수를 줄 수 있다. <strong>배열 요소의 값, 그 요소값의 인덱스, this.</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  pows.push(item ** <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>각 요소(item) 에 대해 함수를 실행. 내부적으로 for문은 돌고있다. 함수는 요소(this)의 갯수만큼 실행되고, 함수를 호출한 객체가 인수를 넣어주는 것이다. 이때 this는 함수를 호출한 배열 자체이다. forEach는 반환값이 undefined. 즉, 리턴문이 없다. 리턴을 쓰면 무시한다. forEach는 모든 요소를 순회하면서 함수를 실행한다. for문처럼 거꾸로 돌리거나 한 칸 건너뛰고 돌거나 break 거는 것은 할 수 없다.<br>for문에서도 증감식에 i++ 나 i–는 되지만 2를 더하거나 곱하거나 하는 건 좋은 코딩이 아니다. 만약 1씩 증가한다고 생각하고 코드를 짜면 에러가 날 수도 있으니까. for문은 사람이 인식하기에 좋지 않은 문법이고 가독성이 안 좋다.<br>forEach안에서 브레이크를 쓰면 에러다. 브레이크는 어떤 조건에 충족 시에 순회를 중단하겠다는건데 그건 filter 로 해결이 가능하다.<br>this를 고칠 수 있는 능력은 forEach에게는 없고 콜백에게는 있다. 왜냐면 콜백은 세번째 인자로 this를 받을 수 있으니까.<br>forEach는 for문처럼 변수선언이나 조건식 증감식이 따로 필요가 없다.<br>forEach는 콜백함수를 일반함수로 호출한다. 그 때 콜백안에서의 this는 윈도우. forEach는 첫번째 인수로 함수를 주고, 두번째 인수로 this를 전달할 수 있다. 그럼 forEach를 호출한 객체가 this가 되어서 전달된다.  </p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>this와 똑같은 갯수의 리턴을 만들어내고 싶을 때 쓴다. 어떤 배열이 있고, 그것을 map 한다고 하면 반환한 배열의 요소들은 원본 배열과 매핑된다. 원본배열의 갯수를 초과하거나 적어지지 않는다. 매 요소마다 콜백함수를 실행하여, 그 결과값으로 이루어진 새로운 배열을 반환한다. 결과값을 새로운 배열에 담아서 리턴하는 것이다. 리턴은 새로운 배열에다가 결과값을 푸쉬하는 것과 같은 동작을 한다. 그 요소의 수는 원본과 반드시 일치한다. map의 활용도는 무지하게 높다! 얘는 반드시 함수를 실행한 뒤 리턴을 해줘야 한다. 만약 리턴하지않으면 빈 배열이 나온다. 그리고 새로운 배열을 반환하기 때문에 변수로 받아주어야 한다. 원본 배열을 수정하지 않는다. forEach처럼 순회하며 콜백을 실행하는 것은 똑같다. 인수로 받는 것들도 똑같다.  </p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>this배열에서 어떤 조건에 부합하는 요소들만으로 구성된 배열을 리턴한다. 따라서 이론상 this배열보다 리턴되는 배열의 요소의 수는 같거나 적을 수 있다. 원본배열을 수정하지 않는다. forEach가 for문을 대체할 수 있듯, filter는 if문을 대체할 수 있다. 리턴문에는 불리언으로 평가되는 표현식을 넣는다. if문이라고 생각하면 된다. 그 조건에 부합하는 요소들이 리턴된다.  </p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>값을 두 개를 가지고 함수를 실행하며, 이전 콜백에서 실행한 결과를 다음 콜백의 첫 인수로 넘겨준다.  </p><h3 id="그-외"><a href="#그-외" class="headerlink" title="그 외"></a>그 외</h3><ul><li>some : 배열 내의 일부 요소가 조건에 맞는지 확인하여 불리언 반환  </li><li>every : 배열 내의 모든 요소가 조건에 맞는지 확인  </li><li>find : 조건에 맞는 첫 요소를 반환<br>여기서 콜백의 매개변수로는 객체가 들어온다. 배열이 아니라 요소를 반환함  </li><li>findIndex : 조건에 맞는 첫 요소의 인덱스를 반환. 만약 find를 못 쓰면 filter를 쓰면 된다.  </li><li>Object.assign : 뒤에서 앞으로 머지.</li></ul><h2 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h2><p>인수를 함수 몸체 안으로 넘겨준다고 이해하면 된다. 호출할 때에는 함수 표현식을 사용한다. 화살표함수는 this가 없고, 함수가 <strong>정의될 때</strong> 자신이 정의된 상위스코프의 this를 승계받는다. 자기가 this를 가지고 있는 것이 아니다. 왜냐면 얘는 콜백함수로 쓰려고 만들었기 때문에. 그러면 콜백을 쓸 때 따로 this를 바인딩해주지 않아도 되니까.  </p><ul><li>this를 바인딩하는 방법 4가지.<br>that에 담거나<br>map의 두번째 인자에 주거나<br>bind를 주거나<br>화살표 함수를 쓴다.  </li></ul><p>화살표함수는 <code>[[constructor]]</code> 가 없다. 생성자함수로 만들 수 없다.<br>this도 없고 arguments도 없다.  </p><h2 id="Rest-파라미터-Spread-연산자"><a href="#Rest-파라미터-Spread-연산자" class="headerlink" title="Rest 파라미터, Spread 연산자"></a>Rest 파라미터, Spread 연산자</h2><ul><li><p>Rest 파라미터(…rest)<br>이걸 쓰면 arguments를 안 써도 된다. arguments는 유사배열객체이기 때문에 배열화 해서 써야했지만 rest를 쓰면 그럴 필요가 없다. rest파라미터는 단독으로 쓰이거나 맨뒤에 쓰여야한다.</p></li><li><p>spread 연산자<br>rest파라미터하고 헷갈리면 안 된다! -&gt; 얘는 풀린 걸 배열로 묶는다.<br>배열 앞에 … 를 찍으면 spread 연산자로서 동작하고 배열을 다 풀어버린다. 피연산자는 문자, 배열, map, set 등의 순회가능한 자료구조여야한다.<br>sperad연산자를 사용한 배열을 인수로 전달할 수 있다. apply대신 썼던 것을 기억하자.<br>배열을 배열 안에서 풀어서 concat처럼 쓸 수 있다.<br>[…array, 4,5,6] 처럼.</p></li><li><p>Rest/Spread 프로퍼티  </p></li></ul><p>Object.assign 을 대체할 수 있는 문법.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...&#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">// &#123; x: 1, y: 2, a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure></p><p>객체 리터럴 안에서 푸는 건 가능하다. 풀려 나와서 머지가 될 것이다.<br>객체를 병합하거나 특정 프로퍼티를 변경할 때 쓴다.<br>정식 표현이 아니므로 구형 브라우저에서 돌지 않는다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;정규표현식&quot;&gt;&lt;a href=&quot;#정규표현식&quot; class=&quot;headerlink&quot; title=&quot;정규표현식&quot;&gt;&lt;/a&gt;정규표현식&lt;/h2&gt;&lt;p&gt;Regular Expression, 줄여서 RegExp 라고 한다. 문자열에서 특정 내용을 찾거나 대체,
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Object.prototype 접근, 배열</title>
    <link href="https://dearjsmc4.github.io/2019/05/17/0517/"/>
    <id>https://dearjsmc4.github.io/2019/05/17/0517/</id>
    <published>2019-05-16T15:00:00.000Z</published>
    <updated>2019-05-20T10:45:40.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Disallow-use-of-Object-prototypes-builtins-directly-no-prototype-builtins"><a href="#Disallow-use-of-Object-prototypes-builtins-directly-no-prototype-builtins" class="headerlink" title="Disallow use of Object.prototypes builtins directly (no-prototype-builtins)"></a>Disallow use of Object.prototypes builtins directly (no-prototype-builtins)</h2><p><a href="https://eslint.org/docs/rules/no-prototype-builtins" target="_blank" rel="noopener">수업시간에 본 ESLint 원문</a>  </p><p>왜 직접 접근을 불허하는가?<br>Object 의 정체는 함수다. 타입오브 찍어보면 함수라고 나온다. 이 함수는 일반적으로 new 와 함께 호출하여 빈 객체를 만드는 역할을 한다. 그런데 <code>Object.</code> 해서 메소드를 쓸 수도 있다. 함수 자체가 가지고 있는 메소드가 있다는 것이다.<br>만약 인스턴스로 메소드를 호출하려고 했다면 Object.prototype 에 있는 메소드라고 생각했으니까 그렇게 했을텐데 나오지 않았다. 그럼 Object 함수에 있는 메소드라는 뜻이고, 이건 내가 Object 에 직접 접근해서 써야 한다. 인스턴스로 호출할 수 있느냐, 직접 접근해야 하느냐에 따라 프로토타입메소드, 정적메소드로 갈린다. 프로토타입메소드는 인스턴스가 반드시 있어야(인스턴스를 생성한 후) 호출이 가능하다. 정적메소드는 인스턴스가 없어도 호출이 가능하다.<br>인스턴스로 호출한 메소드는 this가 그 인스턴스이고, 프로토타입메소드는 코드내부에 this를 반드시 쓰게 되어있다.<br><!-- 아 만약 this를 안 써도 되는 메소드면 정적메소드로 쓰기를 추천한다는 말인가? --></p><ul><li><strong>Object.create() 정적메소드</strong> </li></ul><p>인수로 객체 또는 null 을 쓰게 되어있는, 객체를 만드는 방법 중 하나. 프로토타입을 지정하면서 객체를 만들 수 있다는 것이 특징이다. 인수로 넘겨준 객체를 인스턴스의 프로토타입으로 설정해준다.<br><strong>Object.create(null)</strong> 을 하면 아무것도 상속받지 못하는 객체가 되고 스스로가 프로토타입의 종점이 된다. 이 객체는 Object.prototype 으로부터 상속받았어야 하는 메소드를 사용할 수 없다. 그래서  </p><p><code>var hasBarProperty = Object.prototype.hasOwnProperty.call(foo, &quot;bar&quot;);</code>  </p><ol><li>hasOwnProperty 를 호출하고  </li><li>this를 foo 로 갈아끼우자   </li></ol><!-- foo를 object.prototype 으로 바꾸도록 하는것임! 그럼 결국 foo.hasOwnProperty 랑 똑같아짐.왜냐면 object.prototype은 항상있고, foo가 Object.prototype 의 메소드를 상속받지못했을 가능성때문에 이렇게 쓴다고?만약 그런 가능성이라면... foo.hasOwnProperty('bar') 를 했을 때 에러가 날테니까. 아예 메소드가 없으니까. 메소드자체를 불러올수가없는것이지. --><p>Object.prototype으로 호출하면 일단 call메소드가 그 앞에까진 실행을 해줄 것이고, foo를 this로 갈아끼워주면 hasOwnProperty 함수 내부에서 쓰는 this 가 foo로 바뀐다. 호출하는 주체가 foo 로 바뀐게 아니라, 호출은 Object.prototype이 하고, 메소드가 사용하는 this가 foo로 바뀐다.  </p><p>정적메소드에서 this가 필요없으니 null 을 주는건 그냥 의미없다는 뜻으로 준 것이다… 뭘 넣어도 되지만 그렇다고 100을 넣으면 뭔가 의미가 있어보이니까.  </p><h2 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h2><p>배열은 0개 이상의 요소를 콤마(,)로 구분한 자료구조. 배열 객체에는 length 프로퍼티가 있고, 즉 순회가능하다는 뜻이다. length는 요소의 개수를 반환해준다. 유일한 Array 프로퍼티이며 마지막 요소를 기준으로 반환한다. 배열은 타입오브를 찍으면 객체라고 나온다.<br>빈 배열의 0번째 요소는 undefined 를 가지고 있는 게 아니라 그냥 비어있는 empty이며 메모리도 안 잡는다.<br>객체의 프로퍼티는 굳이 삭제하지 않고 안 쓰고 놔두면 된다(지우는게 오히려 일이다).<br>배열은 지워야 할 때가 있을 수 있다. 그런데 delete 로 지우면 길이는 변함없고 그 자리를 empty로 비워둔다. 그래서 splice를 써야 한다. 그 자리까지 잘라낼 수 있도록.<br>순회할 때에는 for문이 가장 빠르지만, 모던프로그래밍은 빠른것 보단 가독성이 먼저이다.  </p><!-- for...in문은 객체의 프로퍼티를 순회할때 쓰는거라고함. 지금은 활용도 별로라고함그런데 단점이있어서 for...of 를 쓴다고.자바스크립트의 배열은 진짜 배열이 아니라 배열을 흉내낸 객체. --><ul><li><p>indexOf<br>인수로 준 요소의 인덱스값을 반환. 없으면 -1<br>같은 것이 두 개 있으면 처음 찾은 인덱스를 반환  </p></li><li><p>concat<br>원본을 바꾸지 않고 요소를 추가한 새로운 배열을 반환.<br>(push 대신 쓰면 되겠다)  </p></li><li><p>join<br>배열의 요소를 합쳐서 문자로 반환. 인수를 주면 인수를 사이사이에 넣어준다.  </p></li><li><p>slice<br>인수를 아무것도 안 주면 복사본을 생성한다.<br>유사배열객체인 arguments를 call을 통해서 slice 함수에 this로 할당하면<br>arguments가 유사배열일지라도 배열메소드인 slice를 사용할 수 있게 된다.<br>arguments를 slice로 복사하여 배열이 되어서 반환된 걸 변수에 넣어서 쓰면 된다.  </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Disallow-use-of-Object-prototypes-builtins-directly-no-prototype-builtins&quot;&gt;&lt;a href=&quot;#Disallow-use-of-Object-prototypes-builtins-dire
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>전역객체, this</title>
    <link href="https://dearjsmc4.github.io/2019/05/15/0515/"/>
    <id>https://dearjsmc4.github.io/2019/05/15/0515/</id>
    <published>2019-05-14T15:00:00.000Z</published>
    <updated>2019-05-15T11:08:43.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="전역객체"><a href="#전역객체" class="headerlink" title="전역객체"></a>전역객체</h2><p>우리가 만드는 게 아니라 브라우저 열자마자 전역객체가 만들어진다. 그 안에는 전역객체가 가지고있는 프로퍼티와 메소드, var 로 만든 전역 변수, 암묵적 전역변수, WEB API가 들어있다. window의 프로퍼티는 window.을 생략해도 된다.  </p><h3 id="eval-함수"><a href="#eval-함수" class="headerlink" title="eval 함수"></a>eval 함수</h3><p>안 배워도 되고 가르치지도 않으려고 하는 함수…<br>얘를 왜 안 쓰냐면, 자기자신만의 스코프를 만들고 상위 스코프도 변형시키기 때문이다. 비용이 많이 드는 일들이다. 비용이 많이 드는 일은 대체로 최적화가 되는데 eval 은 그 최적화를 깨뜨린다. 보안문제도 있다. 사용자가 입력한 데이터는 untrusted data 라고 하는데, 이것은 한번 검사를 해야한다고 한다. eval이 받은 문자열을 바로 실행시켜버리니까 문제인듯하다. 그 안에 무슨 코드가 있을지 모르니까.  </p><p>(함수이름 짓는 팁: 빌트인메소드들 이름 따라하기)  </p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>객체에는 상태 데이터와 동작(메소드)이 있다고 했고, 동작인 메소드는 상태 데이터를 참조하고 변경할 수 있어야 한다. 메소드가 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.<br><strong>this</strong>는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 <strong>자기참조변수</strong>이다. <strong>this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정된다.</strong> 아무것도 신경쓰지말고 함수가 어떻게 호출되었느냐만 보면됨. 함수가 호출되어야 this 가 결정된다.<br><!-- (렉시컬 스코프는 함수정의가 평가될때 결정된다)  --></p><h3 id="다양한-함수호출방식"><a href="#다양한-함수호출방식" class="headerlink" title="다양한 함수호출방식"></a>다양한 함수호출방식</h3><ol><li>일반함수 호출 -&gt; this 는 기본적으로 window 를 가리키도록 세팅된 채로 시작한다.  </li><li>메소드 호출 -&gt; this 는 메소드를 호출한 객체를 가리킨다.  </li><li>생성자함수 호출 -&gt; this 는 생성될 인스턴스를 가리킨다.  </li><li>Function.prototype.apply/call/bind 메소드에 의한 간접 호출 -&gt; this를 명시적으로 바인딩  </li></ol><p>this는 객체의 참조를 얻기 위해 필요한 것이니까 전역이나 일반함수에서 this를 쓸 일은 없다. 그래서 엄격모드에서는 undefined를 내보낸다.  </p><p>메소드로 호출된 함수는 메소드를 <strong>호출한</strong> 객체를 가리킨다고 했다. 메소드를 <strong>가지고 있는</strong> 객체가 아니다! this 가 무엇인지 확인할 때에는 무조건 함수가 <strong>어떻게</strong> 호출되었는지만 확인하면 된다. 즉시실행함수도 this 가 window 이다. 메소드 안의 중첩함수도 일반함수로 호출되었다면 this 는 window 이다.<br>그런데 중첩함수는 외부함수를 도와주는 함수이다. 외부함수 안에서만 딱 쓰겠다는 의지가 나타났다는 말이다. 그럼 외부함수가 메소드로 호출돼서 this 가 객체를 가리키는 상태라면, 중첩함수에서 this가 window로 바뀌는 것은 기대에 어긋난다. 그래서 필요하다면 this를 갈아끼워줄 수 있다. 외부함수에서의 this를 변수에 회피시켜놓고 쓸 수도 있지만, bind/apply/call 빌트인 메소드를 사용할 수도 있다. 위 목록 중 4번 항목을 말하는 것이다. </p><!-- 호출이라는 것은 외부의 인수를 함수내부로 밀어넣는 행위이기도 하다. bind(this) 는 바깥의 this를 bind에 넣어주는거고 그럼 this 가 foo 안에 있는거고, foo는 obj가 호출했으니까... this가 obj 가 된다. --><h3 id="apply-와-call"><a href="#apply-와-call" class="headerlink" title="apply 와 call"></a>apply 와 call</h3><p>함수를 호출하는 것이 주 역할인 것은 똑같고 인수를 전달하는 방식만 다른 메소드들이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">뫄뫄.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure></p><p>뫄뫄.apply(thisArg) 일 때, 뫄뫄함수를 호출하면서 인자로 준 thisArg를 this로 바인딩해준다(간접호출도 해준다). 인수가 있을 때 인수도 전달할 수 있다. <code>[argsArray]</code> 는 함수에 전달할 인수 리스트 배열이다. 옵션이므로 생략 가능하다.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">뫄뫄.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>call 메소드도 첫 번째 인자를 this 로 바인딩해주고 간접호출까지 해주는 것은 같다. 하지만 인자를 전달하는 방식이 apply 와는 다르다. 배열의 형태가 아니라 하나씩 전달해야 한다.  </p><ul><li><em>apply 를 쓰는 팁</em><br>내가 자주 접하는 가변인자함수중에는 Math.max() 가 있다. 인수를 한 개, 두 개, 세 개 내 맘대로 전달할 수 있다.<br>Math.max() 의 문법은 <code>Math.max([값1[, 값2[, ...]]])</code> 이고 예제는 다음과 같다.  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">10</span>, <span class="number">20</span>);   <span class="comment">//  20</span></span><br></pre></td></tr></table></figure></li></ul><p>그런데 만약 내 숫자들이 배열 안에 들어있다면<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(arr); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p><p>배열을 통째로 넣어버리면 NaN이 나온다.  </p><p>Math는 this가 필요없는 정적메소드이다. 따라서<br><code>Math.max.apply(null, arr)</code> 이렇게 하면 arr라는 배열이 그대로 Math.max에 들어갈 수 있다.<br><code>Math.max(...arr)</code> ES6에서는 이 문법도 가능하다.  </p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>호출을 자동으로 해주진 않고, 사용할 객체를 this로 전달하는 것까지만 해준다.<br>코드 이해가 잘 안되니까 내일 다시 알아보고 업데이트 해야겠다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;전역객체&quot;&gt;&lt;a href=&quot;#전역객체&quot; class=&quot;headerlink&quot; title=&quot;전역객체&quot;&gt;&lt;/a&gt;전역객체&lt;/h2&gt;&lt;p&gt;우리가 만드는 게 아니라 브라우저 열자마자 전역객체가 만들어진다. 그 안에는 전역객체가 가지고있는 프로퍼티와 메
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>함수, 프로토타입</title>
    <link href="https://dearjsmc4.github.io/2019/05/13/0513/"/>
    <id>https://dearjsmc4.github.io/2019/05/13/0513/</id>
    <published>2019-05-12T15:00:00.000Z</published>
    <updated>2019-05-14T02:12:41.195Z</updated>
    
    <content type="html"><![CDATA[<!-- constructor 와 프로토타입은 전부 객체지향에 대한 이야기고.프로토타입에서 상속을 모르면 안 된다. 프로토타입은 면접질문으로 나올테니까 잘 알아두기. --><h2 id="함수와-일급객체"><a href="#함수와-일급객체" class="headerlink" title="함수와 일급객체"></a>함수와 일급객체</h2><p>일급객체: 값처럼 쓸 수 있는 객체<br>객체는 변수에 담을 수도 있고 프로퍼티의 값으로 할당할 수도 있고 함수 인수로 전달하거나 리턴으로 반환할 수 있다. 함수도 위의 조건을 만족시키므로 일급객체이다.  </p><h3 id="함수-객체의-함수-객체만이-가지고있는-프로퍼티"><a href="#함수-객체의-함수-객체만이-가지고있는-프로퍼티" class="headerlink" title="함수 객체의(함수 객체만이 가지고있는) 프로퍼티"></a>함수 객체의(함수 객체만이 가지고있는) 프로퍼티</h3><p>함수는 객체이므로 프로퍼티를 가질 수 있다.<br>함수를 console.dir 로 찍었을 때 나오는 함수객체 고유의 프로퍼티는<br>arguments, caller, length, name, prototype 이렇게 다섯 가지이다.  </p><ul><li><p><code>arguments</code>: 함수 호출 시 전달된 <strong>인수들의 정보</strong>를 가지고 있다.(중요함!!!)<br>  유사배열객체이므로 for문 등으로 순회가 가능하다. 하지만 arguments는 프로퍼티처럼 쓰면 안 되고 함수의 암묵적인 지역변수처럼 써야 한다. arguments 객체는 매개변수 개수를 확정할 수 없는 <strong>가변인자함수</strong>에서 쓰면 좋다. 만약 for 문을 돌리면서 <code>arguments[i]</code> 이런 식으로 접근하는 것은 배열표현식이 아니라 프로퍼티접근이다. i 에 0, 1, 2, 3 이런 숫자들이 들어가더라도 숫자를 문자로 바꿔서 접근하기 때문에 사실은 <code>arguments.0</code> 이런식으로 접근하는 것과 같다.  </p></li><li><p><code>length</code>: <strong>매개변수</strong>의 개수를 가리킨다.  </p></li><li><code>name</code>: <strong>함수명</strong>을 나타낸다.  </li><li><code>prototype</code>: 함수만 가지고 있는 객체. 생성자 함수의 경우 함수가 생성할 객체의 프로토타입을 가리킨다.  </li></ul><h2 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">me.name = <span class="string">'Rudy'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me);</span><br><span class="line"><span class="comment">// &#123;name: "Rudy"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(me.hasOwnProperty(<span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Object 생성자 함수가 빈 객체를 만들고 내가 me 객체 안에 프로퍼티를 추가하였다. 그런데 me 객체는 내가 만들지 않은 여러 메소드들도 가지고 있다. 내가 선언하지 않았지만 쓸 수 있는 함수들이 있다는 말이다. <code>hasOwnProperty()</code> 역시 그 중 하나이다. 나는 이 메소드를 만든 적이 없지만 me 객체에서 사용할 수 있다. 왜냐면 모든 객체는 자신의 부모역할을 하는 프로토타입과 연결되어있다는 전제가 깔려있어서 그렇다.  </p><p>결론부터 말하자면 프로토타입 체인의 종점에 해당하는 <code>Object.prototype</code> 이 가지고 있는 메소드들은 모든 객체가 상속받아서 사용할 수 있다. 자식객체가 부모객체의 자산을 자신의 것인냥 사용할 수 있다는 것이다. 하지만 부모객체는 자식객체의 자산을 사용할 수 없다.(프로토타입 체인은 단방향 링크드 리스트로 구현되어있다.) 프로토타입 체인은 상속을 구현하는 방식이다.  </p><p>me 객체의 부모역할을 하는 프로토타입은 <code>Object.prototype</code> 이며, 따라서 me 객체는 <code>Object.prototype</code> 가 가지고 있는 모든 메소드들을 상속받아 사용할 수 있다.  </p><h3 id="Object-생성자-함수와-Object-prototype"><a href="#Object-생성자-함수와-Object-prototype" class="headerlink" title="Object 생성자 함수와 Object.prototype"></a>Object 생성자 함수와 Object.prototype</h3><p>Object 생성자함수는 객체이면서 함수이며, prototype 이라는 프로퍼티를 가지고 있다. 이 prototype 프로퍼티는 함수 객체만이 가지고 있으며, <code>Object.prototype</code>을 가리키고 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">생성자 함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 객체의 </span><br><span class="line">프로토타입을 가리킨다고 했다. 일반함수도 가지고 prototype 프로퍼티를 가지고 있지만 </span><br><span class="line">이 때에는 의미가 없다. 화살표함수나 메소드축약표현으로 만든 함수는 아예 이 메소드가 없다.</span><br></pre></td></tr></table></figure></p><p>그리고 모든 프로토타입 객체는 constructor 라는 프로퍼티를 가지고 있고, 이것은 생성자함수를 가리킨다. 그래서 Object 생성자함수와 <code>Object.prototype</code>은 서로를 가리키고 있다.  </p><p><code>Object.prototype</code>은 프로토타입체인의 종점이다. 모든 객체는 <code>Object.prototype</code> 의 자식이고, 모든 객체는 <code>Object.prototype</code> 의 자산을 상속받는다. <code>Array.prototype</code> 이나 <code>Function.prototype</code>도 <code>Object.prototype</code>의 아래에 연결되어있다.  </p><!-- `me.hasOwnProperty('name')` 일 때, me를 스코프체인에서 먼저 찾고, 성공하면, 프로퍼티를 프로토타입체인에서 찾아서 호출.스코프는 상속되는게 아니지. 스코프는 그냥 보이느냐 아니냐 문제지. 하위스코프에서 상위스코프를 볼 수 있을뿐 상속받는건 아님.--><h3 id="proto-접근자-프로퍼티"><a href="#proto-접근자-프로퍼티" class="headerlink" title="__proto__ 접근자 프로퍼티"></a><code>__proto__</code> 접근자 프로퍼티</h3><p>프로퍼티에는 데이터프로퍼티와 접근자프로퍼티 두 가지 종류가 있다. 데이터 프로퍼티와 달리 접근자 프로퍼티는 value가 없다. 접근자 프로퍼티는 다른 데이터프로퍼티의 값을 가져오거나 변경/갱신할때 쓰는 것. 어떤 데이터프로퍼티 값을 보호하고 싶을 때, 혹은 조건에 부합할 때만 바꾸고 싶을 때 쓴다. <code>__proto__</code> 접근자 프로퍼티는 <code>Object.prototype</code> 에 있기 때문에 모든 객체와 함수가 사용할 수 있다. (모든 객체가 <code>__proto__</code> 를 ‘가지고 있는’ 것이 아니다!)</p><p>그럼 <code>__proto__</code> 접근자 프로퍼티는 어디서 데이터를 가져올까?<br><code>[[Prototype]]</code> 내부슬롯에서 가져온다. 모든 객체는 자기가 생성될때 <code>[[prototype]]</code> 이라는 내부슬롯을 가지고, 이 안에 자신의 프로토타입 객체를 넣는다. 원래 직접적인 접근은 할 수 없지만, 간접적인 방법으로 접근을 허용한다.<br>따라서 <code>me.__proto__ === Object.prototype</code> 은 true 가 된다. <code>__proto__</code> 접근자 프로퍼티를 이용하여 프로토타입을 교체하거나 프로토타입에 프로퍼티를 추가할 수도 있지만, 그보다는 <code>Object.getPrototypeOf</code> 메소드나 <code>Object.setPrototypeOf</code> 를 이용하는 것이 좋다. <code>__proto__</code> 접근자 프로퍼티는 객체의 프로토타입을 찾기 위한 것이고 원래는 직접 접근해서는 안 되는 프로퍼티이기 때문이다.  </p><!-- ### 객체지향 프로그래밍  객체는 데이터뿐만 아니라 메소드도 가지고있는데 내부데이터만 조작을 한다.그래서 프로퍼티를 상태데이터라고 함(바뀔값이라는 뜻. 메소드가 동작하는 순간 바뀔테니까)메소드는 동작이라고 함.객체는 상태와 동작을 그룹화한것. -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- constructor 와 프로토타입은 전부 객체지향에 대한 이야기고.
프로토타입에서 상속을 모르면 안 된다. 프로토타입은 면접질문으로 나올테니까 잘 알아두기. --&gt;
&lt;h2 id=&quot;함수와-일급객체&quot;&gt;&lt;a href=&quot;#함수와-일급객체&quot; clas
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>전역변수 문제점, 모듈패턴, 프로퍼티 정의, 생성자 함수</title>
    <link href="https://dearjsmc4.github.io/2019/05/10/0510/"/>
    <id>https://dearjsmc4.github.io/2019/05/10/0510/</id>
    <published>2019-05-09T15:00:00.000Z</published>
    <updated>2019-05-13T11:40:18.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="전역-변수의-문제점"><a href="#전역-변수의-문제점" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h2><ol><li><p>중복 선언이 가능하다.<br> var 키워드의 경우 중복 선언이 가능한데, 이때 의도치않은 재할당이 일어날 수 있다.</p></li><li><p>생명 주기가 길다.<br> 스코프에 식별자가 등록되면 태어나는 것이고, 스코프가 죽으면 그 스코프의 변수도 죽는다. 전역 변수는 스코프가 소멸되지 않는다. 전역 스코프가 소멸되면 다른 window 전역 객체들도 다 못 쓰게 되는 것이다. 게다가 변수가 소멸되지 않으면 계속 메모리공간을 차지하고 있게 되는 문제도 있다.  </p></li></ol><p>함수의 생명 주기가 끝날 때는 식별자가 함수 객체를 가리키고 있는 그 참조를 끊어버리고 나중에 다시 함수를 호출하면 다시 참조하게 된다. 함수는 최대한 간결하고 짧게(스코프를 좁게) 만들고, 함수 하나당 할 일도 하나만 준다. 변수가 태어나자마자 빨리 소멸되도록 하는 것이다.</p><ol start="3"><li><p>누구나 접근 가능하고 누구나 변경 가능하다. 값이 변할 확률이 높다.<br> 예상치못한 값의 변경은 에러를 일으키기 딱 좋다.  </p></li><li><p>네임 스페이스 오염<br> 브라우저에서는 파일별로 스코프가 생기지 않는다. 따라서 각 파일마다 전역변수를 따로 설정하더라도 브라우저에서 변수가 충돌할 수 있다.</p></li></ol><p><strong>캡슐화</strong>:<br>인터넷에서 내가 쓰지 않은 남의 댓글은 특별한 방법을 쓰지 않는 이상 삭제하거나 수정할 수 없다. 애초에 삭제나 수정버튼이 제공되지 않기 때문이다. 이처럼 어떤 변수를 아무나 참조하거나 변경할 수 없게 하고 싶다면 캡슐화를 통해 변수를 숨겨버릴 수도 있다. 자바스크립트는 클로저를 통해 캡슐화를 한다.  </p><h2 id="모듈패턴"><a href="#모듈패턴" class="headerlink" title="모듈패턴"></a>모듈패턴</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// private 변수</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        increase()&#123;</span><br><span class="line">            <span class="keyword">return</span> ++num;</span><br><span class="line">        &#125;,</span><br><span class="line">        decrease()&#123;</span><br><span class="line">            <span class="keyword">return</span> --num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter.num); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.increase()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter.decrease()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>전역 변수를 사용하지 않는 방법 중 하나다. (이해가 안 되면 외워야 한다)<br>중첩함수가 외부함수보다 더 오래 살아남으면 그것을 클로져라고 한다. 함수 객체는 생성되어질때 자신의 상위스코프를 기억한다. (렉시컬 스코프와 연결되는 얘기다) 그래서 외부함수가 죽었어도 중첩함수가 갖고있던 상위스코프는 살아있다. 따라서 참조도 가능하고, 상위스코프에 있던 지역변수는 자유변수가 된다. 살아있는 상위스코프를 참조하고 있으니까 상태유지도 가능하다. 하지만 밖에서 변수 num 을 참조할 순 없다. 중첩함수만이 외부함수를 참조하고 변경할 수 있다.  </p><!-- 외부스코프를 나타내는 객체가 사실은 절대 죽지 않으니까 메모리낭비가 아닌가?요즘 브라우저에서 클로져를 엄청나게 최적화해놔서 괜찮다는듯...100개의 변수가 있더라도 참조하는 변수만 기억함. 나머지는 기억안함. --><h2 id="프로퍼티-정의"><a href="#프로퍼티-정의" class="headerlink" title="프로퍼티 정의"></a>프로퍼티 정의</h2><p>프로퍼티를 정의한다는건 프로퍼티 생성과 다르다.<br><code>Object.getOwnPropertyDescriptor</code> 메소드가 반환하는 게 프로퍼티의 어트리뷰트들인데, 이것들은 자바스크립트 엔진이 프로퍼티를 생성할 때 자동으로 기본값으로 정의해준다. 함수로 이렇게 정의된 어트리뷰트들을 바꿀 수도 있지만 실제로 그렇게 할 일이 많지는 않다.<br><!-- (enumerable : 열거가능한지. for in 문같은걸로 돌렸을 때 열거될수있는지.) --><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> me = &#123;</span><br><span class="line">name : <span class="string">'Rudy'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(me,<span class="string">'name'</span>));</span><br><span class="line"><span class="comment">//&#123;value: "Rudy", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="내부슬롯-내부메소드"><a href="#내부슬롯-내부메소드" class="headerlink" title="내부슬롯/내부메소드"></a>내부슬롯/내부메소드</h3><p>ECMAScript 스펙에서 나오는 말…<br><code>[[Call]]</code> 이나 <code>[[Prototype]]</code> 처럼 대괄호가 두 개 겹쳐있는 애들이 내부슬롯이다.<br><!-- ecmascript 스펙이 뭔가. 스펙은 설계서. 일을 왜하는지, 어떻게하는지. 자바스크립트엔진을 어떻게 구현해야하는지.내부 슬롯, 내부 메소드는  --><br>자바스크립트 엔진이 코드를 실행하는 알고리즘을 설명하기 위해 ECMAScript 스펙에서 사용하는 의사 프로퍼티. 자바스크립트엔진은 내부슬롯과 내부메소드의 사양을 만족시키는 것이 중요하다. 이 내부 슬롯은 내가 직접 접근할 수는 없고 필요하다면 간접적으로 접근 가능하다. 하지만 접근할 수 없게 만든 것들에는 역시 접근하지 않는 것이 좋겠다.  </p><h3 id="데이터-프로퍼티와-접근자-프로퍼티"><a href="#데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="데이터 프로퍼티와 접근자 프로퍼티"></a>데이터 프로퍼티와 접근자 프로퍼티</h3><p>프로퍼티에는 두 가지 종류가 있다. 데이터 프로퍼티와 접근자 프로퍼티이다.<br>위에서 살펴보았듯, <code>Object.getOwnPropertyDescriptor</code> 는 객체가 가지고 있는 프로퍼티의 정의값을 본다. 프로퍼티 어트리뷰트들을 담아서 프로퍼티 디스크립터라는 객체를 반환해준다고 하는데, 데이터 프로퍼티에는 value, writable, enumerable, configurable 이렇게 네 가지 어트리뷰트가 있다. 보통 우리가 보는 대부분의 프로퍼티는 데이터 프로퍼티이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(me,<span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123;value: "Rudy", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure></p><p>접근자 프로퍼티에는 자체적으로는 값이 없고, 다른 데이터 프로퍼티의 값을 가져오거나 갱신할 때 쓴다.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(me.__proto__);</span><br><span class="line"><span class="comment">// &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;</span></span><br></pre></td></tr></table></figure><p><code>__proto__</code> 는 접근자 프로퍼티이다. 접근자 프로퍼티에는 value 가 보이지 않는다.  </p><h2 id="생성자-함수에-의한-객체-생성"><a href="#생성자-함수에-의한-객체-생성" class="headerlink" title="생성자 함수에 의한 객체 생성"></a>생성자 함수에 의한 객체 생성</h2><p>타입변환할 때 쓸 수 있는 방법 중 하나가 생성자 함수인데, 생성자함수는 타입변환이 주 업무가 아니다.<br>생성자 함수는 매개변수로 외부정보를 받아서 new 연산자와 함께 호출하여 여러 개의 객체를 만들어낼 수 있는 함수다. constructor 라고 한다. 리터럴 표기법으로도 여러 개의 객체를 만들 수 있지만, 한 번에 하나의 객체만 만들어낼 수 있고, 그러므로 여러 개를 만들려면 그만큼의 노가다가 필요하다. 게다가 같은 로직이 중복될 수 있는 문제가 있다. 또한 재사용이 불가능하다. 리터럴 표기법으로는 객체가 생성되고 말 뿐, 미리 만들어진 프로퍼티를 사용할 수는 없기 때문이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Object</span>());</span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></p><p>당장 콘솔창에서 <code>new Object();</code> 를 찍어보면 빈 객체가 만들어지는 것을 볼 수 있다. <strong>Object 생성자 함수</strong> 라고 한다. 물론 new 연산자를 붙이지 않아도 자바스크립트 엔진이 new 연산자가 붙어있는 것처럼 동작하기는 하지만, new 연산자를 붙여주는 것이 정석이니 그렇게 하도록 하자. 만들어진 빈 객체에는 프로퍼티나 메소드를 추가할 수 있다. 그런데 이렇게 일일이 추가하여 만들 것이라면 리터럴로 만드는 것보다 그렇게 큰 메리트는 없다. 객체를 만드는 방법에는  </p><ul><li>리터럴표기법  </li><li>Object 생성자 함수  </li><li>생성자 함수(우리가 만든)(중요!)  </li><li>Object.create() 함수  </li><li>Class  </li></ul><p>등이 있지만 생성자 우리가 만드는 생성자 함수를 먼저 살펴보자.<br><del>왜냐면 마지막 2개는 아직 안 배웠다.</del>  </p><!-- 인자로 원시값을 주면 랩핑해서 문자열이면 문자열객체를 만들고 숫자면 숫자객체를 만든다.원시값을 객체처럼쓰면(메소드를 쓰면) 자바스크립트엔진이 그것을 객체타입으로 만든다. 메소드를 호출하고 난 후에 변경된값을 반환하고 다시 원래값으로 돌아간다(부수효과가없음)래퍼객체. 원시값타입을 객체로 바꾸는거 --><h3 id="생성자-함수가-객체를-만드는-방법"><a href="#생성자-함수가-객체를-만드는-방법" class="headerlink" title="생성자 함수가 객체를 만드는 방법"></a>생성자 함수가 객체를 만드는 방법</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Rudy'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me);</span><br><span class="line"><span class="comment">// Person &#123;name: "Rudy"&#125;</span></span><br></pre></td></tr></table></figure><p>(객체 앞에 붙어있는 Person 은 생성자 함수의 이름이다.)<br>new 연산자와 함께 생성자 함수가 호출되면, 생성자 함수 내부로 컨트롤이 이동하여 두 가지의 암묵적인 동작이 일어난다.  </p><ol><li>빈 객체를 만들어서  </li><li>this에 할당한다.(이를 <strong>this 바인딩</strong> 이라고 한다.)  </li></ol><p>그리고 <code>this.name = &#39;Rudy&#39;;</code> 와 같이 프로퍼티들을 추가하고 할당해준다. 이것이 프로퍼티 동적추가/동적생성이다.<br>이때 <strong>this는 생성자함수가 (미래에) 생성할 객체(인스턴스)</strong>를 가리킨다. 마지막에는 암묵적으로 <strong>this 인 객체</strong>를 반환한다.  </p><p>생성자 함수 내부에 return문이 없더라도 생성자 함수는 암묵적으로 this 를 반환해준다. 그러므로 굳이 return 문을 넣을 필요도 없고 넣어서도 안 된다. 만약 return 문을 넣게 되면 무시되거나, 원시값을 리턴하도록 설정해둔 경우 this 가 아닌 원시값이 리턴되어버린다.  </p><p>생성자 함수를 new 없이 호출하면 일반함수호출이 되고, 이때의 this 는 무조건 생성자 함수가 만들어낼 객체가 아니라 전역 객체인 window 가 된다. 그리고 return 문이 없으므로 undefined 가 반환된다. 그래서 생성자함수가 일반함수와 똑같이 생겼더라도 <strong>반드시 new 로 호출</strong>해야 한다. 애초에 생성자 함수의 함수명을 파스칼케이스로 써서 구별하도록 약속되어 있으니 잘 알아보고 호출하도록 하자(이것도 개발자들끼리의 약속이지, 자바스크립트 엔진이 알아주는 것은 아니다). 이처럼 함수도 다양한 방식으로 호출할 수 있고 그때마다 this가 동적으로 결정된다.  </p><p>그리고 this 바인딩이라고 하였는데, 변수에는 값을 <em>할당</em> 한다고 하고 식별자에는 값을 <em>바인딩</em> 한다고 한다.  </p><!-- - 일반 객체를 호출할 수 없는 이유?  함수 객체만 가지고있는`[[call]]` 과 `[[constructor]]` 내부메소드가 없기때문이다.일반함수,    생성자함수.이렇게 둘로 나눠놓고 new 를 붙엿나 안붙엿나 검사를 한단다.new가 붙으면 생성자함수니까... --><p>일반함수는 다 호출할 수 있지만 생성자 함수로 호출할 수 있는 함수는 정해져 있다. 화살표함수는 생성자 함수로 호출할 수 없다. 화살표함수는 콜백으로 자주 쓰이고, 생성자 내부메소드가 없다. 객체 내에서 메소드축약표현으로 쓴 메소드 역시 생성자함수로 호출이 안 된다.  </p><ul><li><code>new.target</code><br>생성자 함수가 new와 함께 호출되었는지 아닌지를 검사한다. IE에서는 지원이 되지 않는다.  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;전역-변수의-문제점&quot;&gt;&lt;a href=&quot;#전역-변수의-문제점&quot; class=&quot;headerlink&quot; title=&quot;전역 변수의 문제점&quot;&gt;&lt;/a&gt;전역 변수의 문제점&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;중복 선언이 가능하다.&lt;br&gt; var 키워드의 경우 
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>원시 값과 객체, 함수, 스코프</title>
    <link href="https://dearjsmc4.github.io/2019/05/08/0508/"/>
    <id>https://dearjsmc4.github.io/2019/05/08/0508/</id>
    <published>2019-05-07T15:00:00.000Z</published>
    <updated>2019-05-14T01:02:45.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="원시-값"><a href="#원시-값" class="headerlink" title="원시 값"></a>원시 값</h2><p><strong>변경 불가능한 값.</strong> 변수와 헷갈리면 안 된다. 변수 자체가 값도 아닐 뿐더러, 변수는 당연히 변수값이 변한다. 그런데 변수가 가지고 있는 값 자체가 원시 값(숫자, 문자, 불리언, null, undefined, symbol)일 때 값은 바뀌지 않는다. 상수하고도 헷갈리면 안 된다. <strong>상수도 값을 갖고 있을 수 있는 변수</strong>이다. 단지 재할당을 못할 뿐이지. 그래서 변하지 않는 수라고 하면 상수하고 헷갈리기 쉽다.<br><code>const a = {};</code> 일 때는 빈 객체를 변경할 수 있다. 객체는 객체타입이며 변경가능한 값이기 때문이다. <strong>변경 불가능하다는 것은 재할당 불가능하다는 것이 아니다.</strong><br><!-- 변수가 나쁜 건 아니지만 남발하면 안 좋다. 왜냐면 대부분의 에러가 변수때문에 나기 때문에. 따라서 변수는 스코프를 좁혀서 얼른 쓰고 얼른 버리는 게 좋다. 다른 곳에서 변경되지않도록.   --><br>대부분의 언어에서 문자열은 객체로 취급받는데 자바스크립트는 원시 값으로 취급받는다. <strong>재할당 이외의 방법으로는 절대 변할 수 없기 때문에 신뢰성이 보장</strong>된다. 요즘은 객체도 ‘얼려서’ 변경을 못하도록 하기도 한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;그럼 객체도 처음부터 원시 값으로 만들지 그랬냐&quot; </span><br><span class="line">-&gt; 객체를 하나 만든다는 게 생각보다 비용이 많이 드는 일이다. </span><br><span class="line">프로퍼티도 하나의 객체이고. 그러면 객체를 통째로 썼다 지웠다 하는 것보단 차라리 </span><br><span class="line">변경 가능하게 만드는 게 더 나은 일일 것이다. 신뢰성과 맞바꾸더라도... </span><br><span class="line">게다가 원시 값은 Pass by Value, 값을 복사해서 넘겨주는 전달인데, </span><br><span class="line">만약 객체를 통째로 복사해서 전달한다면 큰 낭비이기도 하다.</span><br></pre></td></tr></table></figure></p><p>(+)<br><strong>가비지컬렉터</strong>: 메모리공간의 값을 지우고 다니는 애가 아니라, 메모리공간의 할당을 해제하고 다니는 애다. 메모리공간 확보라는 건 ‘여기 쓸 거니까 건들지마’ 라는거고, 메모리공간 해제라는 건 ‘여기 쓰는 사람 없으니까 써도 돼’ 라는 것.  </p><h2 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h2><p>객체를 할당한 변수가 확보한 메모리공간에는 객체가 실제로 저장된 메모리공간의 주소가 저장되어있고, 이를 <strong>참조값</strong>이라고 한다. 식별자가 객체를 가리키고 있는(point) 상태이다. 참조값(메모리주소) 자체는 원시값이라서 바꿀 수 없지만 메모리공간에 저장된 실제 객체는 변경 가능하다. 객체 리터럴이 평가되어 값이 된다는 건 메모리에 이진수로 저장된다는 말이다. 두 개의 식별자가 한 객체를 공유한다는 건 한 쪽이 데이터를 변경하면 다른 한 쪽도 영향을 받으므로 부작용이 된다.  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person1 === person2); <span class="comment">// ①</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name === person2.name); <span class="comment">// ②</span></span><br></pre></td></tr></table></figure><p>1번은 false, 2번은 true 가 나온다.<br>객체 비교는 참조값이 달라서 false고, 2번은 원시값 비교(‘Lee’)가 되기 때문에 true이다.</p><h2 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h2><p>함수 안으로 필요한 정보를 밀어넣고(input) 값을 만들면 그 값을 내보낸다(output).<br><code>function</code> 키워드는 함수 선언이라기보다는 <strong>함수 정의</strong>라고 하자.<br>함수 정의만으로 함수가 실행되는 것은 아니고, <strong>함수 호출</strong>이라는 트리거가 있어야 한다. <code>return</code>은 옵션이고, return 을 안 쓰면 암묵적으로 undefined 가 반환된다(완료 값). 매개변수도 변수라서 인수가 할당된다. 매개변수는 함수 몸체 안에서만 유효하다.<br>함수는 <strong>재사용</strong>을 위해 쓴다. 코드의 중복을 줄이고, 유지보수를 편리하게 한다. 실수가 줄어들고 품질도 좋아지고 돈도 적게 든다. 같은 코드가 여기저기 흩어져있으면 무언가를 고쳐야 할 때 여기저기 흩어진 코드에 다 찾아가서 고쳐줘야 한다.<br>함수명도 함수 몸체 내에서만 유효한 식별자이다. (보통 재귀함수에서 쓴다) 함수를 호출 할 때 보통 <code>foo();</code> 라고 하는데, 이때 foo 는 함수명이 아니라 자바스크립트 엔진이 함수명으로 암묵적으로 생성한 식별자이다.<br>인수 = argument<br>인자 (매개변수) = parameter  </p><h3 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h3><ol><li>함수 선언문  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>함수 선언문은 함수명이 필수다.<br>함수명 안 쓰고 변수에 할당하면 그게 함수 표현식이 된다.  </p><ol start="2"><li>함수 표현식  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>변수 선언문 + 할당문.  </p><p>함수 선언문을 썼을 때, 자바스크립트 엔진이 암묵적으로 함수명과 같은 식별자를 등록하여 식별자가 함수 객체를 가리키게 하고, 그 식별자를 이용해 함수를 호출하게 된다. 함수 표현식도 var 키워드로 인해 foo 라는 식별자가 등록이 되고 함수 객체를 가리키게 된다. 똑같이 동작하는 것 같지만 사실 조금 다르다. 만약 코드 상으로 함수를 정의하기 전에 호출을 먼저 하게 되면 함수 선언문의 경우 함수 호이스팅에 의해 hello 가 콘솔에 출력된다. 함수 선언문은 foo 라는 식별자를 만듦과 동시에 함수 객체까지 메모리공간에 할당해버리기 때문이다. 하지만 var 키워드를 이용한 함수 표현식은 foo 라는 식별자가 등록만 되어있는 상태이기 때문에 호출하게 되면 foo 는 함수가 아니라는 에러가 뜬다.  </p><p>(+)<br>일반 객체와 함수 객체의 차이?<br>일반 객체와 달리 함수 객체는 호출할 수 있다. </p><p>인수와 매개변수의 개수가 일치하지 않아도 에러가 나지는 않는다.<br>매개변수의 갯수는 정해져 있지는 않지만 적을 수록 좋고, 3개까지 쓰는 게 제일 좋다. (왜인지 잘 기억이 안 나므로 알아보고 업데이트 하겠음)<br>3개가 넘어가면 그것들을 객체로 만들어서 넘기면 좋다.<br><!-- 강사님 추천 책: 클린 코드   --></p><ul><li>반환문 <code>return</code>  <ol><li>리턴 키워드 뒤에 지정한 값을 반환.  </li><li>함수의 실행을 중단하고 함수몸체를 빠져나간다. 값을 리턴했는데 뭘 더 할 게 없으니까.<br>리턴 뒤에 어떤 값을 적지 않아도 된다. 그냥 함수를 빠져나갈 뿐.  </li></ol></li></ul><h3 id="즉시실행함수"><a href="#즉시실행함수" class="headerlink" title="즉시실행함수"></a>즉시실행함수</h3><p>정의와 동시에 호출되는 함수. 함수 정의하면 함수 객체가 만들어지고, 그 객체는 호출할 수 있으니까 끝에 () 로 호출. 단 한 번 호출할 수 있다. 그래서 뭐 함수명을 식별자로 만들고 어쩌구 저쩌구도 안한다. 그냥 메모리를 단 한 번 쓰고 사라진다. 이름을 붙여줄 수도 있지만 재귀를 하지 않는 이상 이름이 의미가 없다. 즉시실행함수는 반드시 그룹연산자 (…) 로 묶어주거나 function 키워드 앞에 <code>!</code> 이나 <code>+</code> 를 붙여주어야 한다. 보통 그룹연산자로 묶은 뒤 그 안에서 호출까지 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  [실행 코드]</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><h3 id="중첩-함수"><a href="#중첩-함수" class="headerlink" title="중첩 함수"></a>중첩 함수</h3><p>함수가 함수 안에서 정의되었다. 외부함수를 도와주는 헬퍼함수의 역할을 한다. 스코프와 연관이 있다. 외부함수도 스코프를 만들고 내부함수도 스코프를 만드니까 스코프도 중첩이 된다. </p><h3 id="콜백함수"><a href="#콜백함수" class="headerlink" title="콜백함수"></a>콜백함수</h3><p>외부에서 밀어넣어주는 헬퍼함수. 두 함수를 합친다. 중첩함수는 태생적으로 함수 안에 있는거고 콜백은 밖에서 밀어넣어진다. 내가 넘기는 콜백함수에 따라 함수가 하는 일이 달라질 수 있다.</p><h2 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h2><p>식별자는 값과 바인딩이 되어있다. 왜냐면 값 없이는 식별자는 의미가 없기 때문이다. 스코프는 상하관계가 있다. 이 상하관계는 중첩관계에 의해서 만들어진다. 중첩된 함수 내부에서 선언된 변수는 하위스코프에, 외부함수에서 선언된 변수는 상위스코프에. 전역변수는 전역스코프에 있다. 자바스크립트는 함수가 스코프를 만들고, 이것을 함수레벨스코프라고 한다(var 키워드가 지원하는…). let이나 const는 블록레벨스코프를 지원한다.<br>똑같은 코드도 어디있느냐에 따라(문맥에 따라) 다르게 동작한다. 똑같은 말이라도 어떤 상황에서 하냐에 따라 다른 것처럼. 그 문맥이 스코프다.<br>자식객체는 부모객체의 자산을 쓸 수 있지만 그 반대는 안 된다. 하위스코프의 변수를 상위스코프에서 참조할 수 없다. 내 스코프에서 참조할 변수의 선언을 찾지 못하면 상위로 찾아 올라간다. 상위스코프와 하위스코프가 연결된 것을 <strong>스코프체인</strong>이라고 하는 것이다.  </p><!-- 렉시컬?사전으로는 어휘의, 단어의.. 라는 뜻인데. 렉싱은 어휘를 뜻하고. 음... 식별자들이 렉시컬환경에 등록된다고 생각하면 그냥 식별자라는 어휘들을 모아두는 환경이라고 보면 안 되나? --><!-- 함수 선언문, 하면 선언이니까 식별자가 만들어지고 식별자는 함수객체를 가리킨다. 그러니까 스코프체인에서 변수를 검색하는것과 똑같이 동작함.스코프는 선언될 때에 결정됨.함수 안의 변수는 호출될지안될지모르기때문에 실행할때 함수가 호출되면 그때 선언.--><h3 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ?</span></span><br><span class="line">bar(); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>스코프가 결정되는데에는 두 가지 방식이 있다.  </p><ol><li>함수를 어디서 호출했는지에 따라 상위 스코프가 결정되거나  </li><li>함수를 어디서 정의했는지에 따라 상위 스코프가 결정된다.  </li></ol><p>자바스크립트는 <strong>함수를 어디서 정의했는지</strong>에 따라 상위 스코프가 결정된다. 즉 2번에 해당되고, 이를 <strong>정적 스코프</strong>, 또는 <strong>렉시컬 스코프</strong>라고 한다(1번은 동적 스코프라고 한다). 함수 bar 는 var x = 1; 과 같이 전역에서 정의되었기 때문에 bar 는 1를 출력한다. 만약 동적 스코프였다면 foo 함수 안에서 bar 가 호출되었기 때문에 foo 가 bar 의 상위 스코프가 되고, bar는 1이 아니라 10을 출력하게 될 것이다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;원시-값&quot;&gt;&lt;a href=&quot;#원시-값&quot; class=&quot;headerlink&quot; title=&quot;원시 값&quot;&gt;&lt;/a&gt;원시 값&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;변경 불가능한 값.&lt;/strong&gt; 변수와 헷갈리면 안 된다. 변수 자체가 값도 아닐 뿐더러, 변
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>변수, 값, 문과 표현식, 데이터타입</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0503/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0503/</id>
    <published>2019-05-03T10:40:59.000Z</published>
    <updated>2019-05-08T09:17:19.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h2><p>들어가기 전에.  </p><ul><li>자바스크립트는 왜 8바이트 숫자를 쓰는가  </li></ul><p>자바스크립트의 변수에는 숫자, 문자, 불리언 등을 자유롭게 넣을 수 있다. 즉, 변수에 뭐가 들어올지 모른다는 말이 된다. 그래서 메모리 공간을 좀 넉넉히 확보한다. 다른 언어같으면 ‘이 변수는 4바이트 정수 숫자를 저장할거야’ 라고 크기를 딱 정해줄텐데, (선언될 때 타입을 정하니까 <code>정적 타입 언어</code> 라고 한다.) 자바스크립트는 <strong>동적 타입 언어</strong>라서 크기를 정해주지 않는다. 변수의 타입은 할당될 때의 값의 타입에 따라 정해진다.  </p><p>숫자의 경우, 내가 숫자를 얼마나 넣을 줄 알겠는가. 그러니까 일단 제일 많이 넣을 수 있을 정도로 메모리공간을 보유해놓는 것이다. 따라서 자바스크립트에서 숫자는 무조건 8바이트를 쓴다. 자바스크립트는 개발자가 타입을 덜 신경쓰도록 만들어진 언어다.  </p><p>숫자의 크기가 8바이트면 8개의 셀을 쓸 것이고, 8개의 주소가 있을 것이다. 이때 변수는 선두 어드레스를 기억하고, 변수값을 불러올 때 몇 바이트를 가지고 와야할지 알아야 하는데, 그것은 데이터 타입으로 결정한다. 데이터 타입의 크기를 참고(메모리 공간을 얼마나 차지하고 있나)하여 그만큼의 데이터를 전부 불러온다. 만약 가져와야하는 바이트보다 조금 가져오면 데이터가 왜곡되기 때문이다.</p><h3 id="변수의-재할당"><a href="#변수의-재할당" class="headerlink" title="변수의 재할당"></a>변수의 재할당</h3><p><code>var x;</code><br><code>x = 10;</code><br><code>=</code>: 우변의 값을 좌변으로 할당하는 할당연산자  </p><p>변수가 선언되면, 선언과 초기화단계를 거쳐 변수명과 메모리공간이 매핑되었고 undefined 가 할당된 상태가 된다. 그리고 런타임에 자바스크립트엔진이 10 이라는 숫자(값)를 이진수로 바꿔서 메모리 공간에 값을 넣는다.  </p><p><strong>!중요!</strong></p><p>undefined를 싹 지우고 숫자를 그 자리에 넣는게 아니라, <strong>새로운 공간에 숫자를 넣고 변수 x가 그 공간을 가리키게</strong> 한다. 원시타입은 변경불가능한(immutable) 값이기 때문이다.  </p><p>undefined는 데이터타입이면서 값이기도 하다. 그러니까 할당이 될 수 있다. undefined는 원시타입이고, 변경할 수 없다.<br>-&gt; 메모리공간에 할당된 undefined를 지우고 다른 값으로 바꿀 수 없다는 뜻이다.<br>undefined가 할당된 공간은 그냥 놔두고, 새로운 공간에 10이라고 이진수로 쓰고 x 가 10을 가리키게 한다. 그럼 undefined는 쓰레기값(어떤 식별자도 참조하지않는 값)이 된다. 쓰레기값이 되면 가비지컬렉터가 치운다. (언제 치울지는 모른다 그건 개발자가 신경 쓸 일은 아니다)<br>이것이 자바스크립트에서의 변수의 <strong>재할당.</strong>  </p><h3 id="변수-호이스팅"><a href="#변수-호이스팅" class="headerlink" title="변수 호이스팅"></a>변수 호이스팅</h3><p>선언만 된 상태에서 참조했을 때 초기화된 상태인 undefined 가 나오는 현상.<br>(호이스팅을 배우는 이유는 쓰라고 배우는게 아니라 쓰지말라고 배우는 거라고 하셨다…)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>var 키워드를 사용했으므로 첫 번째 a는 undefined, 두 번째 a는 100이 나온다.<br>자바스크립트 엔진이 변수 선언문을 실행한 후에 코드를 한 줄씩 실행하면서 값을 할당하게 되는데,<br>함수 내에서 첫 a를 콘솔에 출력하려고 할 때에는 아직 100 이라는 값이 할당되지 않아 undefined 인 상태다.<br>두 번째 a를 출력할 때에는 a에 100이 할당 된 후이기 때문에 100이 정상적으로 출력된다.  </p><ul><li>var 키워드의 문제:  <ul><li>중복선언이 된다.  </li><li>호이스팅이 된다.  </li><li>키워드 없이 선언되면서 심지어 전역변수가 된다.  </li><li>블록레벨스코프를 지원 안하고 함수레벨스코프를 지원. </li><li>상수 선언이 안 된다. (상수는 재할당을 못하는 변수. 상수도 변수다!)<br>(변수명을 대문자로만 지으면 상수란 뜻으로 통한다고 한다)  </li></ul></li></ul><p>그래서 ES6에서 const 와 let 키워드가 도입되었다.<br>const: 할당 한번만 가능<br>let: 재할당가능, 재선언 불가능<br>둘 다 변수호이스팅을 안하는 것처럼 동작한다.</p><h2 id="값"><a href="#값" class="headerlink" title="값"></a>값</h2><p>더 이상 평가될 수 없는 표현식.<br>10+20 이 왜 표현식일까? 평가라는 단계를 거쳐 30이라는 하나의 값을 만들기 때문이다.<br>그럼 30은 왜 표현식이냐. 30도 30으로 평가되니까.<br>정확히는, 30도 메모리에 들어갈때 컴퓨터를 위해 이진수 값으로 평가되어 들어가기 때문이다.</p><h3 id="리터럴"><a href="#리터럴" class="headerlink" title="리터럴"></a>리터럴</h3><p>리터럴이라는 상태는, 내가 그냥 30이라고 쓴 상태다. 리터럴 표기법이 별 게 아니고 그냥 내가 10이라고 쓰면 그게 리터럴 표기법으로 만든 리터럴이다. 30은 숫자 리터럴이고, 자바스크립트엔진이 30을 읽고 “아 숫자 30을 만들라는 거구나,” 하고<br>숫자 30에 대응하는 값(이진수)을 만든다. 30이라는 리터럴이 이진수값으로 평가되었다. 결국 <strong>리터럴은 값을 만드는 방법중에 가장 심플한 표현식</strong> 이다.  </p><p>정확히는 리터럴은 값이 아니라 값을 만드는 표현식이다. 근데 어차피 리터럴은 값이 될 예정이니까 그냥 값이라고 퉁칠 수도 있다. 리터럴은 값이 될 순 있지만 값이 리터럴이 될 수 없다는건 리터럴이 평가되서 값이 될 수는 있지만 값이 평가되어 리터럴이 될 수는 없다는 말이다. </p><h2 id="표현식"><a href="#표현식" class="headerlink" title="표현식"></a>표현식</h2><p>변수에 할당되는 것은 값으로 평가될 수 있는 모든 표현식이다.<br><code>var a = 10;</code><br>이 때 콘솔창에서 a 를 입력하면 10이 나온다. a 도 평가되어 10이 나왔다는 뜻이다.<br>이때 a 를 <strong>식별자 표현식</strong>이라고 한다.<br><code>a + 10</code> 은 a 라는 식별자 표현식과 10 이라는 리터럴 표현식이 합쳐진 표현식이다.<br>그래서 표현식은 표현식의 일부가 될 수 있다는 것을 알 수 있다.  </p><h2 id="문"><a href="#문" class="headerlink" title="문"></a>문</h2><p>문은 하나의 키워드와 식별자로 이루어진 명령이다.<br><code>var foo;</code> 는 선언’문’이다. 왜? var 와 foo 로 이루어진 변수 선언명령이기 때문이다.  </p><h2 id="표현식-vs-문"><a href="#표현식-vs-문" class="headerlink" title="표현식 vs 문"></a>표현식 vs 문</h2><p>표현식은 값을 만드는게 주 업무이며, 문은 무언가를 실행하거나 명령하는 것이 주 업무다.<br>문의 개념이 좀 더 포괄적이다. 따라서 표현식은 문이다. 평가하여 값을 만들라는 일종의 명령이기 때문이다. 하지만 우리는 보통 표현식은 ‘평가’를 한다고 하지, ‘명령’한다고는 하지 않는다. 표현식은 ‘평가’가 주 업무다.  </p><p>문은, 표현식인 문과 표현식이 아닌 문이 있다.  </p><ul><li>표현식인 문 : 값을 만드는 일을 하는 문  </li><li>표현식이 아닌 문 : 값을 만드는 일이 아닌 다른 일을 하는 문  </li></ul><p>둘을 구별하는 가장 쉬운 방법은 변수에 할당해보는 것이다.<br>할당이 잘 되면 표현식인 문이고, 안 되면 표현식이 아닌 문이다.<br>가장 쉬운 예로는, if문은 표현식이 아닌 문이다. if문을 변수에 넣지는 않는다.  </p><p>(+)<br>자바스크립트의 할당문은 식이다.<br><code>sum = 10;</code> 을 콘솔창에서 출력해보면 10으로 평가되어 나온다. 값으로 평가되는 표현식이라는 뜻이다.  </p><h2 id="데이터-타입"><a href="#데이터-타입" class="headerlink" title="데이터 타입"></a>데이터 타입</h2><h3 id="문자열-타입"><a href="#문자열-타입" class="headerlink" title="문자열 타입"></a>문자열 타입</h3><p>자바스크립트엔진은 문자열의 크기를 보고 크기에 맞는 메모리공간을 확보한다.<br>문자열을 따옴표로 묶는 것은 식별자로 오해하지 않게 하기 위해서고, 문자열의 시작과 끝을 알리기 위해서이기도 하다. 마치 열고 닫는 태그같은 것이다.<br>ES6부터는 템플릿 리터럴이 도입되었는데, 1+1 같은 산술연산이 들어가도 평가 후에 문자열로 변환된다. </p><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>변수가 선언되었을 때, 개발자가 보기에는 선언만 되고 할당이 되지 않은 상태이지만 사실 자바스크립트엔진에 의해서 선언과 동시에 undefined가 할당된 상태다(값이 할당되었으니 정의도 되었다). undefined는 개발자가 직접 할당하는 것이 아니다. 할당은 자바스크립트엔진이 해주고, 나는 그게 “할당이 안된 상태구나,” 하고 인식하면 된다. 내가 일부러 undefined를 할당할 일이 얼마나 있을까.  </p><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>변수에 null 을 할당하면 변수가 참조하고 있던 값 말고 null 을 가리키게 한다. null은 값이 없다는 뜻이니까, 변수가 가리키는 값은 ‘없다’. 참조가 끊어지게 된다.<br>null 을 할당하게 되면 자연스레 변수가 원래 참조하고 있던 메모리 공간이 해제되지만, null은 값이지 메모리 공간을 해제하라는 명령어가 아니다. null 을 할당하는 것은 그다지 효율적이지 못하기도 하다.<br>a가 null 을 바라보게되면 a가 바라보던 값이 혼자 남게 되어 쓰레기값이 된다? 그럴거면 null을 쓰나 다른 값을 쓰나 똑같고, 그럴거면 스코프를 줄여서 변수를 소멸시키는 게 낫다.<br>(함수는 null 에서 자주 쓰인다고 한다. 리턴값이 없을때 에러를 내보내면 멈추니까 그냥 null 을 리턴해버린다고…)  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;변수&quot;&gt;&lt;a href=&quot;#변수&quot; class=&quot;headerlink&quot; title=&quot;변수&quot;&gt;&lt;/a&gt;변수&lt;/h2&gt;&lt;p&gt;들어가기 전에.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바스크립트는 왜 8바이트 숫자를 쓰는가  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자바스크립트의
      
    
    </summary>
    
      <category term="Javascript TIL" scheme="https://dearjsmc4.github.io/categories/javascript-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
      <category term="Javascript" scheme="https://dearjsmc4.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0425</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0425/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0425/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T10:43:08.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Internet-네트워크-계층-IP담당"><a href="#Internet-네트워크-계층-IP담당" class="headerlink" title="Internet(네트워크 계층): IP담당"></a>Internet(네트워크 계층): IP담당</h2><p>IP는 IP라우팅을 한다.<br>인터넷 계층 : 아이피.(아이피주소는 내가 데이터를 보내고자 하는 상대 호스트 컴퓨터)<br>최종적으로 도달하는 <strong>호스트를 특정</strong>하기 위해 아이피주소가 필요함.<br>상대방의 호스트를 특정하기 위한 <strong>아이피주소를 관리</strong>하는 계층이 네트워크 계층.<br>강사님 추천 책: “TCP/IP 완벽 가이드”  </p><p><strong>NAT</strong> : 호스트1이 유투브에게 데이터를 요구하면 유투브는 공인아이피인 라우터까지는 보낼 수 있는데 정확히<br>어느 호스트가 보낸 건지 사설아이피까지는 알 수 없다. 그렇다고 늘 브로드캐스트로 보낼 수는 없다.<br>그래서 라우터는 랜카드 중 하나를 임대하여 사설 아이피를 공인 아이피와 매핑한다.<br>그리고 소스 아이피를 자신의 공인아이피로 바꿔서 보낸다.<br>서버가 영상을 공인아이피로 보내면, 변환테이블에서 공인아이피와 연결된 사설아이피를 찾는다.<br>그리고 사설아이피를 다시 목적지로 설정하여 보내준다. 랜카드가 많이 필요하다는 단점이 있다.  </p><p><strong>NAPT</strong> : 호스트가 서버와 통신하고자 할때, 모든 호스트들이 같은 랜카드를 빌려오되,<br>구분을 해야하므로 포트번호까지 이용하여 구분한다. 같은 123.108.157.1 이라는 랜카드를 써도<br>포트번호를 달리해서 쓰면 구분지을 수 있는 것이다.  </p><h2 id="Transport-전송계층-포트담당"><a href="#Transport-전송계층-포트담당" class="headerlink" title="Transport(전송계층): 포트담당"></a>Transport(전송계층): 포트담당</h2><p>특정 컴퓨터에게 데이터가 잘 도착했을 때 해당 <strong>프로세스</strong>에게 데이터를 전달하기위해 <code>포트번호</code>가 필요.<br>이 포트는 패킷이 필요한 프로세스를 특정하기 위해 사용된다.<br>이 <strong>포트를 관리</strong>하는 계층이 전송계층. 포트번호는 2^16-1 까지 할당가능하다.<br>패킷에는 아이피주소 말고도 포트번호가 쓰여있어서,<br>해당 포트번호가 특정하는 프로세스에게 데이터를 전송된다.<br>ex) 데이터를 보내긴 보내는데, 유투브 프로세스가 3개 돌아가고 있다면 그 중 어느 프로세스에 데이터를<br>    보낼 것인가?</p><p>서버에는 소켓이 많다. 서버는 특정 컴퓨터의 특정 프로세스일 뿐이다.<br>포트가 특정 프로세스를 특정한다고 했는데, 포트는 소켓에 부여된 숫자이다.<br>이 숫자가 0부터 2^16-1 까지. 2바이트짜리 정수.<br>소켓에는 두 가지 종류가 있다.  </p><ol><li><p>데이터를 전송하고 있는 <code>데이터 소켓</code><br>실제로 클라이언트와 일대일로 매핑되어 데이터를 주고 받는다.  </p></li><li><p>서버를 대표하는 <code>리스닝 소켓</code><br>클라이언트가 리퀘스트를 날릴 때 서버에서 데이터를 받는 소켓<br>리스닝 소켓은 클라이언트로부터 최초의 접속 요청을 받는 소켓<br>접속 후에 실제로 데이터를 주고받는 것은 데이터 소켓  </p></li></ol><p><code>well-known port</code>: 자주 쓰이는 유명한 포트번호.<br>0~1023 번까지 있는데 서버가 특정 서비스에 따라 특정 포트를 쓴다.  </p><p>전송계층에는 두 가지 프로토콜이 있다.  </p><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP / UDP"></a>TCP / UDP</h2><ul><li><p><strong>TCP</strong><br>신뢰도가 높다. 패킷이 유실되면 <strong>재전송</strong>을 해준다. HTTP는 일반적으로 TCP 위에서 돈다.<br>패킷을 보낸 다음에 상대방이 패킷을 잘 받았는지 인증을 받아서 확인한다.<br>-&gt; 패킷이 유실되었는지 계속 관리해야하기 때문에 네트워크에 부담이 된다.<br>파일 전송이나 메일 전송은 TCP를 이용한다.<br>연결 지향성: 서버와 호스트가 데이터를 주고받을 때 소켓을 가지고 접속과 연결이 되어야 한다.  </p></li><li><p><strong>UDP</strong><br>신뢰도가 낮다. 패킷이 유실되더라도 재전송을 해주지 않는다. 보내면 끝.<br>-&gt; 한번 보내면 끝이기 때문에 가볍고 빠르다.<br>동영상이나 빠른 속도가 필요한 게임 등은 UDP를 이용한다.<br>비연결 지향성: 접속이나 연결이 없이 그냥 보내기만 한다.  </p></li></ul><h2 id="Application-응용-표현-세션-계층"><a href="#Application-응용-표현-세션-계층" class="headerlink" title="Application (응용, 표현, 세션 계층)"></a>Application (응용, 표현, 세션 계층)</h2><p><code>Secure Socket Layer(SSL)</code>(Transport Layer Security)를 어플리케이션과 트랜스포트 사이에 끼워넣는다.<br>이 레이어는 <strong>암호화</strong>를 한다. 내가 html 과 js를 만들어서 보내면<br>다른 해커가 스푸핑을 통해서 파일들을 뺏더라도 암호화가 되어있어서 볼 수 없다.<br>받는 상대방은 <strong>복호화</strong>를 해서 볼 수 있다.  </p><ul><li>http: 메세지 기반의 프로토콜. 단순한 문자열을 주고 받고 해석함.<br>(html 파일이나 js 파일도 결국 문자열일 뿐이다)  </li><li>dns: 도메인 네임 시스템. 사람이 읽고 기억하기 쉬운 이름.<br>원래 어떤 사이트에 가려면 아이피주소를 써야하는데,<br>우리는 그 누구도 페이스북에 접속하려고 아이피를 적지 않는다. 대신 도메인 위치를 적는다.<br>그리고 DNS SERVER 에서 도메인 네임에 대한 아이피를 알려준다.<br>받아온 아이피는 캐시로 저장된다.  </li></ul><p><code>HTTP</code> : 하이퍼 텍스트 트랜스퍼 프로토콜<br>“나 이번에 새로 쓴 논문이 있어 인터넷에 링크 걸어둘게!”<br>원래는 진짜 정적파일 텍스트만 보는 용도였다.<br>http 1.0 이하에서는 연결이 일시적이다. 한번 데이터 주고받으면 끝.<br>그런데 점점 컴퓨터 성능이 좋아지니까 이미지나 동영상, 스크립트 파일도 받게 되었다.<br>그래서 한번 리퀘스트를 받은 다음에 한번의 리스폰스로 끝나는 게 아니게 되었다.<br>그래서 http 1.1부터는 연결을 유지한다. 한번 연결하면 끊지 않고 계속 연결.<br>만약 일시적 연결을 원한다면 헤더에 <code>connection:close</code> 를 포함하면 된다.  </p><p><strong>메서드</strong>: 클라이언트 요청의 종류  </p><ul><li><code>GET</code> : URL 이 지원하는 자원을 찾아 클라이언트에 전송</li><li><code>POST</code> : 클라이언트가 임의의 데이터를 서버로 보낸다.<br>주로 form 형식을 사용하며 서버의 프로그램에 전달</li><li>HEAD: GET과 같지만 메세지 본문이 없다. 테스트 용도</li><li>PUT: 지정한 URL에 요청의 본문내용을 저장</li><li>DELETE: 지정한 자원을 지움</li><li>TRACE: 클라이언트가 서버에 보낸 요청의 복사본을 돌려받는다.</li></ul><h3 id="상태코드"><a href="#상태코드" class="headerlink" title="상태코드"></a>상태코드</h3><p>200번대 : 성공<br>300번대 : 서버가 옮겨간것같은데 저쪽으로 다시 시도해볼래?<br>400번대 : 클라이언트가 잘못했다<br>500번대 : 서버가 잘못했다  </p><h3 id="컨텐트-협상"><a href="#컨텐트-협상" class="headerlink" title="컨텐트 협상:"></a>컨텐트 협상:</h3><ol><li><p>서버 주도 협상:<br> -&gt; 최선 추측<br>클라이언트가 원하는 것이 없을 때, 요청과 가장 비슷한 것을 가져감.  </p></li><li><p>에이전트 주도 협상:<br> 클라이언트가 자원을 고를 수 있음<br>-&gt; 클라이언트: 글 좀 보내봐<br>서버: 한국어도 있고 영어도 있고 프랑스어도 있는데… 뭐 보내지?<br>클라이언트: Accept - Language: kr;q=0.7, fr;q=0, en;q=0.4<br> “한국어가 최우선이고 한국어 없으면 영어 보내줘. 프랑스어는 있어도 보내지마”  </p></li></ol><ul><li>random pivot<br>리스트의 첫번째, 중간, 마지막 값을 가져와서 중간값을 찾아서 pivot 으로 설정.<br>-&gt; 거의 average case 에 가깝게 구현이 되더라는 것이 정설.  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Internet-네트워크-계층-IP담당&quot;&gt;&lt;a href=&quot;#Internet-네트워크-계층-IP담당&quot; class=&quot;headerlink&quot; title=&quot;Internet(네트워크 계층): IP담당&quot;&gt;&lt;/a&gt;Internet(네트워크 계층): IP
      
    
    </summary>
    
      <category term="CS TIL" scheme="https://dearjsmc4.github.io/categories/cs-til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0423-1</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0423-1/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0423-1/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T10:42:55.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="메모리-계층-주요-키워드"><a href="#메모리-계층-주요-키워드" class="headerlink" title="메모리 계층 (주요 키워드)"></a>메모리 계층 (주요 키워드)</h2><p><em>지금은 모르더라도 나중에 꼭 알아둬야할 내용</em></p><ol><li>레지스터  </li><li>캐시  <ul><li>지역성 원리(principle of locality) -&gt; 캐시 히트, 캐시 미스  </li></ul></li><li>메모리  <ul><li>segmentation  <ul><li>코드  </li><li>데이터  </li><li>힙 (slow)  </li><li>스택 (fast)  </li></ul></li><li>가상메모리  <ul><li>page  </li><li>page frame  </li><li>page fault  </li><li>page title  </li></ul></li></ul></li><li>하드디스크  </li></ol><h2 id="Big-O"><a href="#Big-O" class="headerlink" title="Big O"></a>Big O</h2><p>데이터 갯수가 늘어날 때 T(n)이 어떤 식으로 늘어나는가<br>(어떤 형태의 그래프를 그리는가) 우리의 주 관심사.<br>그래프의 모양만 알기 위해서는 최고차항만 필요하다. -&gt; <code>O(n^2)</code></p><p><strong>이해가 안 되면 외워</strong>  </p><ol><li>O(a): 상수 시간<br> ex) 배열의 인덱싱  <pre><code>링크드 리스트의 삽입,삭제  </code></pre></li><li>O(log n): 로그 시간<br> ex) BST - insert, search, delete  </li><li>O(n): 선형 시간<br> ex) 링크드 리스트의 탐색 / 특정배열에서의 삽입,삭제  </li><li>O(n log n): 선형 로그 시간<br> ex) quick sort, merge sort<br> 비교 정렬(comparison sorting)의 경우 성능이 아무리 좋아도 O(n log n)보다 성능이 좋을 순 없다.  </li><li>O(n^2): 지수 시간<br> ex) 버블 소트, 선택 정렬, 삽입 정렬  </li></ol><hr><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><ul><li>Job scheduling -&gt; scheduler<br>-&gt; context switching<br>process status(프로세스 상태)<br>thread -&gt; multi threading(cpu 작업이 많을 때)  </li></ul><p>multi threading 의 문제  </p><ul><li>race condition  </li><li>dead-lock </li></ul><h3 id="Concurrency-Programming-동시성-프로그래밍"><a href="#Concurrency-Programming-동시성-프로그래밍" class="headerlink" title="Concurrency Programming (동시성 프로그래밍)"></a>Concurrency Programming (동시성 프로그래밍)</h3><ul><li><code>Asyncronous I/O</code><br>자바스크립트는 헤비한 연산 하지 않는다.<br>따라서 I/O bound 작업에만 쓴다.  </li></ul><h2 id="program-과-process"><a href="#program-과-process" class="headerlink" title="program 과 process"></a>program 과 process</h2><ul><li>program :<br>하드디스크에 저장되어 있는 “하나”의 이미지  </li><li>process :<br>메인 메모리에 올라와서 <code>실행</code>을 시작한 프로그램  </li></ul><p>notepad.exe 라는 프로그램은 하나이지만(program),<br>노트패드 창을 여러 개 띄워서 <code>실행</code>(process) 수 있다.<br>실행되고 있는 여러 개의 notepad 는 <code>PID</code> 를 부여하여 구분  </p><h3 id="선점형-스케줄링과-비선점형-스케줄링"><a href="#선점형-스케줄링과-비선점형-스케줄링" class="headerlink" title="선점형 스케줄링과 비선점형 스케줄링"></a>선점형 스케줄링과 비선점형 스케줄링</h3><ul><li><p>선점형 스케줄링(pre-emptive scheduling) : 새치기가 가능하다.  </p><ol><li><p>created : process 생성<br>OS의 스케줄러가 <strong>우선순위</strong>를 파악  </p></li><li><p>waiting : Queue 실행 대기 상태<br>우선순위가 높으면 이미 실행 중인 프로세스를 waiting 으로 보내고 실행됨<br>-&gt; <code>Priority Algorithm</code><br>우선순위가 같다면 <strong>정해진 시간동안</strong> 실행<br>-&gt; <code>Round Robin Algorithm</code>  </p></li></ol><ul><li>time slice  </li><li><p>quantum  </p><p>정해진 시간동안의 실행이 모두 끝나면 상태가 어떻든 무조건 queue 로 돌아감<br>-&gt; <code>aging</code><br>우선순위가 높은 프로세스들이 들어와서 우선순위가 낮은 프로세스가 실행되지 못하고<br>무한히 대기중인 상태인 <strong>기아상태</strong> 를 해결하기 위한 방법. 오랫동안 대기한<br>프로세스의 우선순위를 점진적으로 증가시켜 실행할 수 있도록 해준다. </p><p><em>I/O 작업</em><br>파일 입출력이나 네트워크 작업<br>CPU가 필요없고 미친듯이 느리다.<br>-&gt; blocked 로 가서 작업이 완료된 후 waiting 으로 갔다가 running 으로.  </p><p>-&gt; waiting 과 blocked<br>waiting 은 cpu 가 부르면 바로 올라갈 수 있다.<br>blocked 는 i/o 가 끝날 때까지 무조건 기다려야 함.</p></li></ul><ol start="3"><li>running : CPU 할당(실행)<br>실행이 끝나면 terminated  </li></ol></li><li><p>비선점형 스케줄링 : 새치기가 불가능하다.  </p></li></ul><h3 id="context-switching"><a href="#context-switching" class="headerlink" title="context switching"></a>context switching</h3><p>정해진 시간동안의 실행이 끝나면 무조건 queue 로 돌아가서 waiting 상태가 되는데,<br>queue 로 끌어내려지는 시점에서 CPU 레지스터에 저장되어있는 실행상태정보(IR과 PC 등)를<br>PCB라는 별도의 공간에 저장한다.  </p><ul><li>Instruction Register: 실행되고 있는 부분  </li><li>Program Counter: 다음 실행될 코드를 가리키고 있는 부분  </li><li>PCB(Process Control Block)<br>그리고 다시 실행할 차례가 돌아오면 PCB의 내용을 다시 CPU에 넣어서 실행할 수 있도록 한다.<br>  -&gt;(디스패치라고도 한다)  </li></ul><p>context switching 이 많이 일어나면 시스템에 과부하가 생긴다.<br>100분의 1초마다 프로세스가 전환이 되면, 1초에 컨텍스트스위칭이 100번 일어나는 것인데,<br>두 프로세스를 실행하기 위해 그 사이에 작업이 추가되는 것이니까<br>그만큼 일종의 오버헤드가 걸릴 수 있다. </p><p><em>context switching 을 안할 수 없는 이유</em><br>라운드로빈에서 시간이 다 될 때마다 끌어내려질건데<br>이때는 무조건 컨텍스트 스위칭이 일어날 수 밖에 없음.<br>그렇다고 컨텍스트스위칭을 줄이겠다고 5초마다 한 번 한다면<br>내가 뭔가 할때마다 최소 5초는 기다려야한다는 뜻.<br>즉, 멀티태스킹이 아니게 되는거임.<br>그렇다고 내가 기다리는 시간을 줄여서 컨텍스트 스위칭을 많이 하면 시스템 과부하가 일어나고.<br>-&gt;<code>sys.getswitchinterval() == 0.005</code>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;메모리-계층-주요-키워드&quot;&gt;&lt;a href=&quot;#메모리-계층-주요-키워드&quot; class=&quot;headerlink&quot; title=&quot;메모리 계층 (주요 키워드)&quot;&gt;&lt;/a&gt;메모리 계층 (주요 키워드)&lt;/h2&gt;&lt;p&gt;&lt;em&gt;지금은 모르더라도 나중에 꼭 알아
      
    
    </summary>
    
      <category term="CS TIL" scheme="https://dearjsmc4.github.io/categories/cs-til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>파이썬 기초 문법</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0419-python/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0419-python/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T10:42:44.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="파이썬-자료형-기초"><a href="#파이썬-자료형-기초" class="headerlink" title="파이썬 자료형 기초"></a>파이썬 자료형 기초</h1><ul><li>string = “abcde”  <ul><li>string<code>[2]</code> = ‘c’  </li><li>string<code>[2:]</code> = ‘cde’ (2번 자리 이상)  </li><li>string<code>[:2]</code> = ‘ab’ (0번 이상, 2번 미만)  </li><li>string<code>[0:1]</code> = ‘a’ (0번 째 이상, 1번 미만)  </li><li>string<code>[0:2]+&quot;z&quot;+string[3:]</code> = ‘abzde’ ( ab + z + de )  </li><li>string<code>.replace(&#39;c&#39;,&#39;z&#39;)</code> = ‘abzde’ (c 를 z 로 바꾸어서 보여줌. 원본이 바뀌지는 않는다.)  </li></ul></li></ul><h3 id="문자열-포매팅"><a href="#문자열-포매팅" class="headerlink" title="문자열 포매팅"></a>문자열 포매팅</h3><p>문자열 내의 어떤 값을 삽입하는 방법.  </p><p>a = 10<br>b = ‘abcde’  </p><ul><li><code>print(&quot;%d, %s&quot; %(a,b))</code> = 10, abcde  </li><li><code>print(&#39;숫자는 {0} 문자열은 {1}&#39;.format(a,b))</code><br>  = 숫자는 10 문자열은 abcde  </li><li><code>print(f&#39;숫자는 {} 문자열은 {}&#39;)</code><br>  = 숫자는 10 문자열은 abcde  </li></ul><p>a = 0.1234512345  </p><ul><li><code>print(f&#39;{a:.3}&#39;)</code> = 0.123 (소수점 뒤의 3자리까지만 자르기)  </li></ul><h3 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h3><ul><li>dic = {‘a’:1, 2:’two’, ‘func’:lambda a,b: a+b}<ul><li>dic<code>[&#39;a&#39;]</code> = 1 (a라는 키의 value를 가져오기)  </li><li>dic<code>[func](1,2)</code> = 3 (func 라는 키의 value 인 함수를 실행)<br>  lambda: 함수가 위치한 메모리 주소값  </li><li>dic.<code>keys()</code> = dict_keys([‘a’, 2, ‘func’]) (dic 의 모든 키값을 가져오기)  </li><li>dic.<code>items()</code> = dict_items<code>([(&#39;a&#39;, 1), (2, &#39;two&#39;), (&#39;func&#39;, &lt;function &lt;lambda&gt; at 0x05B738E8&gt;)])</code><br>  (key와 value값이 튜플로 묶여서 나옴) -&gt; 튜플인 이유가 있나?  </li><li>key_list = <code>list(dic.keys())</code> = [‘a’, 2, ‘func’] (key만 모아서 리스트로 만들기)  </li></ul></li></ul><p><strong>list 와 view 객체와의 차이</strong><br>key_view = dic.keys() = dict_keys([‘a’, 2, ‘func’])<br>key_list = [‘a’, 2, ‘func’]<br>일 때,<br><code>dic[5]=&#39;five&#39;</code> 딕셔너리에 쌍을 추가하면<br>key_view = dict_keys([‘a’, 2, ‘func’, <code>5</code>]) -&gt; 추가되었음<br>key_list = [‘a’, 2, ‘func’] -&gt; 추가 되지 않았음  </p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>집합 자료형인 세트에서는 중복이 허용되지 않는다.  </p><p>s1 = set([1,2,3,4])<br>s2 = set([3,4,5,6])  </p><ul><li><code>s1|s2</code> or <code>s1.union(s2)</code>= {1,2,3,4,5,6} (합집합)  </li><li><code>s1&amp;s2</code> or <code>s1.intersection(s2)</code>= {3,4} (교집합)  </li><li><code>s1-s2</code> or <code>s1.difference(s2)</code> = {1,2} (차집합)  </li><li><code>s2-s1</code> or <code>s2.difference(s1)</code> = {5,6} (차집합)  </li><li><code>s1^s2</code> or <code>s1.symmetric_difference(s2)</code>= {1,2,5,6} (대칭 차집합)  </li></ul><h3 id="True-False"><a href="#True-False" class="headerlink" title="True / False"></a>True / False</h3><ul><li><strong>거짓</strong>으로 취급하는 데이터  <ul><li>“” 빈 문자열  </li><li>[] 빈 리스트  </li><li>() 빈 튜플  </li><li>{} 빈 딕셔너리  </li><li>false  </li><li>none (JS의 undefined)  </li><li>0  </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;파이썬-자료형-기초&quot;&gt;&lt;a href=&quot;#파이썬-자료형-기초&quot; class=&quot;headerlink&quot; title=&quot;파이썬 자료형 기초&quot;&gt;&lt;/a&gt;파이썬 자료형 기초&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;string = “abcde”  &lt;ul&gt;
&lt;li&gt;strin
      
    
    </summary>
    
      <category term="CS TIL" scheme="https://dearjsmc4.github.io/categories/cs-til/"/>
    
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0424</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0424/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0424/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T10:43:02.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOP-꼭-공부해야-함"><a href="#OOP-꼭-공부해야-함" class="headerlink" title="OOP (꼭 공부해야 함)"></a>OOP (꼭 공부해야 함)</h1><ol><li>캡슐화(encapsulation) : 정보 은닉을 포함  </li><li>정보 은닉(information hiding)  </li><li>다형성 (polymophism) : 상속(inheritance)<br> -&gt; 메소드 오버라이딩(method overriding)<br> -&gt; 함수 오버로딩과 헷갈리면 안됨.  </li><li>디자인 패턴(SOLID)  <ul><li>Single responsibility principle(단일 책임 원칙)  </li><li>Open-closed principle(확장-폐쇄 원칙)  </li><li>Liskov substitution principle(리스코브 치환 원칙)  </li><li>Interface segregation principle(인터페이스 분리 원칙)  </li><li>Dependancy inversion principle (의존 역전 원칙)  </li></ul></li></ol><p><strong>객체 지향</strong><br>객체지향 : 관련 있는 변수와 함수를 묶어둠.<br>    변수 : 상태정보(<code>데이터</code>)<br>    함수(여기선 함수가 아니라 메서드) : <code>기능</code>   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Account:</span><br><span class="line">    #생성자(constructor): 객체를 생성할 때 반드시 한번호출한다 --&gt; Account() 형태로 쓴다</span><br><span class="line">    def __init__(self, cust_name, init_balance):</span><br><span class="line">        # 인스턴스 멤버(속성, 데이터, 변수)를 설정</span><br><span class="line">        self.name=cust_name</span><br><span class="line">        self.balance=init_balance</span><br><span class="line">    #소멸자(destructor): 객체가 소멸될 때 반드시 한번 호출</span><br><span class="line">    def __del__(self):</span><br><span class="line">        pass</span><br><span class="line">    #인스턴스 메서드(기능, 행동)</span><br><span class="line">    def deposit(self, money):</span><br><span class="line">        if money &lt; 0:</span><br><span class="line">            return False</span><br><span class="line">        #관련 있는 변수 : 인스턴스멤버</span><br><span class="line">        self.balance+=money</span><br><span class="line">        return True</span><br><span class="line">        </span><br><span class="line">    def withdraw(self, money):</span><br><span class="line">        if money &gt; self.balance:</span><br><span class="line">            return 0</span><br><span class="line">        self.balance -= money</span><br><span class="line">        return money</span><br><span class="line">    </span><br><span class="line">    def transter(self, other, money):</span><br><span class="line">        self.balance -= money</span><br><span class="line">        #다른 객체의 멤버에 바로 접근하지 않는다는 것이 원칙이다</span><br><span class="line">        #다른 객체의 멤버값(데이터)을 변경할때는 반드시 상대 객체가 가진 메서드에 위임해야한다.</span><br><span class="line">        # = 메시지 패싱 </span><br><span class="line">        other.deposit(money)</span><br></pre></td></tr></table></figure><p>-&gt; <strong>입력값은 같지만 상태정보에 따라 결과값은 다르게 나온다</strong></p><h1 id="네트워크"><a href="#네트워크" class="headerlink" title="네트워크"></a>네트워크</h1><h2 id="Network-Interface-물리계층-데이터-링크-계층-mac-address-담당"><a href="#Network-Interface-물리계층-데이터-링크-계층-mac-address-담당" class="headerlink" title="Network Interface(물리계층, 데이터 링크 계층): mac address 담당"></a>Network Interface(물리계층, 데이터 링크 계층): mac address 담당</h2><h3 id="LAN-amp-WAN"><a href="#LAN-amp-WAN" class="headerlink" title="LAN &amp; WAN"></a>LAN &amp; WAN</h3><ul><li><p>LAN : <code>Local Area Network</code><br>같은 지역 내에서 라우터를 통해 서로 연결.<br>아이피주소가 필요없이 물리주소만 알고있으면 라우터를 거치지 않고도 연결이 가능.<br>맥주소를 통해 LAN 안에서만 데이터를 주고받는 프로토콜 = <code>이더넷 프로토콜</code><br>패킷 : 패킷의 맨 윗 부분에 이더넷 헤더가 들어감.<br>이더넷 헤더에는 패킷을 받을 상대방의 맥주소와 송신자의 맥주소가 들어감.<br>받는 사람과 보내는 사람은 같은 LAN 안에 존재해야함.<br><code>MTU(maximum transfer unit)</code> : 한번에 보낼 수 있는 데이터의 크기.<br>패킷은 한번에 1500바이트를 넘지 않는다.  </p></li><li><p>WAN : <code>Wide Area Network</code>  </p></li></ul><h2 id="Internet-네트워크-계층-IP담당"><a href="#Internet-네트워크-계층-IP담당" class="headerlink" title="Internet(네트워크 계층): IP담당"></a>Internet(네트워크 계층): IP담당</h2><p><code>ARP(Address Resolution Protocol)</code>: 브로드캐스트로 어떤 IP 를 사용하는 호스트의 맥 주소를 알아낸다.   </p><p><strong>How? :</strong><br>서로 맥 주소를 모르는 상태에서 호스트1과 호스트2가<br>이더넷 프로토콜을 이용해 데이터를 주고 받고 싶을 때.<br>이때 호스트1이 특별한 <code>패킷</code>을 만들어서 송신자부분에 자신의 아이피와 맥 주소를 쓴다.<br>그리고 수신자 부분엔 호스트2의 아이피를 써놓음. 맥주소는 00:00:00… 과 같이 쓴다.<br>라우터에게 패킷을 던진다.<br>“이거 <code>브로드캐스트</code>로 좀 쏴줄래?” -&gt; 마치 방송하듯이 모든 호스트에게 패킷을 다 보낸다.<br>다른 호스트들이 패킷을 받았을 때, 아이피주소를 보고 자신의 것과 같은지 확인한 후에 무시하거나 리스폰스 한다.<br>호스트2는 <code>리스폰스 패킷</code>을 보낸다.<br>보내는 호스트에다가 자신의 아이피주소와 맥주소를 쓰고<br>받는 호스트에는 처음에 보냈던 호스트1의 주소를 그대로 써서 보낸다.<br>-&gt; 이제 서로의 맥주소를 알게 되었으므로 <code>라우터를 거치지 않고 직접</code> 통신한다.<br>호스트1: “나 이제 호스트2 주소 알아! 직접 통신하자.”<br>한번 ARP를 하고 나면 <code>ARP 테이블</code>(모든 컴퓨터에 다 있음)에다가 맥주소를 저장해둔다.  </p><h3 id="IP프로토콜"><a href="#IP프로토콜" class="headerlink" title="IP프로토콜:"></a>IP프로토콜:</h3><p>IPv4 : 내 아이피주소, 서브넷마스크, 게이트웨이  </p><ul><li><code>아이피</code>는 주소. 4바이트로 구성이 되어있다. 한 자리당 1바이트, 0~255까지.<br>  첫번째 자리에서 클라스 단위를 구분한다.  </li><li><code>서브넷마스크</code>: 어디까지가 네트워크 주소인가?<br>호스트아이디에 할당된 비트를 서브넷으로 쪼갤 수 있다.<br>호스트아이디중에 앞의 두 개 비트를 서브넷아이디로.<br>네트워크가 여러 개일때 연결할 수 있는 호스트의 수는 적어진다.  </li></ul><p>전세계적으로 유니크한, 세상에 하나 뿐인 <code>공인 아이피(public IP)</code>.<br><code>사설 네트워크(privite network)</code>가 구성되어 공인 아이피를 공유하고,<br>그들이 쓰는 아이피가 <code>사설 아이피(privite IP)</code>.<br>사설아이피는 동적으로 할당되기때문에<br>컴퓨터를 껐다 키면 바뀌어있다.<br>(커피숍에서 해킹을 해도 날 잡으러 오기는 힘든 이유.)  </p><h2 id="정렬-알고리즘"><a href="#정렬-알고리즘" class="headerlink" title="정렬 알고리즘"></a>정렬 알고리즘</h2><p>단순 알고리즘(비교정렬) : <a href="https://blueshirudy.tistory.com/13" target="_blank" rel="noopener">버블 정렬</a>,<br><a href="https://blueshirudy.tistory.com/19" target="_blank" rel="noopener">삽입 정렬</a>, <a href="https://blueshirudy.tistory.com/20" target="_blank" rel="noopener">선택 정렬</a><br>분할 정복: <a href="https://blueshirudy.tistory.com/18" target="_blank" rel="noopener">퀵 정렬</a>, 병합 정렬, 힙 정렬  </p><p><strong>분할 정복 기법(divide &amp; conquer)</strong><br>어떤 어려운 문제를 잘개 <em>쪼개서</em>,  작게 쪼개진 문제를 하나씩 <em>해결</em> 해나감으로써<br>작은 솔루션들이 모여 전체 문제에 대한 솔루션을 구하는 기법.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OOP-꼭-공부해야-함&quot;&gt;&lt;a href=&quot;#OOP-꼭-공부해야-함&quot; class=&quot;headerlink&quot; title=&quot;OOP (꼭 공부해야 함)&quot;&gt;&lt;/a&gt;OOP (꼭 공부해야 함)&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;캡슐화(encapsulation) :
      
    
    </summary>
    
      <category term="CS TIL" scheme="https://dearjsmc4.github.io/categories/cs-til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0419</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0419/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0419/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T10:42:47.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="파이썬-기초와-알고리즘-3일차"><a href="#파이썬-기초와-알고리즘-3일차" class="headerlink" title="파이썬 기초와 알고리즘 3일차"></a>파이썬 기초와 알고리즘 3일차</h1><p><code>.replace()</code> - 원본의 데이터를 바꾸지 않음.  </p><ul><li><p>튜플은 <strong>성능 최적화</strong>를 위해 존재.<br>데이터를 바꿀 수 없기 때문에 데이터를 가져와서 읽는 용도로만 사용한다.<br>리스트보다 빠르다. 튜플을 쓸 수 있다면 튜플을 쓸 것.  </p></li><li><p>딕셔너리 = “Collection of Pairs”<br>pair = <code>key : item</code><br>키와 밸류가 한 쌍으로 모여있다.  </p></li><li><p>뷰객체와 리스트객체의 차이<br>원본에 데이터를 추가했을 때 뷰 객체에서는 변경사항이 저장되지만 리스트는 안됨.  </p></li></ul><p>파이썬은 단순성이 존재목적.  </p><ul><li>expression: 식.<br>무언가를 반환할 수 있다면 그것은 식이다.<br>단항식 역시 참과 거짓, 혹은 값 자체를 반환할 수 있으므로 식이다.  </li></ul><p>a+b : <code>이항식. binary expression</code><br>“abc” : <code>단항식 unary expression</code>  </p><p>파이썬에서는 함수도 식이다.<br>식이라면 반드시 무언가를 반환해야 한다.<br>print() 도 함수고, 반환이 없어보이지만 실제로는 none 을 반환함.  </p><p><code>stdin</code> : standard input (키보드), 0<br><code>stdout</code> : standard output (모니터), 1<br><code>stderr</code> : standard error (모니터), 2  </p><h2 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h2><ul><li>ASCII  </li><li><p>UNICODE  </p><ul><li>UTF-8  </li><li>UTF-16  </li><li>UTF-32  </li><li>~CP949~  </li></ul></li><li><p>문자집합 :<br>영어, 불어, 독일어는 언어체계는 다르지만 같은 문자집합을 공유한다.  </p></li><li><p>문자 인코딩 : 모스부호처럼 문자를 부호화하는 것.<br>  반대로 모스부호를 문자로 만드는 것은 복호화.  </p></li><li><p>코트 포인트 : 내 맘대로 a를 13으로 바꿀 수 없다. 전세계 사람들이 약속을 해야 한다.<br>  a = 97 일때, a는 chracter 고, 97은 코드포인트. 어떠한 문자에 매핑되어있는 숫자.<br>  이렇게 매핑된 문자와 숫자를 테이블로 정리를 해놓은 것이 ASCII.  </p></li></ul><p>ASCII의 치명적 약점 : </p><ol><li>7비트만 사용할 수 있고 127개까지만 문자가 매핑되어있다.  </li><li>영어밖에 없다.  </li></ol><p>-&gt; <strong>UNICODE</strong><br>16비트짜리 평면을 17개 만들었다.<br>ASCII 코드가 임베디드 되어 있다.  </p><ul><li>UTF-8<ul><li>8비트 기반</li><li>아스키에 소속된 영어는 여전히 1바이트, 한글은 3바이트로 저장됨  </li></ul></li></ul><p>big endian &amp; little endian &amp; endian less(빅, 리틀 상관없이 그 자체가 저장됨)  </p><ul><li>단순 정렬 알고리즘(bubble sort)<br><a href="https://blueshirudy.tistory.com/13" target="_blank" rel="noopener">과정 정리해본 노트</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;파이썬-기초와-알고리즘-3일차&quot;&gt;&lt;a href=&quot;#파이썬-기초와-알고리즘-3일차&quot; class=&quot;headerlink&quot; title=&quot;파이썬 기초와 알고리즘 3일차&quot;&gt;&lt;/a&gt;파이썬 기초와 알고리즘 3일차&lt;/h1&gt;&lt;p&gt;&lt;code&gt;.replace
      
    
    </summary>
    
      <category term="CS TIL" scheme="https://dearjsmc4.github.io/categories/cs-til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0423-2</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0423-2/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0423-2/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T10:42:58.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="process-와-thread"><a href="#process-와-thread" class="headerlink" title="process 와 thread"></a>process 와 thread</h2><p>process : 인스트럭션의 나열.<br>OS 가 프로세스에게 할당해주는 메모리는 실제 메모리가 아닌 <strong>가상 주소 공간(VAS)</strong><br>각 프로세스에 할당된 메모리는 가상메모리.  </p><h3 id="IPC-InterProcess-Communication-프로세스간-커뮤니케이션"><a href="#IPC-InterProcess-Communication-프로세스간-커뮤니케이션" class="headerlink" title="IPC: InterProcess Communication, 프로세스간 커뮤니케이션"></a>IPC: InterProcess Communication, 프로세스간 커뮤니케이션</h3><p>프로세스간 공간은 완전히 분리되어 있으므로,<br>기본적으로 프로세스끼리 서로의 데이터에 직접적으로 접근하거나 데이터를 바꿀 수는 없다.<br>그럼에도 불구하고 별도로 커뮤니케이션을 해야 할 때가 있다.<br>성능을 높이기 위해 여러 프로세스를 동시에 실행할 때<br>( ex) 웹 서버가 사용자 요청이 올 때마다 새로운 프로세스를 만들어 즉시 대응 )<br><em>프로세스간 상태 확인 및 데이터 송수신</em> 이 필요하기 때문이다. 이때 쓰는 것이 IPC기법이다.<br>대부분의 IPC기법은 각 프로세스가 공유하는 커널공간을 이용한다.  </p><ul><li><p>Shared resource</p></li><li><p>Multi Threading<br>여러 개의 실행흐름이 필요하다 -&gt; concurrency programming<br>동시에 도는 것 같은 실행흐름.  </p></li></ul><p>스레드는 프로세스에 포함된 개념.<br>우리가 만든 프로그램은 스레드가 하나.<br>스레드가 하나면 <code>싱글스레드</code>.<br>자바스크립트는 흐름이 하나밖에 없는 것.  </p><h3 id="멀티스레딩"><a href="#멀티스레딩" class="headerlink" title="멀티스레딩"></a>멀티스레딩</h3><p><code>멀티스레드</code>는 흐름이 여러 개인 것.<br>스레드가 각자의 스택을 따로 가지고 있다.<br>실행흐름이란게 인스트럭션인데 인스트럭션은 함수 실행. 함수가 실행되려면 스택프레임이 필요하고<br>이 스택프레임은 스택에 쌓인다.<br>코드와 데이터와 힙은 공유를 하고 스택만 따로 따로 가지고 있다.<br>여러 개의 스레드가 공유자원을 공유.  </p><p>Shared Resource(각 스레드가 접근하는 하나의 자원) 가 있을 때<br>race condition, 경쟁조건이 발생한다.<br>-&gt; 상호배제 를 통해 예방<br>-&gt; <strong>GIL : Global Interpreter Lock</strong><br>공유자원을 먼저 점유한 스레드가 작업을 마치고 릴리즈를 할 때까지 다른 스레드들이 기다리게 한다.  </p><p>모든 스레드가 접근해서 사용하는 리스트: shared list<br>각 스레드가 접근하는 리스트가 같을 때, 그 안에서 접근하는 데이터는 다른 것이 좋다.  </p><h3 id="동시성-프로그래밍과-병렬-프로그래밍"><a href="#동시성-프로그래밍과-병렬-프로그래밍" class="headerlink" title="동시성 프로그래밍과 병렬 프로그래밍"></a>동시성 프로그래밍과 병렬 프로그래밍</h3><p><strong>동시성 프로그래밍</strong>은 cpu(프로세스)가 하나여도 동시성 프로그래밍을 구현할 수 있다.<br>멀티스레딩을 하게되면 라운드로빈으로 돌아갈 수 있으니까.<br>하지만 여러 개를 하나씩 순서대로 돌리는거지, 엄밀한 의미의 병렬은 아니다.<br><strong>병렬 프로그래밍</strong>은 아예 하드웨어가 최소 두 개 이상 있어서<br>어떤 태스크가 있을 때 각 하드웨어가 일을 같이 처리하는 것이다.<br>2초 걸릴 일을 1초만에 할 수 있는 것이다.  </p><p>싱글코어 멀티스레딩: 단순하게 동시성프로그래밍. 스레드를 여러 개 만들어서 실행.<br>멀티코어 멀티스레딩: 병렬 + 동시성. 동시에 두 개 이상 돌 수 있는 것.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;process-와-thread&quot;&gt;&lt;a href=&quot;#process-와-thread&quot; class=&quot;headerlink&quot; title=&quot;process 와 thread&quot;&gt;&lt;/a&gt;process 와 thread&lt;/h2&gt;&lt;p&gt;process : 인스트럭
      
    
    </summary>
    
      <category term="CS TIL" scheme="https://dearjsmc4.github.io/categories/cs-til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0426</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0426/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0426/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T10:43:11.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ADT-abstract-data-type-추상-자료형"><a href="#ADT-abstract-data-type-추상-자료형" class="headerlink" title="ADT(abstract data type), 추상 자료형"></a>ADT(abstract data type), 추상 자료형</h2><p>자료구조의 인터페이스(함수 시그니쳐를, 함수 사용법을) 명시해 놓은 것. 기능 명세.<br>구체적인 구현설명이 들어가면 안 된다.<br>-&gt; 인터페이스와 내부구현의 분리, 추상화.  </p><p>이미 존재하는 자료구조를 이용해서 새로운 자료구조를 구현.<br>스택 구현 방법:  </p><ol><li>배열  </li><li>연결 리스트  </li><li>파이썬의 리스트  </li></ol><h3 id="스택"><a href="#스택" class="headerlink" title="스택"></a>스택</h3><p>접시쌓기를 생각해보자.<br>접시를 하나씩 위로 쌓는다면 보통은 위에서부터 하나씩 가져간다.<br>이처럼, 데이터1, 데이터2, 데이터3, 데이터4 가 쌓였을 때 데이터4 부터 먼저 사라지는 것.<br>제일 나중에 들어오면 제일 먼저 나간다. : <code>Last In First Out</code> = 후입선출  </p><p>pop: 삭제하면서 반환<br>peek: 다음으로 나올 데이터를 반환만 하고 삭제하지 않음  </p><p>일반적으로 스택의 맨 위 데이터는 top 으로 가리킨다.  </p><p><em>나중에 꼭 풀어볼 것</em>  </p><ol><li>후위 표기법 계산기  </li><li>미로찾기  </li></ol><h3 id="큐"><a href="#큐" class="headerlink" title="큐"></a>큐</h3><p>줄서기와 같다.<br>맨 처음에 데이터1이 들어오고 그 다음에 데이터2, 데이터3가 들어온다면<br>제일 먼저 온 데이터1이 먼저 나간다. : <code>First In First Out</code> = 선입선출  </p><h2 id="연결-리스트-linked-list"><a href="#연결-리스트-linked-list" class="headerlink" title="연결 리스트(linked list)"></a>연결 리스트(linked list)</h2><ol><li><code>싱글 링크드 리스트</code><br>노드가 데이터 + 링크<br>싱글 링크드 리스트의 노드는 데이터에 대한 링크가 하나이다.<br>링크가 하나만 있으면 양방향이 아니게 된다.<br>1 -&gt; 2 -&gt; 1 이 안 됨.  </li><li><code>더미 더블 링크드 리스트</code> -&gt; 이중 연결 리스트<br>노드가 링크 + 데이터 + 링크<br>링크가 두 개이기 때문에 양방향이다.<br>1 -&gt; 2 -&gt; 1 이 가능함. </li></ol><p><code>더미 노드</code>:  </p><ul><li>데이터가 없다  </li><li><p>구현 편의성이 높아지면서 에러 가능성이 낮다<br>  구현이 좋아진다 = 프로그래머의 실수를 줄일 수 있다<br><code>dummy</code>(head)~<code>1</code>~<code>2</code>~<code>3</code>~<code>dummy</code>(tail)</p></li><li><p>delete<br>reference count 가 0 이 되면<br>(어떤 값을 참조하는 것들이 모두 사라지면)<br>garbage collection 에 의해 사라진다.  </p></li></ul><p>delete 도 이와 비슷하게<br>지우려는 노드를 참조하는 다른 노드의 연결을 끊어버리면 된다.  </p><h2 id="배열과-링크드리스트의-차이"><a href="#배열과-링크드리스트의-차이" class="headerlink" title="배열과 링크드리스트의 차이"></a>배열과 링크드리스트의 차이</h2><p><strong>배열 :</strong><br>실제 메모리에도 데이터가 일렬로 들어간다.<br>인덱싱이 가능하므로 검색도 빠르다. O(1)<br>단, 데이터 삽입이나 삭제를 할 때 최악의 경우 O(n)<br>검색을 자주 할 때 배열을 쓴다.  </p><p><strong>연결리스트 :</strong><br>실제 메모리에서 데이터가 일렬로 들어가지 않고 흩어져있으며 서로 연결되어 있다.<br>인덱싱을 하려면 모든 데이터를 순회해야 하므로 검색이 느리다. O(n)<br>데이터 삽입을 할 때 싱글 링크드 리스트의 경우 O(1),<br>더블 링크드 리스트의 경우도 O(1).<br>삽입과 삭제를 자주 할 때 연결리스트를 쓴다.  </p><h1 id="앞으로-공부하라고-하신-내용"><a href="#앞으로-공부하라고-하신-내용" class="headerlink" title="앞으로 공부하라고 하신 내용"></a>앞으로 공부하라고 하신 내용</h1><p>linked list, stack, queue 는 선형 자료구조.<br>앞으로는 비선형 자료구조도 공부해야 할 것.  </p><ul><li>tree(이진트리)  <ul><li>순회(travorsal)  <ul><li>전위(preorder)  </li><li>중위(inorder)  </li><li>후위(postorder)<br>-&gt; 전위, 중위, 후위는 스택의 일종이고, 스택은 DFS의 일종.<br>  반복문과 재귀로 구현  </li><li>레벨 순서(level order)  </li></ul></li></ul></li><li>BST(Binary Search Tree)<br>  O(n^2)  </li><li><p>균형이진트리 (Balanced, self balancing)  </p><ul><li>AVL 트리  </li><li>RED-BLACK 트리  </li></ul></li><li><p>B-Tree (데이터베이스의 인덱스에 쓰임)<br>  : 균형이진트리 + 하드웨어 아키텍쳐  </p></li><li><p>Heap (완전이진트리, 배열로 구현한다)  </p></li><li><p>Hash Table(map)  </p><ul><li>hash function  </li><li>collision(충돌)  <ul><li>chaining(체이닝)  </li><li>open-addressing 기법  </li></ul></li></ul></li><li><p>Graph(그래프)  </p><ul><li>순회  <ul><li>DFS (깊이 우선 탐색) -&gt; 스택 기반  </li><li>BFS (너비 우선 탐색) -&gt; 큐 기반  </li></ul></li><li>MST(Minimum Spanning Tree) 최소 신장 트리  <ul><li>그리디 알고리즘 기반  </li><li>kruskal algorithm  </li><li>prim algorithm  </li></ul></li><li>최단 경로 문제(shortest path)  <ul><li>dijkstra algorithm -&gt; 그리디 알고리즘  </li><li>Balman-ford algorithm  </li><li>flord-warshall -&gt; 다이나믹 프로그래밍  </li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ADT-abstract-data-type-추상-자료형&quot;&gt;&lt;a href=&quot;#ADT-abstract-data-type-추상-자료형&quot; class=&quot;headerlink&quot; title=&quot;ADT(abstract data type), 추상 자료형&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="CS TIL" scheme="https://dearjsmc4.github.io/categories/cs-til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0418</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0418/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0418/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T10:42:39.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="파이썬-기초와-알고리즘-2일차"><a href="#파이썬-기초와-알고리즘-2일차" class="headerlink" title="파이썬 기초와 알고리즘 2일차"></a>파이썬 기초와 알고리즘 2일차</h1><p>프로그래머는 프로그래밍(추상화) 하는 사람.  </p><ul><li>Procedual Programming : 함수를 통한 추상화<br>함수(function, (routine, procedure, subroutine))  </li><li>OOP(Object-Oriented Programming) : 객체를 통한 추상화  </li></ul><h3 id="함수에서의-추상화"><a href="#함수에서의-추상화" class="headerlink" title="함수에서의 추상화"></a>함수에서의 추상화</h3><p>함수 시그니쳐/인터페이스 와 내부구현을 구분하기  </p><ul><li>함수 시그니쳐(Function Signature)<br>-&gt; 함수 이름, 매개변수(parameter, argument), 결과값(반환)  </li><li>인터페이스(Interface)  </li><li>내부 구현(Implementation)  </li></ul><p>나는 <code>Math.pow()</code>함수를 사용할 때 내부 구현을 몰라도, 함수 시그니쳐만 알면 사용할 수 있다.<br>자바스크립트를 만든 사람들은 내부 구현을 맡아서 하는 것이고,<br>유저 프로그래머는 인터페이스만 알면 된다.<br>함수 시그니쳐를 모아놓은 것 -&gt; documentation  </p><h3 id="시그니쳐를-설계할-때-주의할-점"><a href="#시그니쳐를-설계할-때-주의할-점" class="headerlink" title="시그니쳐를 설계할 때 주의할 점"></a>시그니쳐를 설계할 때 주의할 점</h3><ol><li>함수 이름은 누가 봐도 이 함수가 하는 일이 뭔지 알 수 있게 지어야 한다.  </li><li>매개변수와 리턴값을 잘 설계해야 한다.<br>어떤 함수를 설계했을 때, 그 함수의 리턴값을 이용해 또다른 함수를 실행할 때 문제가 없도록.<br>예를 들어 내가 만든 함수는 문자형을 반환하는데, 다른 사람이 만든 함수가 숫자형을 매개변수로 받는 경우.<br>-&gt; “인터페이스도 안 맞추고 일하냐, 가관이다.” 소리가 나오는 상황.<br>-&gt; 기능 명세  </li></ol><h2 id="실수-real-number"><a href="#실수-real-number" class="headerlink" title="실수(real number)"></a>실수(real number)</h2><h3 id="부동-소수점"><a href="#부동-소수점" class="headerlink" title="부동 소수점"></a>부동 소수점</h3><ol><li><p>32비트로 실수를 표현하기 : <strong>단정도</strong> </p></li><li><p>64비트로 실수를 표현하기 : <strong>배정도</strong> -&gt; 자바스크립트  </p></li></ol><ul><li>첫 번째 비트는 부호를 의미 한다.  </li><li>가수부(mantissa)가 52bit 이다.  </li></ul><h3 id="64-실수-자료형-설계하기"><a href="#64-실수-자료형-설계하기" class="headerlink" title="64 실수 자료형 설계하기"></a>64 실수 자료형 설계하기</h3><p>실수 자료형을 표현한 수식<br><code>± 1.man × 2^exp - bias</code><br>1.man 은 가수(mantissa), 2는 밑수, exp-bias 는 지수(exponent)  </p><h4 id="정규화"><a href="#정규화" class="headerlink" title="정규화"></a>정규화</h4><p>정수부분을 0이 아닌 자연수로 만들기.<br>ex) 5234.433 -&gt; 5.234433 * 10^3  </p><ul><li>10진수 실수 10.625를 2진수 실수로 바꾸고 정규화<br>10.625 -&gt; 1010.101(2) -&gt; <code>1</code>.010101(2) * 2^3  </li></ul><p>2진수의 경우 0이 아닌 자연수는 1밖에 없다.<br>그래서 실제 가수부는 1.010101 이지만<br>정수부분을 뺀 소수부분 <code>010101</code> 을 가수부(mantissa)에 저장한다.<br>(나머지 부분은 0으로 채운다)<br>배정도의 가수부는 52bit 이지만,<br>-&gt; <code>&gt;&gt;&gt; sys.float_info.mant_dig</code> 이 53이었던 이유.  </p><p>(+)</p><p>10진수를 2진수가 커버할 때,<br>한 자리 수 중에 가장 큰 수인 9를 커버하려면<br>2진수 4자리가 필요하다. <code>1111(2) = 15</code><br>두 자리 수 중에 가장 큰 수인 99를 커버하려면<br>7자리가 필요하다. <code>1111111(2) = 127</code>  </p><p>이때, 가수부를 53자리까지 (맨 앞의 1 포함) 키운다면<br>9,007,199,254,740,991 까지 커버할 수 있고, 총 15자리이다.<br>-&gt; <code>&gt;&gt;&gt; sys.float_info.dig</code> 가 15인 이유.  </p><h4 id="exp-bias"><a href="#exp-bias" class="headerlink" title="exp-bias"></a>exp-bias</h4><p>1.010101(2) * 2^<code>3</code><br>지수를 저장하기.  </p><p><code>± 1.man * 2^exp-bias</code><br>즉, 3이 exp-bias 이다.<br>bias 는 음수를 지원하기 위해 IEEE 가 자체적으로 만든 프로토콜.<br>ex) 만약 -8 을 저장해야 한다면?  </p><p>double 의 bias 를 구하는 식은,<br><code>bias = 2^n-1 - 1</code><br>n은 지수부의 비트 수를 뜻한다.<br>double 의 지수부의 비트 수는 11bit 이므로,<br>bias = 2^11-1 - 1<br>bias = 2^10 - 1 = 1023  </p><p>지수부에는 3이 들어가야 맞는 것이지만, 편향치를 고려하여 저장해야 한다.<br>내가 저장해야 하는 실제 지수 값과 편향치를 안다면 메모리에 저장할 값도 알 수 있다.  </p><p><code>Ere = Emem - bias</code><br>즉, <code>Emem = Ere + bias</code>  </p><p>Emem = 3 + 1023 = 1026 이 된다.  </p><p><strong>이제 필요한 값은 다 구했다</strong>  </p><p><code>± 1.man × 2^exp - bias</code>  </p><ol><li>sign : 0  </li><li>exponent(exp - bias) : Emem = 1026 = 01000000001(2)  </li><li>mantissa : 010101000000…. (52bit를 채울 때까지 0을 넣는다)  </li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;파이썬-기초와-알고리즘-2일차&quot;&gt;&lt;a href=&quot;#파이썬-기초와-알고리즘-2일차&quot; class=&quot;headerlink&quot; title=&quot;파이썬 기초와 알고리즘 2일차&quot;&gt;&lt;/a&gt;파이썬 기초와 알고리즘 2일차&lt;/h1&gt;&lt;p&gt;프로그래머는 프로그래밍(추
      
    
    </summary>
    
      <category term="CS TIL" scheme="https://dearjsmc4.github.io/categories/cs-til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 공학 TIL 0422</title>
    <link href="https://dearjsmc4.github.io/2019/05/03/0422/"/>
    <id>https://dearjsmc4.github.io/2019/05/03/0422/</id>
    <published>2019-05-03T02:45:18.000Z</published>
    <updated>2019-05-03T10:42:50.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1><ol><li>namespace  </li><li>stack frame  </li><li>call by value<br>call by reference<br>call by object reference  </li></ol><p><em>“왜 call by value 와 call by reference 를 나누는가?”</em>  </p><h2 id="전역변수-vs-지역변수"><a href="#전역변수-vs-지역변수" class="headerlink" title="전역변수 vs 지역변수"></a>전역변수 vs 지역변수</h2><ul><li>지역변수가 생기는 시점은?<br><code>def func(): b=20</code><br>라고 함수를 선언해둘 때가 아니라, 함수를 실행할 때.  </li></ul><p>namespace = 변수가 저장되어 있는 공간. 함수가 가지는 자기만의 공간.  </p><h2 id="stack-frame"><a href="#stack-frame" class="headerlink" title="stack frame"></a>stack frame</h2><p>함수가 실행될 때 함수 내부적으로 연산에 필요한 지역변수들이 쌓이는 공간.<br>블로킹이 걸리면 새로운 함수에게 다시 주도권이 넘어감.<br>함수 실행(연산)이 끝나면 연산에 필요한 변수들은 사라지고 스택프레임도 사라짐.<br>그리고 블로킹 걸렸던 시점에서부터 다시 실행이 되고 원래 함수에게 주도권 넘어감.<br>함수 실행이 종료되면 연산에 필요없는 변수가 다 사라지고,<br>실행 주도권은 다시 글로벌 프레임으로 넘어온다.<br>(파이썬 튜터로 스택프레임을 비주얼적으로 보면 좋다.)  </p><ul><li>call by value :<br>  변수의 값 10을 복사해서 단순히 <strong>값</strong>을 스택프레임에 넘겨주는 것.  </li><li>call by reference :<br>  변수의 값이 아니라 <strong>주소값</strong>을 전달함. = 참조값을 전달하는 것과 같다.<br>  주소값을 알고 잇으면 주소값을 통해 접근할 수 있다.<br>  원래 블로킹 상태라면, 실행 중인 함수의 프레임을 벗어나서 참조할 수 없는데,<br>  주소값으로 전달하면 주소값을 참조하여 <strong>현재 실행중인 프레임의 바깥 스택프레임의 변수에 접근할 수 있다.</strong><br>  <code>*a = 30</code> -&gt; a의 메모리 자체에 접근하여, 그 메모리에 값 30을 넣겠다.  </li></ul><p><strong>call by value와 call by reference의 차이</strong><br>-&gt; 새로운 스택프레임이 쌓였을 때  </p><ul><li>call by value : 그 어떤 변수를 이용하더라도 바깥으로 접근할 수 없다.<br>실행하고 있는 프레임 바깥의 데이터에 접근하는게 완벽히 불가능하다.  </li><li>call by reference : 스택프레임이 갈라지고, 새로운 프레임이 실행하는 상황에서 특정 변수를 이용해<br>바깥 프레임의 데이터에 접근하여 값을 수정하는 것이 가능하다.  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;함수&quot;&gt;&lt;a href=&quot;#함수&quot; class=&quot;headerlink&quot; title=&quot;함수&quot;&gt;&lt;/a&gt;함수&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;namespace  &lt;/li&gt;
&lt;li&gt;stack frame  &lt;/li&gt;
&lt;li&gt;call by value&lt;br&gt;cal
      
    
    </summary>
    
      <category term="CS TIL" scheme="https://dearjsmc4.github.io/categories/cs-til/"/>
    
    
      <category term="CS" scheme="https://dearjsmc4.github.io/tags/cs/"/>
    
      <category term="TIL" scheme="https://dearjsmc4.github.io/tags/til/"/>
    
  </entry>
  
</feed>
